This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-17T06:08:54.422Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  actions/
    auth.ts
    products.ts
    settings.ts
    upload.ts
  api/
    auth/
      callback/
        route.ts
      creation/
        route.ts
      storage-token/
        route.ts
      sync/
        route.ts
    market-stand/
      [id]/
        route.ts
      route.ts
    product/
      route.ts
    stripe/
      connect/
        success/
          route.ts
        route.ts
      route.ts
    upload/
      route.ts
    user/
      route.ts
  auth-error/
    page.tsx
  billing/
    page.tsx
  dashboard/
    market-stand/
      page.tsx
    sell/
      page.tsx
    settings/
      page.tsx
    layout.tsx
    page.tsx
  market-stand/
    [id]/
      edit/
        page.tsx
      page.tsx
    grid/
      page.tsx
    map/
      loading.tsx
      page.tsx
    setup/
      loading.tsx
      page.tsx
    page.tsx
  navigate/
    [id]/
      page.tsx
  payment/
    cancel/
      page.tsx
    success/
      page.tsx
  product/
    [id]/
      edit/
        loading.tsx
        page.tsx
      loading.tsx
      page.tsx
  return/
    [id]/
      page.tsx
  sell/
    loading.tsx
    page.tsx
    sell-client.tsx
  settings/
    loading.tsx
    page.tsx
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  form/
    AuthForm.tsx
    MarketStandForm.tsx
    Sellform.tsx
    SettingsForm.tsx
    SubmitStandButton.tsx
  providers/
    SupabaseProvider.tsx
  ui/
    avatar.tsx
    button.tsx
    card.tsx
    carousel.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    tabs.tsx
    textarea.tsx
  AuthDialog.tsx
  Editor.tsx
  FloatingTimer.tsx
  ImageUpload.tsx
  InventoryManager.tsx
  MapView.tsx
  MarketStandCard.tsx
  MarketStandQR.tsx
  MarketStandSelect.tsx
  MarketStandsMap.tsx
  MarketStandViewNav.tsx
  MobileMenu.tsx
  Navbar.tsx
  NavbarLinks.tsx
  NewestProducts.tsx
  PaymentTab.tsx
  ProductCard.tsx
  ProductDashboardCard.tsx
  ProductDescription.tsx
  ProductEmail.tsx
  ProductRow.tsx
  ProductTimer.tsx
  StripeConnectButton.tsx
  SubmitButtons.tsx
  UserNav.tsx
lib/
  auth.ts
  db.ts
  stripe.ts
  supabase-browser.ts
  supabase-server.ts
  utils.ts
prisma/
  migrations/
    20241229030000_add_location_details/
      migration.sql
    20241229164310_add_product_inventory_and_timestamp/
      migration.sql
    20241229184041_add_inventory_timestamp/
      migration.sql
    20250115020106_add_tags_to_models/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  logos/
    cornucopia-dark.svg
    cornucopia.svg
    icon-svg.svg
  next.svg
  vercel.svg
types/
  product.ts
.eslintrc.json
.gitignore
components.json
middleware.ts
next.config.mjs
package.json
postcss.config.js
postcss.config.mjs
tailwind.config.js
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/actions/auth.ts">
'use server'

import { getSupabaseServer } from '@/lib/supabase-server';
import jwt from 'jsonwebtoken';

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL');
}
if (!process.env.SUPABASE_JWT_SECRET) {
  throw new Error('Missing env.SUPABASE_JWT_SECRET');
}

export async function signInWithEmail(email: string, password: string) {
  const supabase = getSupabaseServer();
  
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    throw error;
  }

  return data;
}

export async function signUpWithEmail(email: string, password: string) {
  const supabase = getSupabaseServer();
  
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`,
    },
  });

  if (error) {
    throw error;
  }

  return data;
}

export async function signOut() {
  const supabase = getSupabaseServer();
  await supabase.auth.signOut();
}

export async function getUser() {
  const supabase = getSupabaseServer();
  const { data: { session } } = await supabase.auth.getSession();
  return session?.user ?? null;
}

export async function getSupabaseToken() {
  const user = await getUser();
  
  if (!user || !user.id) {
    throw new Error('Not authenticated');
  }

  // Create a JWT that Supabase will accept
  const payload = {
    aud: 'authenticated',
    exp: Math.floor(Date.now() / 1000) + (60 * 60), // 1 hour from now
    sub: user.id,
    email: user.email,
    role: 'authenticated'
  };

  if (!process.env.SUPABASE_JWT_SECRET) {
    throw new Error('Missing SUPABASE_JWT_SECRET');
  }
  const token = jwt.sign(payload, process.env.SUPABASE_JWT_SECRET as jwt.Secret);
  return token;
}
</file>

<file path="app/actions/products.ts">
'use server'

import prisma from '@/lib/db';

export async function getProducts(userId: string) {
  try {
    const products = await prisma.product.findMany({
      where: {
        userId,
      },
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        images: true,
        inventory: true,
        inventoryUpdatedAt: true,
        status: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
        userId: true,
        totalReviews: true,
        marketStand: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    // Serialize dates for client consumption
    return products.map((product) => ({
      ...product,
      createdAt: product.createdAt.toISOString(),
      updatedAt: product.updatedAt.toISOString(),
      inventoryUpdatedAt: product.inventoryUpdatedAt?.toISOString() || null,
      locationName: product.marketStand?.name || 'Unknown Location',
    }));
  } catch (error) {
    console.error('Error fetching products:', error);
    throw new Error('Failed to fetch products');
  }
}

export async function getLatestProducts(userLocation?: { lat: number; lng: number } | null) {
  try {
    const data = await prisma.product.findMany({
      select: {
        name: true,
        id: true,
        images: true,
        updatedAt: true,
        price: true,
        marketStand: {
          select: {
            id: true,
            name: true,
            latitude: true,
            longitude: true,
          }
        }
      },
      take: 6,
      orderBy: {
        updatedAt: 'desc'
      }
    });

    const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    };

    if (userLocation && userLocation.lat && userLocation.lng) {
      return data.map(product => {
        const distance = product.marketStand ? calculateDistance(
          userLocation.lat,
          userLocation.lng,
          product.marketStand.latitude,
          product.marketStand.longitude
        ) : Infinity;

        return {
          ...product,
          updatedAt: product.updatedAt.toISOString(),
          locationName: product.marketStand ? product.marketStand.name : 'Unknown Location'
        };
      });
    }

    return data.map(product => ({
      ...product,
      updatedAt: product.updatedAt.toISOString(),
      locationName: product.marketStand?.name || 'Unknown Location'
    }));
  } catch (error) {
    console.error('Error fetching products:', error);
    throw new Error('Failed to fetch latest products');
  }
}
</file>

<file path="app/actions/settings.ts">
"use server";

import { createServerSupabaseClient } from "@/lib/auth";
import prisma from "@/lib/db";
import { z } from "zod";

const userSettingsSchema = z.object({
  firstName: z.string().min(1, { message: "First name is required" }),
  lastName: z.string().min(1, { message: "Last name is required" }),
});

export type State = {
  status: "error" | "success" | undefined;
  message: string | null;
};

export async function UpdateUserSettings(prevState: State, formData: FormData): Promise<State> {
  const supabase = createServerSupabaseClient();
  const { data: { session } } = await supabase.auth.getSession();
  const user = session?.user;

  if (!user) {
    return {
      status: "error",
      message: "Not authenticated"
    };
  }

  const validateFields = userSettingsSchema.safeParse({
    firstName: formData.get("firstName")?.toString() ?? "",
    lastName: formData.get("lastName")?.toString() ?? "",
  });

  if (!validateFields.success) {
    return {
      status: "error",
      message: "Please check your inputs and try again."
    };
  }

  try {
    await prisma.user.update({
      where: {
        id: user.id
      },
      data: {
        firstName: validateFields.data.firstName,
        lastName: validateFields.data.lastName,
      }
    });

    return {
      status: "success",
      message: "Settings updated successfully"
    };
  } catch (error) {
    return {
      status: "error",
      message: "Failed to update settings. Please try again."
    };
  }
}
</file>

<file path="app/actions/upload.ts">
'use server'

import { getUser } from '@/lib/auth';
import { createServerSupabaseClient } from '@/lib/auth';

export async function uploadImageWithAuth(
  fileBase64: string,
  filename: string,
  bucket: string = 'images',
  path: string = ''
): Promise<string> {
  const user = await getUser();
  if (!user) {
    throw new Error('Authentication required for image upload');
  }

  const supabase = createServerSupabaseClient();
  const fileName = `${path}${Date.now()}-${filename}`;
  
  // Convert base64 to buffer
  const base64Data = fileBase64.split(',')[1] || fileBase64;
  const buffer = Buffer.from(base64Data, 'base64');

  const { data, error } = await supabase.storage
    .from(bucket)
    .upload(`${user.id}/${fileName}`, buffer, {
      cacheControl: '3600',
      upsert: false,
    });

  if (error) {
    console.error('Upload error:', error);
    throw error;
  }

  const { data: urlData } = await supabase.storage
    .from(bucket)
    .getPublicUrl(`${user.id}/${data.path}`);

  if (!urlData.publicUrl) {
    throw new Error('Failed to get public URL');
  }

  return urlData.publicUrl;
}

export async function uploadImagesWithAuth(
  files: { base64: string; name: string }[],
  bucket?: string,
  path?: string
): Promise<string[]> {
  const uploadPromises = files.map(file => 
    uploadImageWithAuth(file.base64, file.name, bucket, path)
  );
  return Promise.all(uploadPromises);
}
</file>

<file path="app/api/auth/callback/route.ts">
import { getSupabaseServer } from '@/lib/supabase-server';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  try {
    const requestUrl = new URL(request.url);
    const code = requestUrl.searchParams.get('code');
    const next = requestUrl.searchParams.get('next') || '/dashboard';

    // Handle email confirmation for sign up
    const type = requestUrl.searchParams.get('type');
    if (type === 'signup' && !code) {
      return NextResponse.redirect(
        `${requestUrl.origin}/?message=Please check your email to confirm your account`
      );
    }

    // Validate the code parameter for other auth flows
    if (!code) {
      console.error('No code provided in callback');
      return NextResponse.redirect(`${requestUrl.origin}/auth-error?error=no_code`);
    }

    const supabase = getSupabaseServer();

    // Exchange the code for a session
    const { data, error } = await supabase.auth.exchangeCodeForSession(code);
    
    if (error) {
      console.error('Auth callback error:', error);
      return NextResponse.redirect(`${requestUrl.origin}/auth-error?error=session_error`);
    }

    if (!data.session) {
      console.error('No session created');
      return NextResponse.redirect(`${requestUrl.origin}/auth-error?error=no_session`);
    }

    // Create response with redirect and set session
    const response = NextResponse.redirect(`${requestUrl.origin}/dashboard`);
    await supabase.auth.setSession(data.session);

    // Use the provided next parameter or fall back to dashboard
    return NextResponse.redirect(new URL(next, requestUrl.origin));
  } catch (error) {
    console.error('Auth callback error:', error);
    // Include error details in the redirect for better debugging
    const errorMessage = encodeURIComponent((error as Error).message);
    return NextResponse.redirect(
      `${new URL(request.url).origin}/auth-error?error=unexpected&message=${errorMessage}`
    );
  }
}
</file>

<file path="app/api/auth/creation/route.ts">
import prisma from "@/lib/db";
import { getSupabaseServer } from '@/lib/supabase-server';
import { NextResponse } from "next/server";
import { unstable_noStore as noStore } from "next/cache";

export async function GET(request: Request) {
  noStore();
  const supabase = getSupabaseServer();
  const { data: { session } } = await supabase.auth.getSession();

  if (!session?.user) {
    throw new Error("Not authenticated");
  }

  const user = session.user;

  let dbUser = await prisma.user.findUnique({
    where: {
      id: user.id,
    },
  });

  if (!dbUser) {
    // Create user without Stripe integration for now
    dbUser = await prisma.user.create({
      data: {
        id: user.id,
        firstName: user.user_metadata?.name?.split(' ')[0] ?? "",
        lastName: user.user_metadata?.name?.split(' ')[1] ?? "",
        email: user.email ?? "",
        profileImage:
          user.user_metadata?.avatar_url ?? `https://avatar.vercel.sh/${user.user_metadata?.name?.split(' ')[0]}`,
        connectedAccountId: null,
        stripeConnectedLinked: false,
      },
    });
  }

  // Use the NEXT_PUBLIC_APP_URL from env or fallback to request origin
  const response = NextResponse.redirect(
    process.env.NEXT_PUBLIC_APP_URL || new URL(request.url).origin
  );


  return response;
}
</file>

<file path="app/api/auth/storage-token/route.ts">
import { createServerSupabaseClient } from "@/lib/auth";
import { getUser } from "@/lib/auth";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    const user = await getUser();
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const supabase = createServerSupabaseClient();

    // Create a scoped token that only allows uploads to the user's directory
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      return new NextResponse("Session error", { status: 401 });
    }

    // Get storage bucket policy
    const { data, error } = await supabase.storage
      .from('products')
      .createSignedUrl(`${user.id}/upload-policy`, 60); // 60 seconds expiry

    if (error) {
      console.error('Storage policy error:', error);
      return new NextResponse("Failed to create upload policy", { status: 500 });
    }

    return NextResponse.json({
      url: data.signedUrl,
      path: `${user.id}/upload-policy`
    });
  } catch (error) {
    console.error('Storage token error:', error);
    return new NextResponse("Internal server error", { status: 500 });
  }
}
</file>

<file path="app/api/auth/sync/route.ts">
import { getSupabaseServer } from '@/lib/supabase-server';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const { event, session } = await request.json();
    console.log('[Auth Sync] Received event:', event);
    
    // Get server client
    const supabase = getSupabaseServer();
    
    if (event === 'SIGNED_IN') {
      // Set the session cookie
      const response = new NextResponse(JSON.stringify({ status: 'success' }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
      
      // Set auth cookie
      await supabase.auth.setSession(session);
      
      console.log('[Auth Sync] Session synchronized after sign in');
      return response;
    }
    
    if (event === 'SIGNED_OUT') {
      // Clear the session cookie
      const response = new NextResponse(JSON.stringify({ status: 'success' }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      });
      
      // Sign out to clear the session
      await supabase.auth.signOut();
      
      console.log('[Auth Sync] Session cleared after sign out');
      return response;
    }
    
    return new NextResponse(JSON.stringify({ status: 'ignored' }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });
    
  } catch (error) {
    console.error('[Auth Sync] Error:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal Server Error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
</file>

<file path="app/api/market-stand/[id]/route.ts">
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { Prisma } from "@prisma/client";

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  console.log('Market stand by ID API route called:', params.id);
  
  try {
    // Ensure connection is established
    await prisma.$connect();
    
    console.log('Fetching market stand...');
    const marketStand = await prisma.marketStand.findUnique({
      where: {
        id: params.id
      },
      include: {
        products: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            images: true,
            inventory: true,
            inventoryUpdatedAt: true,
            status: true,
            isActive: true,
            createdAt: true,
            updatedAt: true,
            tags: true,
            averageRating: true,
            totalReviews: true
          }
        },
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            profileImage: true
          }
        }
      }
    });

    // Explicitly disconnect after query
    await prisma.$disconnect();

    if (!marketStand) {
      console.error('Market stand not found:', params.id);
      return NextResponse.json(
        { error: 'Market stand not found' },
        { status: 404 }
      );
    }

    console.log('Successfully fetched market stand:', marketStand.id);
    
    // Serialize dates to ISO strings before sending response
    const serializedStand = {
      ...marketStand,
      createdAt: marketStand.createdAt.toISOString(),
      products: marketStand.products.map(product => ({
        ...product,
        createdAt: product.createdAt.toISOString(),
        updatedAt: product.updatedAt.toISOString()
      }))
    };
    
    return NextResponse.json(JSON.parse(JSON.stringify(serializedStand)));
  } catch (error) {
    // Ensure disconnection even on error
    try {
      await prisma.$disconnect();
    } catch (disconnectError) {
      console.error('Error disconnecting from database:', disconnectError);
    }

    console.error('Failed to fetch market stand:', {
      error,
      message: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return NextResponse.json(
      { error: 'Failed to fetch market stand. Please try again.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/market-stand/route.ts">
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import { Prisma } from "@prisma/client";

type MarketStandWithRelations = Prisma.MarketStandGetPayload<{
  select: {
    id: true;
    name: true;
    description: true;
    images: true;
    latitude: true;
    longitude: true;
    locationName: true;
    locationGuide: true;
    createdAt: true;
    tags: true;
    products: {
      select: {
        id: true;
        name: true;
        description: true;
        price: true;
        images: true;
        createdAt: true;
        updatedAt: true;
      };
    };
    user: {
      select: {
        firstName: true;
        profileImage: true;
      };
    };
  };
}>;

export async function GET() {
  console.log('Market stand API route called');
  
  try {
    // Ensure connection is established
    await prisma.$connect();
    
    console.log('Fetching market stands...');
    const marketStands = await prisma.marketStand.findMany({
      take: 10,
      orderBy: {
        createdAt: 'desc'
      },
      select: {
        id: true,
        name: true,
        description: true,
        images: true,
        latitude: true,
        longitude: true,
        locationName: true,
        locationGuide: true,
        createdAt: true,
        tags: true,
        products: {
          select: {
            id: true,
            name: true,
            description: true,
            price: true,
            images: true,
            createdAt: true,
            updatedAt: true
          }
        },
        user: {
          select: {
            firstName: true,
            profileImage: true
          }
        }
      }
    });

    // Explicitly disconnect after query
    await prisma.$disconnect();

    if (!marketStands || !Array.isArray(marketStands)) {
      console.error('Invalid market stands response:', marketStands);
      throw new Error('Invalid response from database');
    }

    console.log('Successfully fetched market stands:', {
      count: marketStands.length,
      hasData: marketStands.length > 0
    });
    
    // Serialize dates to ISO strings before sending response
    // Double serialize to handle any non-serializable objects
    const serializedStands = marketStands.map(stand => ({
      ...stand,
      createdAt: stand.createdAt.toISOString(),
      products: stand.products.map(product => ({
        ...product,
        createdAt: product.createdAt.toISOString(),
        updatedAt: product.updatedAt.toISOString()
      }))
    }));
    
    return NextResponse.json(JSON.parse(JSON.stringify(serializedStands)));
  } catch (error) {
    // Ensure disconnection even on error
    try {
      await prisma.$disconnect();
    } catch (disconnectError) {
      console.error('Error disconnecting from database:', disconnectError);
    }

    console.error('Failed to fetch market stands:', {
      error,
      message: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return NextResponse.json(
      { error: 'Failed to fetch market stands. Please try again.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/product/route.ts">
import prisma from "@/lib/db";
import { NextResponse } from "next/server";
import { getUser } from "@/lib/auth";

export async function PATCH(req: Request) {
  try {
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const body = await req.json();
    const { id, inventory } = body;

    if (!id || typeof inventory !== 'number') {
      return new NextResponse("Invalid request data", { status: 400 });
    }

    // Check if product exists and belongs to user
    const product = await prisma.product.findUnique({
      where: {
        id,
        userId: user.id
      }
    });

    if (!product) {
      return new NextResponse("Product not found or unauthorized", { status: 404 });
    }

    // Update product inventory with user check
    const updatedProduct = await prisma.product.update({
      where: {
        id,
        userId: user.id // Ensure user owns the product
      },
      data: {
        inventory,
        inventoryUpdatedAt: new Date()
      }
    });

    return NextResponse.json(updatedProduct);
  } catch (error) {
    console.error("[PRODUCT_PATCH]", error);
    return new NextResponse("Internal error", { status: 500 });
  }
}

export async function PUT(req: Request) {
  try {
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const body = await req.json();
    const { id, ...updateData } = body;

    if (!id) {
      return new NextResponse("Invalid request data", { status: 400 });
    }

    // Check if product exists and belongs to user
    const product = await prisma.product.findUnique({
      where: {
        id,
        userId: user.id
      }
    });

    if (!product) {
      return new NextResponse("Product not found or unauthorized", { status: 404 });
    }

    // Update product with user check
    const updatedProduct = await prisma.product.update({
      where: {
        id,
        userId: user.id // Ensure user owns the product
      },
      data: {
        ...updateData,
        updatedAt: new Date()
      }
    });

    return NextResponse.json(updatedProduct);
  } catch (error) {
    console.error("[PRODUCT_PUT]", error);
    return new NextResponse("Internal error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/connect/success/route.ts">
import { NextResponse } from "next/server";
import prisma from "../../../../../lib/db";

export async function GET(request: Request) {
  try {
    // 1. Verify user authentication
    const user = await getUser();

    if (!user || !user.id) {
      console.error("[STRIPE_CONNECT_SUCCESS_ERROR] User not authenticated");
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // 2. Verify environment variables
    if (!process.env.NEXT_PUBLIC_APP_URL) {
      console.error("[STRIPE_CONNECT_SUCCESS_ERROR] NEXT_PUBLIC_APP_URL not set");
      return new NextResponse("Server configuration error", { status: 500 });
    }

    // 3. Update user's Stripe connection status
    try {
      const updatedUser = await prisma.user.update({
        where: { id: user.id },
        data: { stripeConnectedLinked: true },
        select: { connectedAccountId: true }
      });

      if (!updatedUser.connectedAccountId) {
        console.error("[STRIPE_CONNECT_SUCCESS_ERROR] No connectedAccountId found for user");
        return new NextResponse("Invalid account state", { status: 400 });
      }

      // 4. Redirect back to dashboard with success message
      const redirectUrl = new URL(`${process.env.NEXT_PUBLIC_APP_URL}/dashboard`);
      redirectUrl.searchParams.set("stripe", "success");
      
      return NextResponse.redirect(redirectUrl.toString());
    } catch (error) {
      console.error("[STRIPE_CONNECT_SUCCESS_ERROR] Failed to update user:", error);
      return new NextResponse("Failed to update account status", { status: 500 });
    }
  } catch (error) {
    console.error("[STRIPE_CONNECT_SUCCESS_ERROR] Unexpected error:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/connect/route.ts">
import { stripe } from "@/lib/stripe";
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import Stripe from "stripe";

export async function POST() {
  try {
    // 1. Verify user authentication
    const user = await getUser();

    if (!user || !user.id) {
      console.error("[STRIPE_CONNECT_ERROR] User not authenticated");
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // 2. Check if user already has a Stripe account
    try {
      const existingUser = await prisma.user.findUnique({
        where: { id: user.id },
        select: { connectedAccountId: true }
      });

      if (existingUser?.connectedAccountId) {
        console.error("[STRIPE_CONNECT_ERROR] User already has connected account", existingUser.connectedAccountId);
        return new NextResponse("Stripe account already connected", { status: 400 });
      }
    } catch (error) {
      console.error("[STRIPE_CONNECT_ERROR] Database error checking existing account:", error);
      return new NextResponse("Database error", { status: 500 });
    }

    // 3. Verify environment variables
    if (!process.env.NEXT_PUBLIC_APP_URL) {
      console.error("[STRIPE_CONNECT_ERROR] NEXT_PUBLIC_APP_URL not set");
      return new NextResponse("Server configuration error", { status: 500 });
    }

    // 4. Create Stripe Connect account
    let account: Stripe.Response<Stripe.Account>;
    try {
      account = await stripe.accounts.create({
        type: "express",
        country: "US",
        email: user.email || undefined,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
        },
        tos_acceptance: {
          service_agreement: 'recipient'
        }
      });
    } catch (error) {
      console.error("[STRIPE_CONNECT_ERROR] Failed to create Stripe account:", {
        error,
        user: {
          id: user.id,
          email: user.email,
        },
        requestData: {
          type: "express",
          country: "US",
          email: user.email || undefined,
          capabilities: {
            card_payments: { requested: true },
            transfers: { requested: true },
          },
          tos_acceptance: {
            service_agreement: 'recipient'
          }
        }
      });
      return new NextResponse("Failed to create Stripe account", { status: 500 });
    }

    // 5. Update user with connected account ID
    try {
      await prisma.user.update({
        where: { id: user.id },
        data: { connectedAccountId: account.id }
      });
    } catch (error) {
      console.error("[STRIPE_CONNECT_ERROR] Failed to update user with account ID:", error);
      // Try to clean up the created Stripe account
      try {
        await stripe.accounts.del(account.id);
      } catch (deleteError) {
        console.error("[STRIPE_CONNECT_ERROR] Failed to delete Stripe account after error:", deleteError);
      }
      return new NextResponse("Failed to update user record", { status: 500 });
    }

    // 6. Create account link for onboarding
    try {
      const accountLink = await stripe.accountLinks.create({
        account: account.id,
        refresh_url: `${process.env.NEXT_PUBLIC_APP_URL}/market-stand/setup`,
        return_url: `${process.env.NEXT_PUBLIC_APP_URL}/api/stripe/connect/success`,
        type: "account_onboarding",
      });

      return NextResponse.json({ url: accountLink.url });
    } catch (error) {
      console.error("[STRIPE_CONNECT_ERROR] Failed to create account link:", error);
      return new NextResponse("Failed to create onboarding link", { status: 500 });
    }
  } catch (error) {
    console.error("[STRIPE_CONNECT_ERROR] Unexpected error:", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/route.ts">
import ProductEmail from "@/components/ProductEmail";
import { stripe } from "@/lib/stripe";

import { headers } from "next/headers";
import { Resend } from "resend";

const resend = new Resend(process.env.RESEND_API_KEY);

export async function POST(req: Request) {
  const body = await req.text();

  const signature = headers().get("Stripe-Signature") as string;

  let event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_SECRET_WEBHOOK as string
    );
  } catch (error: unknown) {
    return new Response("webhook error", { status: 400 });
  }

  switch (event.type) {
    case "checkout.session.completed": {
      const session = event.data.object;

      const link = session.metadata?.link;

      const { data, error } = await resend.emails.send({
        from: "MarshalUI <onboarding@resend.dev>",
        to: ["your_email"],
        subject: "Your Product from MarshalUI",
        react: ProductEmail({
          link: link as string,
        }),
      });

      break;
    }
    default: {
      console.log("unhandled event");
    }
  }

  return new Response(null, { status: 200 });
}
</file>

<file path="app/api/upload/route.ts">
import { createServerSupabaseClient } from "@/lib/auth";
import { getUser } from "@/lib/auth";
import { NextResponse } from "next/server";

export const config = {
  api: {
    bodyParser: false,
  },
};

export async function POST(req: Request) {
  try {
    const user = await getUser();
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;
    if (!file) {
      return new NextResponse("No file provided", { status: 400 });
    }

    const supabase = createServerSupabaseClient();

    // Create a buffer from the file
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload to user's folder with proper permissions
    const fileName = `${user.id}/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
    let uploadResult = await supabase.storage
      .from('products')
      .upload(fileName, buffer, {
        contentType: file.type,
        duplex: 'half',
        upsert: false
      });

    if (uploadResult.error) {
      console.error('Upload error:', uploadResult.error);
      if (uploadResult.error.message.includes('row-level security')) {
        // Set up bucket policy if it doesn't exist
        await supabase.storage.from('products').upload(`${user.id}/.keep`, new Uint8Array(0), {
          upsert: true
        });
        
        // Try upload again
        uploadResult = await supabase.storage
          .from('products')
          .upload(fileName, buffer, {
            contentType: file.type,
            duplex: 'half',
            upsert: false
          });
          
        if (uploadResult.error) {
          return new NextResponse(uploadResult.error.message, { status: 500 });
        }
      } else {
        return new NextResponse(uploadResult.error.message, { status: 500 });
      }
    }

    if (!uploadResult.data) {
      return new NextResponse("Failed to upload file", { status: 500 });
    }

    // Get the public URL
    const { data: urlData } = supabase.storage
      .from('products')
      .getPublicUrl(uploadResult.data.path);

    if (!urlData?.publicUrl) {
      return new NextResponse("Failed to get public URL", { status: 500 });
    }

    return NextResponse.json({ url: urlData.publicUrl });
  } catch (error) {
    console.error('Upload error:', error);
    return new NextResponse(
      error instanceof Error ? error.message : "Internal server error", 
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/user/route.ts">
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    
    const { data: { user }, error } = await supabase.auth.getUser();
    
    if (error || !user) {
      return new NextResponse(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
      });
    }

    // Get user's market stand ID from your database
    const { data: profile } = await supabase
      .from('profiles')
      .select('market_stand_id')
      .eq('id', user.id)
      .single();

    return NextResponse.json({
      id: user.id,
      email: user.email,
      marketStandId: profile?.market_stand_id
    });
  } catch (error) {
    console.error('API Error:', error);
    return new NextResponse(JSON.stringify({ error: 'Internal Server Error' }), {
      status: 500,
    });
  }
}
</file>

<file path="app/auth-error/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";

const errorMessages = {
  no_code: "Authentication code was not provided",
  session_error: "There was an error with your session",
  verification_error: "Could not verify your authentication status",
  no_session: "Unable to create a session",
  unexpected: "An unexpected error occurred",
};

export default function AuthError() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [countdown, setCountdown] = useState(3);

  const error = searchParams.get("error") || "unexpected";
  const message = searchParams.get("message");

  useEffect(() => {
    // Auto-redirect after 5 seconds
    if (countdown > 0) {
      const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
      return () => clearTimeout(timer);
    } else {
      router.push("/");
    }
  }, [countdown, router]);

  return (
    <div className="flex min-h-[60vh] flex-col items-center justify-center text-center">
      <div className="max-w-md space-y-6 px-4">
        <h1 className="text-2xl font-bold">Authentication Error</h1>
        
        <p className="text-muted-foreground">
          {errorMessages[error as keyof typeof errorMessages]}
          {message && (
            <span className="block mt-2 text-sm text-destructive">
              Details: {decodeURIComponent(message)}
            </span>
          )}
        </p>

        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">
            Redirecting to home in {countdown} seconds...
          </p>
          
          <div className="flex justify-center gap-4">
            <Button
              variant="outline"
              onClick={() => router.push("/")}
            >
              Return Home
            </Button>
            <Button
              onClick={() => {
                router.push("/?retry=true");
              }}
            >
              Try Again
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/billing/page.tsx">
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import prisma from "@/lib/db";
import { getUser } from "@/lib/auth";
import { AlertCircle } from "lucide-react";
import { unstable_noStore as noStore } from "next/cache";

async function getData(userId: string) {
  const data = await prisma.user.findUnique({
    where: {
      id: userId,
    },
    select: {
      stripeConnectedLinked: true,
    },
  });

  return data;
}

export default async function BillingRoute() {
  noStore();
  const user = await getUser();

  if (!user) {
    throw new Error("Authentication required");
  }

  const data = await getData(user.id);
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader>
          <CardTitle>Billing</CardTitle>
          <CardDescription>
            Find all your details regarding your payments
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg flex items-start gap-3">
            <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
            <div>
              <p className="font-medium">Payment Integration Temporarily Disabled</p>
              <p className="text-sm mt-1">
                Stripe integration is currently disabled for testing purposes. Payment functionality will be available soon.
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </section>
  );
}
</file>

<file path="app/dashboard/market-stand/page.tsx">
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";
import { MarketStandCard } from "@/components/MarketStandCard";
import { redirect } from "next/navigation";

async function getMarketStands(userId: string) {
  try {
    return await prisma.marketStand.findMany({
      where: {
        userId: userId,
      },
      select: {
        id: true,
        name: true,
        description: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        images: true,
        _count: {
          select: {
            products: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  } catch (error) {
    console.error('Error fetching market stands:', error);
    return [];
  }
}

export default async function MarketStandDashboard() {
  const user = await getUser();
  
  // If no user, redirect to home page
  if (!user) {
    redirect('/');
  }

  // Only fetch market stands if we have a user
  const marketStands = await getMarketStands(user.id);

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold">My Market Stands</h1>
          <p className="text-muted-foreground">
            Manage your market stands and their products
          </p>
        </div>
        <Link href="/market-stand/setup">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            New Market Stand
          </Button>
        </Link>
      </div>

      {marketStands.length === 0 ? (
        <div className="text-center py-12">
          <h3 className="text-lg font-medium mb-2">No market stands yet</h3>
          <p className="text-muted-foreground mb-4">
            Create your first market stand to start selling products
          </p>
          <Link href="/market-stand/setup">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Create Market Stand
            </Button>
          </Link>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {marketStands.map((stand) => (
            <MarketStandCard 
              key={stand.id}
              stand={stand}
              userId={user.id}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/dashboard/sell/page.tsx">
"use client";

import { getProducts } from "@/app/actions/products";
import { redirect, useRouter } from "next/navigation";
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { useState, useEffect } from "react";

// Server response type with string dates
type ProductResponse = {
  id: string;
  name: string;
  description: string;
  price: number;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: string | null;
  status: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  userId: string;
  totalReviews: number;
  locationName?: string;
  marketStand?: {
    id: string;
    name: string;
  };
  tags?: string[];
  marketStandId?: string;
  averageRating?: number;
};

// Client-side type with Date objects
type Product = Omit<ProductResponse, 'createdAt' | 'updatedAt' | 'inventoryUpdatedAt'> & {
  createdAt: Date;
  updatedAt: Date;
  inventoryUpdatedAt: Date | null;
};

type User = {
  id: string;
  marketStandId: string;
};

interface DashboardProductRowProps {
  product: {
    id: string;
    name: string;
    description: string;
    price: number;
    images: string[];
    inventory: number;
    inventoryUpdatedAt: Date | null;
    status: string;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    userId: string;
    totalReviews: number;
    marketStand?: {
      id: string;
      name: string;
    };
    locationName?: string;
  };
}

function DashboardProductRow({ product }: DashboardProductRowProps) {
  return (
    <div className="flex items-center justify-between p-4 border rounded-md">
      <div>
        <Link href={`/product/${product.id}`}>
          <h3 className="text-lg font-medium">{product.name}</h3>
        </Link>
        <p className="text-sm text-gray-500">{product.description}</p>
        <p className="mt-1">
          <span className="text-sm font-medium">${(product.price / 100).toFixed(2)}</span>
          {' | '}
          <span className="text-sm text-gray-500">{product.locationName}</span>
        </p>
      </div>
      <div>
        <Link href={`/product/${product.id}/edit`} className="text-sm font-medium text-primary hover:text-primary-focus">
          Edit <span>&rarr;</span>
        </Link>
      </div>
    </div>
  );
}

export default function SellPage() {
  const [user, setUser] = useState<User | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const router = useRouter();
  const supabase = createClientComponentClient();

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        // Check auth status
        const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
        
        if (authError || !authUser) {
          router.push('/');
          return;
        }

        // Get user profile
        const res = await fetch("/api/user");
        const userData = await res.json();
  
        if (!res.ok) {
          throw new Error(userData.error || 'Failed to fetch user data');
        }
  
        setUser(userData);
  
        // Fetch products and convert dates
        const productsData = await getProducts(userData.id);
        const productsWithDates = productsData.map(product => ({
          ...product,
          createdAt: new Date(product.createdAt),
          updatedAt: new Date(product.updatedAt),
          inventoryUpdatedAt: product.inventoryUpdatedAt ? new Date(product.inventoryUpdatedAt) : null
        }));
        setProducts(productsWithDates);
      } catch (error) {
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unexpected error occurred');
        }
      } finally {
        setLoading(false);
      }
    };
  
    fetchData();
  }, [router, supabase]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-muted-foreground">Loading products...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <p className="text-destructive">{error}</p>
          <Button onClick={() => window.location.reload()}>
            Try Again
          </Button>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-medium">Products</h3>
        <p className="text-sm text-muted-foreground">
          Manage and sell your products.
        </p>
      </div>
      <div className="flex justify-end mb-4">
        <Button asChild>
          <Link href="/sell" className="flex items-center">
            <Plus className="h-4 w-4 mr-2" />
            Add Product
          </Link>
        </Button>
      </div>
      <div className="grid gap-4">
        {products?.map((product) => (
          <DashboardProductRow key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/settings/page.tsx">
import { getUser } from "@/lib/auth";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { CreditCard, Store, User } from "lucide-react";

export default async function SettingsDashboard() {
  const user = await getUser();

  const settingsCards = [
    {
      title: "Profile Settings",
      description: "Update your personal information and preferences",
      icon: User,
      href: "/settings",
    },
    {
      title: "Payment Settings",
      description: "Manage your payment methods and billing information",
      icon: CreditCard,
      href: "/billing",
    },
    {
      title: "Market Stand Settings",
      description: "Configure your market stand preferences",
      icon: Store,
      href: "/market-stand/setup",
    },
  ];

  return (
    <div>
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Settings</h1>
        <p className="text-muted-foreground">
          Manage your account settings and preferences
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {settingsCards.map((card) => {
          const Icon = card.icon;
          return (
            <Link key={card.href} href={card.href}>
              <Card className="h-full hover:bg-muted/50 transition-colors">
                <CardHeader>
                  <Icon className="h-8 w-8 mb-2 text-primary" />
                  <CardTitle>{card.title}</CardTitle>
                  <CardDescription>{card.description}</CardDescription>
                </CardHeader>
                <CardContent>
                  <Button variant="ghost" className="w-full">
                    View Settings
                  </Button>
                </CardContent>
              </Card>
            </Link>
          );
        })}
      </div>

      <div className="mt-8">
        <Card>
          <CardHeader>
            <CardTitle>Account Information</CardTitle>
            <CardDescription>Your current account details</CardDescription>
          </CardHeader>
          <CardContent className="space-y-2">
            <div>
              <div className="text-sm font-medium">Email</div>
              <div className="text-sm text-muted-foreground">{user?.email}</div>
            </div>
            <div>
              <div className="text-sm font-medium">Name</div>
              <div className="text-sm text-muted-foreground">
                {user?.user_metadata?.given_name} {user?.user_metadata?.family_name}
              </div>
            </div>
            <div>
              <div className="text-sm font-medium">Account Created</div>
              <div className="text-sm text-muted-foreground">
                {new Date(user?.created_at!).toLocaleDateString()}
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/layout.tsx">
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Store, Settings, Package } from "lucide-react";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  if (!user) {
    return redirect('/');
  }

  const navItems = [
    {
      href: "/dashboard/market-stand",
      label: "Market Stand",
      icon: Store,
    },
    {
      href: "/dashboard/sell",
      label: "Products",
      icon: Package,
    },
    {
      href: "/dashboard/settings",
      label: "Settings",
      icon: Settings,
    },
  ];

  return (
    <div className="flex min-h-screen">
      {/* Sidebar */}
      <div className="w-64 bg-background border-r">
        <div className="p-6">
          <h2 className="text-lg font-semibold mb-6">Dashboard</h2>
          <nav className="space-y-2">
            {navItems.map((item) => {
              const Icon = item.icon;
              return (
                <Link 
                  key={item.href} 
                  href={item.href}
                  className="block"
                >
                  <Button
                    variant="ghost"
                    className="w-full justify-start gap-2"
                  >
                    <Icon className="h-4 w-4" />
                    {item.label}
                  </Button>
                </Link>
              );
            })}
          </nav>
        </div>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-auto">
        <div className="container py-6">
          {children}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/page.tsx">
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";

export default async function DashboardPage() {
  const user = await getUser();

  if (!user) {
    return redirect('/');
  }

  return redirect("/dashboard/market-stand");
}
</file>

<file path="app/market-stand/[id]/edit/page.tsx">
import { redirect } from "next/navigation";
import { unstable_noStore as noStore } from "next/cache";
import prisma from "../../../../lib/db";
import { getUser } from "@/lib/auth";
import { Card } from "../../../../components/ui/card";
import { MarketStandForm } from "../../../../components/form/MarketStandForm";

async function getData(encodedId: string) {
  try {
    // Handle ID decoding once at the start
    const id = decodeURIComponent(encodedId);
    console.log('getData debug:', {
      encodedId,
      decodedId: id,
      isEncoded: encodedId !== id
    });

    // Verify database connection
    try {
      await prisma.$queryRaw`SELECT 1`;
      console.log('Database connection verified');
    } catch (dbError) {
      console.error('Database connection error:', dbError);
      throw new Error('Database connection failed');
    }

    // First try raw query to debug any ID issues
    try {
      const rawCheck = await prisma.$queryRaw`
        SELECT id, "userId" 
        FROM "MarketStand" 
        WHERE id = ${id}
      `;
      console.log('Raw market stand check:', rawCheck);
    } catch (rawError) {
      console.error('Raw query error:', rawError);
    }

    // Fetch market stand with Prisma
    const marketStand = await prisma.marketStand.findUnique({
      where: { id },
    select: {
      id: true,
      name: true,
      description: true,
      images: true,
      locationName: true,
      locationGuide: true,
      latitude: true,
      longitude: true,
      userId: true,
      tags: true
    }
    });

    console.log('Prisma query result:', {
      found: !!marketStand,
      marketStandId: marketStand?.id,
      userId: marketStand?.userId,
      query: {
        where: { id },
        select: ['id', 'name', 'description', 'images', 'locationName', 'locationGuide', 'latitude', 'longitude', 'userId']
      }
    });

    return marketStand;
  } catch (error) {
    console.error('getData error:', {
      error,
      message: error instanceof Error ? error.message : 'Unknown error',
      encodedId,
      stack: error instanceof Error ? error.stack : undefined
    });
    return null;
  }
}

export default async function EditMarketStandPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  
  // Debug params
  console.log('EditMarketStandPage params:', {
    rawParams: params,
    id: params.id,
  });

  // Authentication check
  const user = await getUser();

  console.log('Authentication check:', {
    hasUser: !!user,
    userId: user?.id,
    userEmail: user?.email
  });

  if (!user) {
    console.log('No authenticated user, redirecting to home');
    return redirect("/");
  }

  // Fetch market stand data
  console.log('Fetching market stand data...');
  const marketStand = await getData(params.id);

  // Debug ownership check
  console.log('Ownership verification:', {
    marketStandFound: !!marketStand,
    marketStandId: marketStand?.id,
    marketStandUserId: marketStand?.userId,
    currentUserId: user.id,
    isOwner: marketStand?.userId === user.id
  });

  if (!marketStand) {
    console.log('Market stand not found');
    return (
      <div className="max-w-3xl mx-auto px-4 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
        <pre className="mt-4 p-4 bg-gray-100 rounded text-sm overflow-auto">
          Debug Info:
          {JSON.stringify({
            params,
            userId: user.id,
            timestamp: new Date().toISOString()
          }, null, 2)}
        </pre>
      </div>
    );
  }

  // Verify ownership
  if (marketStand.userId !== user.id) {
    console.log('User is not owner, redirecting to view page');
    return redirect(`/market-stand/${params.id}`); // Use original ID for consistency
  }

  console.log('Access verified, preparing form data');

  // Format market stand data for the form
  const formattedMarketStand = {
    ...marketStand,
    description: marketStand.description
  };

  console.log('Rendering edit form with data:', {
    id: formattedMarketStand.id,
    name: formattedMarketStand.name,
    hasDescription: !!formattedMarketStand.description,
    imageCount: formattedMarketStand.images.length,
    timestamp: new Date().toISOString()
  });

  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Edit Market Stand</h1>
        <p className="text-muted-foreground">Update your market stand details</p>
      </div>
      <Card>
        <MarketStandForm 
          userId={user.id} 
          marketStand={formattedMarketStand} 
        />
      </Card>
    </div>
  );
}
</file>

<file path="app/market-stand/[id]/page.tsx">
import prisma from "@/lib/db";
import { unstable_noStore as noStore } from "next/cache";
import Image from "next/image";
import { MapPin, Package, Clock, Navigation } from "lucide-react";
import { getUser } from "@/lib/auth";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { ProductCard } from "@/components/ProductCard";
import { Card, CardContent } from "@/components/ui/card";
import { Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious } from "@/components/ui/carousel";
import MapView from "@/components/MapView";
import { Separator } from "@/components/ui/separator";

async function getData(encodedId: string) {
  try {
    const id = decodeURIComponent(encodedId);
    await prisma.$queryRaw`SELECT 1`;

    const marketStand = await prisma.marketStand.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        images: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        userId: true,
        createdAt: true,
        tags: true,
        products: {
          select: {
            id: true,
            name: true,
            images: true,
            updatedAt: true,
            price: true,
            inventory: true,
            tags: true,
          }
        },
        user: {
          select: {
            id: true,
            firstName: true,
            profileImage: true,
          }
        }
      }
    });

    if (!marketStand) return null;

    // Serialize dates
    return {
      ...marketStand,
      createdAt: marketStand.createdAt.toISOString(),
      products: marketStand.products.map(product => ({
        ...product,
        updatedAt: product.updatedAt.toISOString()
      }))
    };
  } catch (error) {
    console.error('getData error:', error);
    return null;
  }
}

export default async function MarketStandPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  
  const user = await getUser();
  const marketStand = await getData(params.id);

  if (!marketStand) {
    return (
      <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
      {/* Header Section */}
      <div className="flex flex-col gap-4 mb-8">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div>
              <h1 className="text-3xl font-bold">{marketStand.name}</h1>
            </div>
          </div>
        </div>
        {marketStand.tags && marketStand.tags.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {marketStand.tags.map((tag, index) => (
              <div
                key={index}
                className="bg-secondary px-2 py-1 rounded-md text-xs"
              >
                {tag}
              </div>
            ))}
          </div>
        )}
      </div>

      <div className="grid lg:grid-cols-3 gap-8">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-8">
          {/* Image Carousel */}
          <div className="relative">
            <Carousel className="w-full">
              <CarouselContent>
                {marketStand.images.map((image, index) => (
                  <CarouselItem key={index}>
                    <div className="aspect-video relative rounded-lg overflow-hidden">
                      <Image
                        src={image}
                        alt={`${marketStand.name} ${index + 1}`}
                        fill
                        className="object-cover"
                        priority={index === 0}
                      />
                    </div>
                  </CarouselItem>
                ))}
              </CarouselContent>
              <CarouselPrevious className="left-4" />
              <CarouselNext className="right-4" />
            </Carousel>
          </div>

          {/* Description */}
          <Card>
            <CardContent className="p-6">
              <h2 className="text-xl font-semibold mb-4">About this Market Stand</h2>
              <p className="text-muted-foreground whitespace-pre-wrap">
                {marketStand.description}
              </p>
            </CardContent>
          </Card>

          {/* Products */}
          <div>
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold">Available Products</h2>
              <div className="flex items-center gap-2 text-muted-foreground">
                <Package className="h-4 w-4" />
                <span>{marketStand.products.length} products</span>
              </div>
            </div>
            <div className="grid sm:grid-cols-2 gap-4">
              {marketStand.products.map((product) => (
                <ProductCard
                  key={product.id}
                  id={product.id}
                  name={product.name}
                  images={product.images}
                  locationName={marketStand.locationName}
                  updatedAt={product.updatedAt}
                  inventory={product.inventory}
                  marketStandId={marketStand.id}
                  isQRAccess={false}
                  price={product.price}
                  tags={product.tags}
                />
              ))}
            </div>
          </div>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Location Card */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold mb-4">Location</h3>
              <div className="space-y-4">
                <div className="flex items-start gap-3">
                  <MapPin className="h-5 w-5 text-primary mt-0.5" />
                  <div>
                    <p className="font-medium">{marketStand.locationName}</p>
                    <p className="text-sm text-muted-foreground mt-1">
                      {marketStand.locationGuide}
                    </p>
                  </div>
                </div>
                <div className="aspect-video relative rounded-lg overflow-hidden">
                  <MapView 
                    latitude={marketStand.latitude} 
                    longitude={marketStand.longitude}
                    locationName={marketStand.locationName}
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Additional Info Card */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold mb-4">Additional Information</h3>
              <div className="space-y-4">
                <div className="flex items-center gap-3">
                  <Clock className="h-5 w-5 text-primary" />
                  <div>
                    <p className="text-sm text-muted-foreground">Member since</p>
                    <p className="font-medium">
                      {new Date(marketStand.createdAt).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <Separator />
                <div className="flex items-center gap-3">
                  <Navigation className="h-5 w-5 text-primary" />
                  <div>
                    <p className="text-sm text-muted-foreground">Coordinates</p>
                    <p className="font-medium">
                      {marketStand.latitude.toFixed(6)}, {marketStand.longitude.toFixed(6)}
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/market-stand/grid/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { MarketStandViewNav } from "@components/MarketStandViewNav";
import { Button } from "@components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@components/ui/select";
import { MarketStandCard } from "@components/MarketStandCard";
import Link from "next/link";

interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  images: string[];
  createdAt: Date;
  updatedAt: Date;
}

interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  createdAt: Date;
  tags: string[];
  products: Product[];
  user: {
    firstName: string;
    profileImage: string;
  };
}

async function getData() {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

    const res = await fetch('/api/market-stand', { 
      cache: 'no-store',
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!res.ok) {
      const errorData = await res.json().catch(() => ({}));
      console.error('Market stand fetch failed:', {
        status: res.status,
        statusText: res.statusText,
        errorData
      });
      throw new Error(errorData.error || 'Failed to fetch market stands');
    }

    const data = await res.json();
    
    if (!Array.isArray(data)) {
      console.error('Invalid market stand data:', data);
      throw new Error('Invalid response format');
    }

    return data;
  } catch (error) {
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error('Request timed out. Please try again.');
    }
    throw error;
  }
}

export default function MarketStandsGridPage() {
  const [marketStands, setMarketStands] = useState<MarketStand[]>([]);
  const [sortOrder, setSortOrder] = useState<'newest' | 'distance'>('newest');
  const [userLocation, setUserLocation] = useState<{latitude: number; longitude: number} | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Get user's location
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude
          });
        },
        (error) => {
          console.error('Error getting location:', error);
        }
      );
    }
  }, []);

  useEffect(() => {
    let mounted = true;

    const fetchData = async () => {
      try {
        const data = await getData();
        if (mounted) {
          console.log('Successfully fetched market stands:', {
            count: data.length,
            hasImages: data.some(stand => stand.images?.length > 0)
          });
          setMarketStands(data);
        }
      } catch (error) {
        console.error('Error in fetchData:', error);
        if (mounted) {
          setError(error instanceof Error ? error.message : 'An unexpected error occurred');
        }
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      mounted = false;
    };
  }, []);

  if (error) {
    return (
      <section className="max-w-7xl mx-auto px-4 md:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold">Market Stands</h1>
          <p className="text-red-500 mt-2">{error}</p>
        </div>
      </section>
    );
  }

  const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number) => {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
      Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // Distance in km
  };

  const sortedStands = [...marketStands].sort((a, b) => {
    switch (sortOrder) {
      case 'newest':
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      case 'distance':
        if (!userLocation) return 0;
        const distA = calculateDistance(userLocation.latitude, userLocation.longitude, a.latitude, a.longitude);
        const distB = calculateDistance(userLocation.latitude, userLocation.longitude, b.latitude, b.longitude);
        return distA - distB;
      default:
        return 0;
    }
  });

  if (isLoading) {
    return (
      <section className="max-w-7xl mx-auto px-4 md:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold">Market Stands</h1>
          <p className="text-muted-foreground mt-2">Loading market stands...</p>
        </div>
        <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-6">
          {[...Array(6)].map((_, i) => (
            <div key={i} className="animate-pulse">
              <div className="bg-gray-200 h-48 rounded-lg mb-4"></div>
              <div className="space-y-3">
                <div className="h-4 bg-gray-200 rounded w-3/4"></div>
                <div className="h-4 bg-gray-200 rounded w-1/2"></div>
              </div>
            </div>
          ))}
        </div>
      </section>
    );
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Market Stands</h1>
        <p className="text-muted-foreground mt-2">
          Discover local market stands near you
        </p>
      </div>

      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
          <MarketStandViewNav currentView="grid" />
          <Select
            value={sortOrder}
            onValueChange={(value: 'newest' | 'distance') => setSortOrder(value)}
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Sort by..." />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="newest">Newest</SelectItem>
              <SelectItem value="distance">Nearest</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-6">
          {sortedStands.map((stand) => (
            <MarketStandCard
              key={stand.id}
              stand={{
                id: stand.id,
                name: stand.name,
                description: stand.description,
                locationName: stand.locationName,
                locationGuide: stand.locationGuide,
                latitude: stand.latitude,
                longitude: stand.longitude,
                images: stand.images,
                tags: stand.tags,
                _count: {
                  products: stand.products.length
                }
              }}
            />
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="app/market-stand/map/loading.tsx">
import { Skeleton } from "../../../components/ui/skeleton";
import { Button } from "../../../components/ui/button";
import { MapIcon, List } from "lucide-react";
import Link from "next/link";

export default function MarketStandsMapLoading() {
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold">Market Stands</h1>
          <p className="text-muted-foreground mt-2">
            Discover local market stands near you
          </p>
        </div>

        <div className="flex items-center gap-4">
          <Link href="/market-stand">
            <Button variant="outline" size="sm">
              <List className="h-4 w-4 mr-2" />
              List View
            </Button>
          </Link>
          <Button variant="default" size="sm" disabled>
            <MapIcon className="h-4 w-4 mr-2" />
            Map View
          </Button>
        </div>
      </div>

      <Skeleton className="w-full h-[600px] rounded-lg" />
    </section>
  );
}
</file>

<file path="app/market-stand/map/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import MarketStandsMap from "@components/MarketStandsMap";
import { MarketStandViewNav } from "@components/MarketStandViewNav";

interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  createdAt: string;
  tags: string[];
  products: Array<{
    id: string;
    name: string;
    description: string;
    price: number;
    images: string[];
    createdAt: string;
    updatedAt: string;
  }>;
  user: {
    firstName: string;
    profileImage: string;
  };
}

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

async function getData() {
  const res = await fetch('/api/market-stand', { cache: 'no-store' });
  if (!res.ok) {
    throw new Error('Failed to fetch market stands');
  }
  return res.json();
}

export default function MarketStandsMapPage() {
  const [marketStands, setMarketStands] = useState<MarketStand[]>([]);
  const [userLocation, setUserLocation] = useState<{lat: number; lng: number} | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    getData()
      .then(data => {
        setMarketStands(data);
        setIsLoading(false);
      })
      .catch(error => {
        console.error('Error fetching market stands:', error);
        setIsLoading(false);
      });
  }, []);

  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        },
        (error) => {
          console.error('Error getting location:', error);
        }
      );
    }
  }, []);

  const standsWithDistance = marketStands.map(stand => {
    // Ensure dates are serialized as strings
    const serializedStand = {
      ...stand,
      createdAt: new Date(stand.createdAt).toISOString(),
      products: stand.products.map(product => ({
        ...product,
        createdAt: new Date(product.createdAt).toISOString(),
        updatedAt: new Date(product.updatedAt).toISOString(),
      }))
    };

    return {
      ...serializedStand,
      distance: userLocation
        ? calculateDistance(
            userLocation.lat,
            userLocation.lng,
            stand.latitude,
            stand.longitude
          )
        : undefined
    };
  });

  if (isLoading) {
    return (
      <section className="max-w-7xl mx-auto px-4 md:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold">Market Stands Map</h1>
          <p className="text-muted-foreground mt-2">Loading...</p>
        </div>
      </section>
    );
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Market Stands Map</h1>
        <p className="text-muted-foreground mt-2">
          Discover local market stands near you
        </p>
      </div>

      <div className="mb-6">
        <MarketStandViewNav currentView="map" />
      </div>

      <MarketStandsMap 
        marketStands={standsWithDistance}
        userLocation={userLocation}
      />
    </section>
  );
}
</file>

<file path="app/market-stand/setup/loading.tsx">
import { Card } from "../../../components/ui/card";
import { Skeleton } from "../../../components/ui/skeleton";

export default function MarketStandSetupLoading() {
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8 mb-14">
      <Card>
        <Skeleton className="h-[800px]" />
      </Card>
    </section>
  );
}
</file>

<file path="app/market-stand/setup/page.tsx">
import { Card } from "../../../components/ui/card";
import { unstable_noStore as noStore } from "next/cache";
import { MarketStandForm } from "../../../components/form/MarketStandForm";
import { AuthDialog } from "@/components/AuthDialog";
import { getUser } from "@/lib/auth";

export default async function MarketStandSetupPage() {
  noStore();
  const user = await getUser(); // User data is already serialized from getUser

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8 mb-14">
      <Card>
        {user ? (
          <MarketStandForm userId={user.id.toString()} />
        ) : (
          <div className="p-6">
            <h2 className="text-2xl font-semibold mb-4">Create Your Market Stand</h2>
            <p className="mb-6">Please sign in to create your market stand.</p>
            <AuthDialog />
          </div>
        )}
      </Card>
    </section>
  );
}
</file>

<file path="app/market-stand/page.tsx">
import { redirect } from "next/navigation";

export default function MarketStandsPage() {
  redirect("/market-stand/grid");
}
</file>

<file path="app/navigate/[id]/page.tsx">
import prisma from "../../../lib/db";
import { unstable_noStore as noStore } from "next/cache";
import { MapPin } from "lucide-react";
import dynamic from "next/dynamic";

// Dynamic import for MapView to handle SSR
const MapView = dynamic(
  () => import('../../../components/MapView'),
  {
    ssr: false,
    loading: () => <div className="h-[400px] animate-pulse bg-gray-200 rounded-lg" />
  }
);

async function getData(id: string) {
  const marketStand = await prisma.marketStand.findUnique({
    where: {
      id: id,
    },
    select: {
      id: true,
      name: true,
      description: true,
      locationName: true,
      locationGuide: true,
      latitude: true,
      longitude: true,
      createdAt: true,
      products: {
        select: {
          id: true,
          name: true,
          price: true,
          inventory: true,
        },
        where: {
          inventory: {
            gt: 0
          }
        },
        take: 3
      },
      user: {
        select: {
          firstName: true,
          lastName: true,
          profileImage: true,
        }
      }
    }
  });

  return marketStand;
}

export default async function NavigatePage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  const marketStand = await getData(decodeURIComponent(params.id));

  if (!marketStand) {
    return (
      <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
      <div className="grid lg:grid-cols-2 gap-8">
        {/* Left Column - Market Stand Details */}
        <div className="space-y-6">
          {/* Header Section */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <div className="flex items-center gap-4 mb-6">
              <img
                src={marketStand.user.profileImage}
                alt={marketStand.user.firstName}
                className="w-16 h-16 rounded-full border-2 border-primary"
              />
              <div>
                <h2 className="text-2xl font-bold">{marketStand.name}</h2>
                <p className="text-muted-foreground">
                  Managed by {marketStand.user.firstName} {marketStand.user.lastName}
                </p>
              </div>
            </div>

            {/* Description */}
            {marketStand.description && (
              <div className="mb-6">
                <p className="text-muted-foreground">
                  {marketStand.description}
                </p>
              </div>
            )}

            {/* Location Details */}
            <div className="border-t pt-6">
              <div className="flex items-start gap-3 mb-4">
                <MapPin className="h-5 w-5 text-primary mt-1" />
                <div>
                  <h3 className="font-semibold text-lg mb-1">{marketStand.locationName}</h3>
                  <p className="text-muted-foreground whitespace-pre-line">
                    {marketStand.locationGuide}
                  </p>
                </div>
              </div>
            </div>
          </div>

          {/* Available Products */}
          {marketStand.products.length > 0 && (
            <div className="bg-white rounded-lg shadow-md p-6">
              <h3 className="font-semibold text-lg mb-4">Available Products</h3>
              <div className="space-y-4">
                {marketStand.products.map((product) => (
                  <div key={product.id} className="flex justify-between items-center">
                    <div>
                      <p className="font-medium">{product.name}</p>
                      <p className="text-sm text-muted-foreground">
                        {product.inventory} available
                      </p>
                    </div>
                    <p className="font-medium">
                      ${(product.price / 100).toFixed(2)}
                    </p>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Coordinates Card */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <h3 className="font-semibold text-lg mb-4">GPS Coordinates</h3>
            <div className="grid grid-cols-2 gap-4 mb-6">
              <div>
                <p className="text-sm text-muted-foreground mb-1">Latitude</p>
                <p className="font-mono">{marketStand.latitude.toFixed(6)}</p>
              </div>
              <div>
                <p className="text-sm text-muted-foreground mb-1">Longitude</p>
                <p className="font-mono">{marketStand.longitude.toFixed(6)}</p>
              </div>
            </div>

            {/* Navigation Links */}
            <div className="grid grid-cols-2 gap-4">
              <a
                href={`https://www.google.com/maps/dir/?api=1&destination=${marketStand.latitude},${marketStand.longitude}`}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-3 rounded-md hover:bg-primary/90 transition-colors"
              >
                <MapPin className="h-4 w-4" />
                Google Maps
              </a>
              <a
                href={`https://maps.apple.com/?daddr=${marketStand.latitude},${marketStand.longitude}`}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-3 rounded-md hover:bg-primary/90 transition-colors"
              >
                <MapPin className="h-4 w-4" />
                Apple Maps
              </a>
            </div>
          </div>
        </div>

        {/* Right Column - Map */}
        <div className="lg:h-[calc(100vh-12rem)] h-[400px] bg-white rounded-lg shadow-md overflow-hidden">
          <MapView 
            latitude={marketStand.latitude}
            longitude={marketStand.longitude}
            locationName={marketStand.locationName}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/payment/cancel/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { XCircle } from "lucide-react";
import Link from "next/link";

export default function CacncelRoute() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <XCircle className="w-12 h-12 rounded-full bg-red-500/30 text-red-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">Payment Canceled</h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Something went wrong with your payment. You havent been charged.
              Please try again.
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/payment/success/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Check } from "lucide-react";
import Link from "next/link";

export default function SuccessRoute() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <Check className="w-12 h-12 rounded-full bg-green-500/30 text-green-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">
              Payment Successful
            </h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Congrats to your purchase! Please check your email for futher
              instructions.
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/product/[id]/edit/loading.tsx">
import { Card } from "@components/ui/card";
import { Skeleton } from "@components/ui/skeleton";

export default function EditProductLoading() {
  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <Card>
        <div className="p-6 space-y-8">
          <div className="space-y-4">
            <Skeleton className="h-8 w-48" />
            <Skeleton className="h-4 w-full max-w-md" />
          </div>

          <div className="space-y-4">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-10 w-full" />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Skeleton className="h-4 w-16" />
              <Skeleton className="h-10 w-full" />
            </div>
            <div className="space-y-2">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-10 w-full" />
            </div>
          </div>

          <div className="space-y-2">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-32 w-full" />
          </div>

          <div className="space-y-4">
            <Skeleton className="h-4 w-32" />
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              <Skeleton className="aspect-square rounded-lg" />
              <Skeleton className="aspect-square rounded-lg" />
              <Skeleton className="aspect-square rounded-lg" />
            </div>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="app/product/[id]/edit/page.tsx">
import { redirect } from "next/navigation";
import { unstable_noStore as noStore } from "next/cache";
import prisma from "@/lib/db";
import { Card } from "@/components/ui/card";
import { SellForm } from "@/components/form/Sellform";
import { getUser } from "@/lib/auth";

async function getProduct(id: string, userId: string) {
  const product = await prisma.product.findUnique({
    where: {
      id: id,
      userId: userId // Ensure user owns the product
    },
    select: {
      id: true,
      name: true,
      description: true,
      price: true,
      images: true,
      marketStandId: true,
      inventory: true,
      inventoryUpdatedAt: true,
      marketStand: {
        select: {
          id: true,
          name: true,
          description: true,
          images: true,
          latitude: true,
          longitude: true,
          createdAt: true,
          userId: true
        }
      }
    }
  });
  return product;
}

export default async function EditProductPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  const user = await getUser();

  if (!user) {
    throw new Error("Authentication required");
  }

  const product = await getProduct(params.id, user.id);

  if (!product) {
    return redirect("/dashboard");
  }

  // Format product data for the form
  const initialData = {
    name: product.name,
    price: product.price / 100, // Convert back to dollars from cents
    description: product.description,
    images: product.images,
    marketStandId: product.marketStandId,
    inventory: product.inventory,
    inventoryUpdatedAt: product.inventoryUpdatedAt
  };

  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <Card>
        <SellForm 
          marketStand={product.marketStand}
          initialData={initialData}
          productId={product.id}
        />
      </Card>
    </div>
  );
}
</file>

<file path="app/product/[id]/loading.tsx">
import { Skeleton } from "@components/ui/skeleton";

export default function Loadingfile() {
  return (
    <section className="max-w-7xl mx-auto px-4 sm:px-8 mt-10">
      <div className="w-full grid grid-cols-1 md:grid-cols-2 gap-x-10">
        <div className="col-span-1">
          <Skeleton className="h-[250px] lg:h-[400px] w-full" />
          <Skeleton className="h-[500px] w-full mt-10" />
        </div>

        <div className="col-span-1">
          <Skeleton className="w-full h-[400px]" />
        </div>
      </div>
    </section>
  );
}
</file>

<file path="app/product/[id]/page.tsx">
import { SellProduct } from "@/app/actions";
import { ProductDescription } from "@/components/ProductDescription";
import { BuyButton } from "@/components/SubmitButtons";
import prisma from "@/lib/db";
import { Button } from "@/components/ui/button";
import { unstable_noStore as noStore } from "next/cache";
import { MapPin, Package, AlertCircle } from "lucide-react";
import Link from "next/link";
import { ProductCard } from "@/components/ProductCard";
import { InventoryManager } from "@/components/InventoryManager";

import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@/components/ui/carousel";
import { JSONContent } from "@tiptap/react";
import Image from "next/image";

async function getData(id: string, isQRAccess: boolean) {
  const data = await prisma.product.findUnique({
    where: {
      id: id,
    },
    select: {
      description: true,
      name: true,
      images: true,
      price: true,
      updatedAt: true,
      id: true,
      userId: true,
      inventory: true,
      inventoryUpdatedAt: true,
      tags: true,
      user: {
        select: {
          id: true,
          profileImage: true,
          firstName: true,
          connectedAccountId: true,
          stripeConnectedLinked: true,
        },
      },
      marketStand: {
        select: {
          id: true,
          name: true,
          latitude: true,
          longitude: true,
          locationName: true,
          createdAt: true,
          products: {
            where: {
              NOT: {
                id: id
              }
            },
            select: {
              id: true,
              name: true,
              images: true,
              updatedAt: true,
              price: true,
              tags: true,
            },
            take: isQRAccess ? 4 : 0
          }
        }
      }
    },
  });

  if (!data) return null;

  // Serialize dates
  return {
    ...data,
    updatedAt: data.updatedAt.toISOString(),
    inventoryUpdatedAt: data.inventoryUpdatedAt?.toISOString() ?? null,
    marketStand: data.marketStand ? {
      ...data.marketStand,
      createdAt: data.marketStand.createdAt.toISOString(),
      products: data.marketStand.products.map(product => ({
        ...product,
        updatedAt: product.updatedAt.toISOString()
      }))
    } : null
  };
}

export default async function ProductPage({
  params,
  searchParams,
}: {
  params: { id: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  noStore();
  const isQRAccess = searchParams.qr === 'true';
  const data = await getData(decodeURIComponent(params.id), isQRAccess);

  // Convert string description to JSONContent format
  const descriptionContent: JSONContent = {
    type: 'doc',
    content: [
      {
        type: 'paragraph',
        content: [
          {
            type: 'text',
            text: data?.description || ''
          }
        ]
      }
    ]
  };

  return (
    <section className="mx-auto px-4 lg:mt-10 max-w-7xl lg:px-8 lg:grid lg:grid-rows-1 lg:grid-cols-7 lg:gap-x-8 lg:gap-y-10 xl:gap-x-16">
      <Carousel className="lg:row-end-1 lg:col-span-4 relative group rounded-lg">
        <CarouselContent>
          {data?.images.map((item, index) => (
            <CarouselItem key={index}>
              <div className="relative aspect-[4/3] w-full rounded-lg bg-gray-100 overflow-hidden group-hover:shadow-lg transition-all">
                <Image
                  src={item as string}
                  alt={data?.name || "Product image"}
                  fill
                  className="object-cover rounded-lg transition-transform group-hover:scale-105"
                  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  priority={index === 0}
                />
              </div>
            </CarouselItem>
          ))}
        </CarouselContent>
        <CarouselPrevious className="absolute left-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white opacity-0 group-hover:opacity-100 transition-all shadow-md hover:scale-110 hover:shadow-lg" />
        <CarouselNext className="absolute right-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white opacity-0 group-hover:opacity-100 transition-all shadow-md hover:scale-110 hover:shadow-lg" />
      </Carousel>

      <div className="max-w-2xl mx-auto mt-5 lg:max-w-none lg:mt-0 lg:row-end-2 lg:row-span-2 lg:col-span-3">
        <h1 className="text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl">
          {data?.name}
        </h1>

        <div className="mt-2 mb-6 space-y-4">
          <p className="text-xl font-bold">
            ${((data?.price || 0) / 100).toFixed(2)}
          </p>
          {data?.tags && data.tags.length > 0 && (
            <div className="flex flex-wrap gap-2">
              {data.tags.map((tag, index) => (
                <div
                  key={index}
                  className="bg-secondary px-2 py-1 rounded-md text-xs"
                >
                  {tag}
                </div>
              ))}
            </div>
          )}
        </div>

        <div className="flex flex-col gap-4">
          {isQRAccess ? (
            <>
              {!data?.user?.stripeConnectedLinked && (
                <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg flex items-start gap-3">
                  <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="font-medium">Payment Not Available</p>
                    <p className="text-sm mt-1">
                      This seller hasn&apos;t set up their payment account yet. You can view the product details, but purchases are temporarily unavailable.
                    </p>
                  </div>
                </div>
              )}
              {data?.user?.stripeConnectedLinked && (
                <form action={async (formData: FormData) => {
                  await SellProduct({
                    status: undefined,
                    message: null
                  }, formData);
                }}>
                  <input type="hidden" name="id" value={data?.id} />
                  <BuyButton price={Number(data?.price)} />
                </form>
              )}
            </>
          ) : data?.marketStand ? (
            <>
              <div className="bg-muted p-4 rounded-lg text-sm">
                <h4 className="font-medium mb-2 flex items-center gap-2">
                  <Package className="h-4 w-4" />
                  Visit Market Stand to Purchase
                </h4>
                <p className="text-muted-foreground">
                  To buy this product, visit the market stand and scan the QR code. This helps ensure the product is still available.
                </p>
              </div>
              <Link 
                href={`/navigate/${encodeURIComponent(data.marketStand.id)}`}
                className="inline-flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-2 rounded-md hover:bg-primary/90 transition-colors text-center"
              >
                <MapPin className="h-4 w-4" />
                Get Directions to Market Stand
              </Link>
            </>
          ) : (
            <div className="bg-destructive/10 p-4 rounded-lg text-sm">
              <h4 className="font-medium mb-2 text-destructive">Product Unavailable</h4>
              <p className="text-muted-foreground">
                This product is not currently available at any market stand.
              </p>
            </div>
          )}
        </div>

        <div className="border-t border-gray-200 mt-10 pt-10">
          <div className="grid grid-cols-2 w-full gap-y-3">
            <h3 className="text-sm font-medium text-muted-foreground col-span-1">
              Member since:
            </h3>
            <h3 className="text-sm font-medium col-span-1">
              {data?.marketStand?.createdAt && new Intl.DateTimeFormat("en-US", {
                dateStyle: "long",
              }).format(new Date(data.marketStand.createdAt))}
            </h3>

            <h3 className="text-sm font-medium text-muted-foreground col-span-1">
              Available at:
            </h3>
            <div className="text-sm font-medium col-span-1 space-y-2">
              {!data?.marketStand ? (
                <p className="text-muted-foreground italic">No market stand available</p>
              ) : (
                <div key={data.marketStand.id} className="flex items-start gap-2">
                  <MapPin className="h-4 w-4 mt-0.5 flex-shrink-0" />
                  <div>
                    <p>{data.marketStand.name}</p>
                    <p className="text-xs text-muted-foreground">
                      {data.marketStand.latitude.toFixed(4)}, {data.marketStand.longitude.toFixed(4)}
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="border-t border-gray-200 mt-10">
          <InventoryManager
            productId={data?.id ?? ""}
            currentInventory={data?.inventory ?? 0}
            lastUpdated={data?.inventoryUpdatedAt ?? null}
            isOwner={data?.userId === data?.user?.id}
          />
        </div>
      </div>

      <div className="w-full max-w-2xl mx-auto mt-16 lg:max-w-none lg:mt-0 lg:col-span-4">
        <ProductDescription content={descriptionContent} />
      </div>

      {isQRAccess && data?.marketStand?.products && data.marketStand.products.length > 0 && (
        <div className="col-span-7 mt-16">
          <h3 className="text-xl font-semibold mb-6">More from this Market Stand</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            {data.marketStand.products.map((product) => (
              <ProductCard
                key={product.id}
                id={product.id}
                name={product.name}
                images={product.images}
                locationName={data.marketStand.locationName}
                updatedAt={product.updatedAt}
                marketStandId={data.marketStand.id}
                isQRAccess={true}
                price={product.price}
                tags={product.tags}
              />
            ))}
          </div>
        </div>
      )}
    </section>
  );
}
</file>

<file path="app/return/[id]/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Check } from "lucide-react";
import Link from "next/link";

export default function ReturnUrlStripe() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <Check className="w-12 h-12 rounded-full bg-green-500/30 text-green-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">
              Linking was Successful
            </h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Congrats on linking your account to marshal UI. You can now start
              selling your products!
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/sell/loading.tsx">
import { Card, CardHeader } from "@components/ui/card";
import { Skeleton } from "@components/ui/skeleton";

export default function SellRouteLoading() {
  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader className="h-[1000px]">
          <Skeleton className="w-full h-full" />
        </CardHeader>
      </Card>
    </div>
  );
}
</file>

<file path="app/sell/page.tsx">
import { Card } from "../../components/ui/card";
import { unstable_noStore as noStore } from "next/cache";
import { redirect } from "next/navigation";
import prisma from "../../lib/db";
import { getUser } from "@/lib/auth";
import { SellPageClient } from "@/app/sell/sell-client";

async function getUserMarketStands(userId: string) {
  const marketStands = await prisma.marketStand.findMany({
    where: {
      userId: userId
    }
  });
  return marketStands;
}

export default async function SellRoute() {
  noStore();
  const user = await getUser();

  if (!user) {
    return redirect('/');
  }

  const marketStands = await getUserMarketStands(user.id);
  if (!marketStands.length) {
    return redirect("/market-stand/setup");
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8 mb-14">
      <Card className="p-6 space-y-6">
        <SellPageClient marketStands={marketStands} />
      </Card>
    </section>
  );
}
</file>

<file path="app/sell/sell-client.tsx">
"use client";

import { MarketStand } from "@prisma/client";
import { useState } from "react";
import { MarketStandSelect } from "../../components/MarketStandSelect";
import { SellForm } from "../../components/form/Sellform";

export function SellPageClient({ marketStands }: { marketStands: MarketStand[] }) {
  const [selectedStandId, setSelectedStandId] = useState(marketStands[0]?.id);
  const selectedStand = marketStands.find(stand => stand.id === selectedStandId);

  return (
    <>
      <MarketStandSelect 
        stands={marketStands}
        selectedId={selectedStandId}
        onSelect={setSelectedStandId}
      />
      {selectedStand && <SellForm marketStand={selectedStand} />}
    </>
  );
}
</file>

<file path="app/settings/loading.tsx">
import { Card, CardHeader } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

export default function LoadingFile() {
  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader className="h-[500px]">
          <Skeleton className="w-full h-full" />
        </CardHeader>
      </Card>
    </div>
  );
}
</file>

<file path="app/settings/page.tsx">
import { Card } from "@/components/ui/card";
import prisma from "@/lib/db";
import { getUser } from "@/lib/auth";
import { SettingsForm } from "@/components/form/SettingsForm";
import { unstable_noStore as noStore } from "next/cache";

async function getData(userId: string) {
  const data = await prisma.user.findUnique({
    where: {
      id: userId,
    },
    select: {
      firstName: true,
      lastName: true,
      email: true,
    },
  });

  return data;
}

export default async function SetttingsPage() {
  noStore();
  const user = await getUser();
  if (!user) {
    throw new Error("Authentication required");
  }

  const data = await getData(user.id);
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <SettingsForm
          firstName={data?.firstName as string}
          lastName={data?.lastName as string}
          email={data?.email as string}
        />
      </Card>
    </section>
  );
}
</file>

<file path="app/actions.ts">
"use server";
import { z } from "zod";
import prisma from "@/lib/db";
import { redirect } from "next/navigation";
import { getUser } from "@/lib/auth";

// Type for market stand data
interface MarketStandData {
  name: string;
  description?: string;
  images: string[];
  tags: string[];
  locationName: string;
  locationGuide: string;
  latitude: number;
  longitude: number;
  userId: string;
}

// Define the market stand schema with coordinate validation
const marketStandSchema = z.object({
  name: z.string().min(3, { message: "The name has to be a min character length of 3" }),
  description: z.string().min(10, { message: "Please describe your market stand in detail" }).optional(),
  images: z.array(z.string(), { message: "Images are required" }),
  tags: z.array(z.string()).default([]),
  locationName: z.string().min(3, { message: "Location name is required" }),
  locationGuide: z.string().min(10, { message: "Please provide detailed directions to find your stand" })
});

// Function to validate and parse market stand data
function validateMarketStandData(data: any): MarketStandData {
  const baseValidation = marketStandSchema.parse(data);
  
  const lat = parseFloat(data.latitude);
  if (isNaN(lat) || lat < -90 || lat > 90) {
    throw new Error("Latitude must be a valid number between -90 and 90 degrees");
  }

  const lng = parseFloat(data.longitude);
  if (isNaN(lng) || lng < -180 || lng > 180) {
    throw new Error("Longitude must be a valid number between -180 and 180 degrees");
  }

  return {
    ...baseValidation,
    latitude: lat,
    longitude: lng,
    userId: data.userId
  };
}

const productSchema = z.object({
  name: z
    .string()
    .min(3, { message: "The name has to be a min character length of 3" }),
  price: z.string()
    .transform((val) => {
      const price = parseFloat(val);
      if (isNaN(price)) throw new Error("Price must be a valid number");
      if (price <= 0) throw new Error("Price must be greater than 0");
      return Math.round(price * 100); // Convert dollars to cents for storage
    }),
  description: z
    .string()
    .min(10, { message: "Please describe your product in detail" }),
  images: z.array(z.string(), { message: "Images are required" }),
  tags: z.array(z.string()).default([]),
  marketStandId: z.string({ required_error: "Market stand is required" }),
  inventory: z.string()
    .transform((val) => {
      const num = parseInt(val || "0", 10);
      if (isNaN(num)) throw new Error("Inventory must be a valid number");
      if (num < 0) throw new Error("Inventory cannot be negative");
      return num;
    })
});

export type State = {
  status: "error" | "success" | undefined;
  errors?: {
    name?: string[];
    price?: string[];
    description?: string[];
    images?: string[];
    marketStandId?: string[];
  };
  message: string | null;
};

export async function SellProduct(
  prevState: State,
  formData: FormData
): Promise<State | Response> {
  try {
    const productId = formData.get("productId")?.toString() || undefined;
    const user = await getUser();

    if (!user || !user.id) {
      return {
        status: "error",
        message: "Not authenticated or invalid user data"
      };
    }

    // Check if user exists in database
    let dbUser = await prisma.user.findUnique({
      where: { id: user.id }
    });

    // Create user if doesn't exist
    if (!dbUser) {
      dbUser = await prisma.user.create({
        data: {
          id: user.id,
          email: user.email ?? '',
          firstName: user.user_metadata?.name?.split(' ')[0] ?? '',
          lastName: user.user_metadata?.name?.split(' ')[1] ?? '',
          profileImage: user.user_metadata?.avatar_url ?? '',
          connectedAccountId: null,
          stripeConnectedLinked: false
        }
      });
    }

    const rawMarketStandId = formData.get("marketStandId");
    const marketStandId = rawMarketStandId ? rawMarketStandId.toString() : undefined;
    if (!marketStandId) {
      return {
        status: "error",
        errors: { marketStandId: ["Market stand is required"] },
        message: "Market stand is required"
      };
    }

    const validateFields = productSchema.safeParse({
      name: formData.get("name")?.toString() ?? "",
      price: formData.get("price")?.toString() ?? "0",
      description: formData.get("description")?.toString() ?? "",
      images: JSON.parse(formData.get("images") as string),
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      marketStandId: marketStandId,
      inventory: formData.get("inventory")?.toString() ?? "0"
    });

    if (!validateFields.success) {
      return {
        status: "error",
        errors: validateFields.error.flatten().fieldErrors,
        message: "Oops, I think there is a mistake with your inputs."
      };
    }

    // If productId exists, update the product instead of creating a new one
    if (productId) {
      const product = await prisma.product.update({
        where: {
          id: productId,
          userId: user.id, // Ensure user owns the product
        },
        data: {
          name: validateFields.data.name,
          description: validateFields.data.description,
          price: validateFields.data.price,
          images: validateFields.data.images,
          tags: validateFields.data.tags,
          marketStandId: validateFields.data.marketStandId,
          inventory: validateFields.data.inventory,
          inventoryUpdatedAt: new Date()
        }
      });

      if (!product) {
        return {
          status: "error",
          message: "Failed to update product"
        };
      }
    } else {
      // Create new product
      const product = await prisma.product.create({
        data: {
          name: validateFields.data.name,
          description: validateFields.data.description,
          price: validateFields.data.price,
          images: validateFields.data.images,
          tags: validateFields.data.tags,
          userId: user.id,
          marketStandId: validateFields.data.marketStandId,
          inventory: validateFields.data.inventory,
          inventoryUpdatedAt: new Date()
        }
      });

      if (!product) {
        return {
          status: "error",
          message: "Failed to create product"
        };
      }
    }

    // Redirect to dashboard after successful product creation/update
    return redirect("/dashboard");
  } catch (error) {
    console.error("[SELL_PRODUCT]", error);
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Failed to save product"
    };
  }
}

export async function UpdateMarketStand(
  prevState: any,
  formData: FormData
): Promise<Response> {
  const user = await getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Not authenticated" }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const marketStandId = formData.get("id")?.toString();
  
  if (!marketStandId) {
    return new Response(JSON.stringify({ error: "Market stand ID is required" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const existingStand = await prisma.marketStand.findUnique({
      where: {
        id: marketStandId,
        userId: user.id
      }
    });

    if (!existingStand) {
      return new Response(JSON.stringify({ error: "Market stand not found or you don't have permission to edit it" }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Parse and validate form data
    const rawImages = formData.get("images");
    const rawFormData = {
      name: formData.get("name")?.toString() ?? "",
      description: formData.get("description")?.toString() ?? "",
      images: rawImages ? JSON.parse(rawImages.toString()) : [],
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      locationName: formData.get("locationName")?.toString() ?? "",
      locationGuide: formData.get("locationGuide")?.toString() ?? "",
      latitude: formData.get("latitude")?.toString() ?? "0",
      longitude: formData.get("longitude")?.toString() ?? "0",
      userId: user.id
    };

    // Validate data
    const marketStandData = validateMarketStandData(rawFormData);

    // Perform update
    const marketStand = await prisma.marketStand.update({
      where: {
        id: marketStandId,
        userId: user.id
      },
      data: {
        name: marketStandData.name,
        description: marketStandData.description,
        images: { set: marketStandData.images },
        tags: { set: marketStandData.tags || [] },
        latitude: marketStandData.latitude,
        longitude: marketStandData.longitude,
        locationName: marketStandData.locationName,
        locationGuide: marketStandData.locationGuide,
        userId: marketStandData.userId
      }
    });

    if (!marketStand) {
      return new Response(JSON.stringify({ error: "Failed to update market stand" }), {
        status: 400
      });
    }

    return Response.redirect(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'}/dashboard`);
  } catch (error) {
    if (error instanceof Error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    return new Response(JSON.stringify({ error: "Failed to update market stand. Please try again." }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

export async function CreateMarketStand(
  prevState: any,
  formData: FormData
): Promise<Response> {
  const user = await getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Not authenticated" }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    // Parse and validate form data
    const rawImages = formData.get("images");
    const rawFormData = {
      name: formData.get("name")?.toString() ?? "",
      description: formData.get("description")?.toString() ?? "",
      images: rawImages ? JSON.parse(rawImages.toString()) : [],
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      locationName: formData.get("locationName")?.toString() ?? "",
      locationGuide: formData.get("locationGuide")?.toString() ?? "",
      latitude: formData.get("latitude")?.toString() ?? "0",
      longitude: formData.get("longitude")?.toString() ?? "0",
      userId: user.id
    };

    const marketStandData = validateMarketStandData(rawFormData);

    // Check if user exists in database
    let dbUser = await prisma.user.findUnique({
      where: { id: user.id }
    });

    // Create user if doesn't exist
    if (!dbUser) {
      dbUser = await prisma.user.create({
        data: {
          id: user.id,
          email: user.email ?? '',
          firstName: user.user_metadata?.name?.split(' ')[0] ?? '',
          lastName: user.user_metadata?.name?.split(' ')[1] ?? '',
          profileImage: user.user_metadata?.avatar_url ?? '',
          connectedAccountId: null,
          stripeConnectedLinked: false
        }
      });
    }

    // Create the market stand
    const result = await prisma.marketStand.create({
      data: {
        name: marketStandData.name,
        description: marketStandData.description,
        images: { set: marketStandData.images },
        tags: { set: marketStandData.tags || [] },
        latitude: marketStandData.latitude,
        longitude: marketStandData.longitude,
        locationName: marketStandData.locationName,
        locationGuide: marketStandData.locationGuide,
        userId: marketStandData.userId
      }
    });

    if (!result) {
      return new Response(JSON.stringify({ error: "Failed to create market stand" }), {
        status: 400
      });
    }

    // Redirect after successful creation
    return Response.redirect(new URL('/dashboard', process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'));
  } catch (error) {
    if (error instanceof Error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    return new Response(JSON.stringify({ error: "Failed to create market stand. Please try again." }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 82 23% 32%;
    --primary-foreground: 82 23% 98%;
    --secondary: 82 15% 96.1%;
    --secondary-foreground: 82 47.4% 11.2%;
    --muted: 82 15% 96.1%;
    --muted-foreground: 82 16.3% 46.9%;
    --accent: 82 15% 96.1%;
    --accent-foreground: 82 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 82 31.8% 91.4%;
    --input: 82 31.8% 91.4%;
    --ring: 82 23% 32%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Navbar } from "@/components/Navbar";
import { Toaster } from "@/components/ui/sonner";
import { SupabaseProvider } from "@/components/providers/SupabaseProvider";

const inter = Inter({
  subsets: ["latin"],
  display: 'swap',
  preload: true,
  adjustFontFallback: true,
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        <link
          rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossOrigin=""
        />
      </head>
      <body className={inter.className}>
        <SupabaseProvider>
          <Navbar />
          {children}
          <Toaster />
        </SupabaseProvider>
      </body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
import { ProductRow } from "../components/ProductRow";
import { createServerComponentClient } from "@supabase/auth-helpers-nextjs";
import { redirect } from "next/navigation";
import { getSupabaseServer } from "@/lib/supabase-server";

export default async function Home({
  searchParams,
}: {
  searchParams: { returnUrl?: string };
}) {
  const supabase = getSupabaseServer();
  
  // Get session
  const { data: { session }, error } = await supabase.auth.getSession();

  // Log auth state for debugging
  console.log('Auth state:', {
    hasSession: !!session,
    returnUrl: searchParams.returnUrl,
    error: error?.message
  });

  // Handle authenticated users with returnUrl
  if (session && searchParams.returnUrl) {
    const decodedUrl = decodeURIComponent(searchParams.returnUrl);
    const protectedRoutes = [
      '/sell',
      '/settings',
      '/market-stand/setup',
      '/billing',
      '/product',
      '/dashboard/market-stand',
      '/dashboard/sell',
      '/dashboard/settings'
    ];

    // Only redirect to protected routes
    if (protectedRoutes.some(route => decodedUrl.startsWith(route))) {
      redirect(decodedUrl);
    }
  }

  // If user is authenticated but no returnUrl, show home page
  // If user is not authenticated, show home page
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8 mb-24">
      <div className="max-w-3xl mx-auto text-2xl sm:text-5xl lg:text-6xl font-semibold text-center">
        <h1>Discover Fresh Local</h1>
        <h1 className="text-primary">Farm Products</h1>
        <p className="lg:text-lg text-muted-foreground mx-auto mt-5 w-[90%] font-normal text-base">
          Find the freshest products from local farmstands near you. Support your local
          farmers and enjoy farm-fresh goods delivered directly to you.
        </p>
      </div>
      <ProductRow title="Recently Added" link="/local-spots" />
    </section>
  );
}
</file>

<file path="components/form/AuthForm.tsx">
"use client";

import { useState } from "react";
import { signInWithEmail, signUpWithEmail } from "@/app/actions/auth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useRouter } from "next/navigation";

export function AuthForm() {
  const [isLoading, setIsLoading] = useState(false);
  const [isSignUp, setIsSignUp] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      if (isSignUp) {
        await signUpWithEmail(email, password);
        // Show confirmation message for sign up
        setError("Please check your email to confirm your account");
      } else {
        await signInWithEmail(email, password);
        router.refresh();
      }
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full max-w-md space-y-8">
      <div className="text-center">
        <h2 className="text-2xl font-bold">
          {isSignUp ? "Create an account" : "Sign in to your account"}
        </h2>
      </div>

      <form onSubmit={handleSubmit} className="mt-8 space-y-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="email">Email address</Label>
            <Input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              className="mt-1"
              disabled={isLoading}
            />
          </div>

          <div>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              autoComplete={isSignUp ? "new-password" : "current-password"}
              required
              className="mt-1"
              disabled={isLoading}
            />
          </div>
        </div>

        {error && (
          <div className="text-sm text-red-500 text-center">{error}</div>
        )}

        <div>
          <Button
            type="submit"
            className="w-full"
            disabled={isLoading}
          >
            {isLoading
              ? "Loading..."
              : isSignUp
              ? "Sign up"
              : "Sign in"}
          </Button>
        </div>

        <div className="text-center">
          <button
            type="button"
            onClick={() => setIsSignUp(!isSignUp)}
            className="text-sm text-blue-600 hover:text-blue-500"
            disabled={isLoading}
          >
            {isSignUp
              ? "Already have an account? Sign in"
              : "Don't have an account? Sign up"}
          </button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="components/form/MarketStandForm.tsx">
"use client";

import { CreateMarketStand, UpdateMarketStand, type State } from "@/app/actions";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect, useState } from "react";
import { X } from "lucide-react";
import { toast } from "sonner";
import { Textarea } from "@/components/ui/textarea";
import { ImageUpload } from "@/components/ImageUpload";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";
import { SubmitStandButton } from "./SubmitStandButton";

interface MarketStandFormProps {
  userId: string;
  marketStand?: {
    id: string;
    name: string;
    description: string | null;
    images: string[];
    tags: string[];
    latitude: number;
    longitude: number;
    locationName: string;
    locationGuide: string;
  };
}

interface FormState {
  values: {
    name: string;
    description: string;
    locationName: string;
    locationGuide: string;
    latitude: string;
    longitude: string;
    tags: string[];
    currentTag: string;
  };
  errors: {
    name?: string;
    description?: string;
    locationName?: string;
    locationGuide?: string;
    latitude?: string;
    longitude?: string;
    images?: string;
  };
}

const validateField = (name: string, value: string | string[]): string | undefined => {
  // Skip validation for array values (tags)
  if (Array.isArray(value)) return undefined;
  
  if (!value || value.trim() === '') return "This field is required";
  
  switch (name) {
    case "name":
      return value.length < 3 ? "Name must be at least 3 characters long" : undefined;
    case "description":
      return value.length < 10 ? "Must be at least 10 characters long" : undefined;
    case "locationName":
      return value.length < 3 ? "Location name must be at least 3 characters long" : undefined;
    case "locationGuide":
      return value.length < 10 ? "Must provide detailed directions" : undefined;
    case "latitude":
      const lat = parseFloat(value);
      if (isNaN(lat) || lat < -90 || lat > 90) return "Must be between -90 and 90";
      return undefined;
    case "longitude":
      const lng = parseFloat(value);
      if (isNaN(lng) || lng < -180 || lng > 180) return "Must be between -180 and 180";
      return undefined;
    default:
      return undefined;
  }
};

export function MarketStandForm({ userId, marketStand }: MarketStandFormProps): JSX.Element {
  const router = useRouter();
  const [images, setImages] = useState<string[]>(marketStand?.images || []);
  const [formState, setFormState] = useState<FormState>({
    values: {
      name: marketStand?.name || '',
      description: marketStand?.description || '',
      locationName: marketStand?.locationName || '',
      locationGuide: marketStand?.locationGuide || '',
      latitude: marketStand?.latitude?.toString() || '',
      longitude: marketStand?.longitude?.toString() || '',
      tags: marketStand?.tags || [],
      currentTag: ''
    },
    errors: {}
  });

  const handleFieldChange = (name: string, value: string) => {
    setFormState(prev => {
      const newErrors = { ...prev.errors };
      const error = validateField(name, value);
      
      if (error) {
        newErrors[name as keyof FormState['errors']] = error;
      } else {
        delete newErrors[name as keyof FormState['errors']];
      }

      return {
        ...prev,
        values: { ...prev.values, [name]: value },
        errors: newErrors
      };
    });
  };

  const removeImage = (indexToRemove: number) => {
    setImages(prev => prev.filter((_, index) => index !== indexToRemove));
  };

  const validateForm = (): boolean => {
    const newErrors: FormState['errors'] = {};
    let isValid = true;

    // Validate required fields only
    const fieldsToValidate = ['name', 'description', 'locationName', 'locationGuide', 'latitude', 'longitude'];
    fieldsToValidate.forEach(name => {
      const value = formState.values[name as keyof typeof formState.values];
      const error = validateField(name, value);
      if (error) {
        newErrors[name as keyof FormState['errors']] = error;
        isValid = false;
      }
    });

    // Validate images
    if (images.length === 0) {
      newErrors.images = "At least one image is required";
      isValid = false;
    }

    setFormState(prev => ({
      ...prev,
      errors: newErrors
    }));

    return isValid;
  };

  const handleAddTag = () => {
    const tag = formState.values.currentTag.trim();
    if (tag) {
      const capitalizedTag = tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase();
      if (!formState.values.tags.includes(capitalizedTag)) {
        setFormState(prev => ({
          ...prev,
          values: {
            ...prev.values,
            tags: [...prev.values.tags, capitalizedTag],
            currentTag: ''
          }
        }));
      }
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormState(prev => ({
      ...prev,
      values: {
        ...prev.values,
        tags: prev.values.tags.filter(tag => tag !== tagToRemove)
      }
    }));
  };

  const handleTagKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    
    if (!validateForm()) {
      toast.error("Please fix the validation errors");
      return;
    }

    const formData = new FormData(e.currentTarget);
    formData.append('images', JSON.stringify(images));
    formData.append('tags', JSON.stringify(formState.values.tags));

    try {
      if (marketStand) {
        formData.append("id", marketStand.id);
        const result = await UpdateMarketStand({ status: undefined, message: null }, formData);
        // console.log('result:\n', result)
        if (!result.ok) {
          const data = await result.json();
          toast.error(data.error);
          return;
        }
        if (result.redirected) {
          window.location.href = result.url;
          return;
        }
      } else {
        const result = await CreateMarketStand({ status: undefined, message: null }, formData);
        if (!result.ok) {
          console.log('first')
          const data = await result.json();
          toast.error(data.error);
          return;
        }
        if (result.redirected) {
          console.log('second')
          window.location.href = result.url;
          return;
        }
      }
    } catch (error) {
      toast.error("An error occurred. Please try again.");
    }
  };

  // Validate images when they change
  useEffect(() => {
    if (images.length === 0) {
      setFormState(prev => ({
        ...prev,
        errors: { ...prev.errors, images: "At least one image is required" }
      }));
    } else {
      setFormState(prev => {
        const newErrors = { ...prev.errors };
        delete newErrors.images;
        return { ...prev, errors: newErrors };
      });
    }
  }, [images]);

  const isFormValid = Object.keys(formState.errors).length === 0;

  return (
    <form onSubmit={handleSubmit} className="w-full max-w-4xl mx-auto">
      <CardHeader>
        <CardTitle>{marketStand ? 'Edit your market stand' : 'Create your market stand'}</CardTitle>
        <CardDescription>
          Please provide details about your market stand
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-8">
        <div className="flex flex-col gap-y-2">
          <Label>Name</Label>
          <Input
            name="name"
            type="text"
            placeholder="Name of your Market Stand"
            required
            minLength={3}
            value={formState.values.name}
            onChange={(e) => handleFieldChange('name', e.target.value)}
            className={formState.errors.name ? 'border-destructive' : ''}
          />
          {formState.errors.name && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.name}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Description</Label>
          <Textarea
            name="description"
            placeholder="Please describe your market stand..."
            required
            minLength={10}
            value={formState.values.description}
            onChange={(e) => handleFieldChange('description', e.target.value)}
            className={formState.errors.description ? 'border-destructive' : ''}
          />
          {formState.errors.description && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.description}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Location Name</Label>
          <Input
            name="locationName"
            type="text"
            placeholder="e.g., Central Park, Downtown Market"
            required
            minLength={3}
            value={formState.values.locationName}
            onChange={(e) => handleFieldChange('locationName', e.target.value)}
            className={formState.errors.locationName ? 'border-destructive' : ''}
          />
          {formState.errors.locationName && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.locationName}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Location Guide</Label>
          <Textarea
            name="locationGuide"
            placeholder="Please provide detailed directions to find your stand..."
            required
            minLength={10}
            value={formState.values.locationGuide}
            onChange={(e) => handleFieldChange('locationGuide', e.target.value)}
            className={formState.errors.locationGuide ? 'border-destructive' : ''}
          />
          {formState.errors.locationGuide && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.locationGuide}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2 mb-8">
          <Label>Tags</Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {formState.values.tags.map((tag, index) => (
              <div
                key={index}
                className="flex items-center gap-1 bg-secondary px-2 py-1 rounded-md"
              >
                <span>{tag}</span>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => handleRemoveTag(tag)}
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            ))}
          </div>
          <div className="flex gap-x-2">
            <Input
              type="text"
              placeholder="Add a tag"
              value={formState.values.currentTag}
              onChange={(e) => setFormState(prev => ({
                ...prev,
                values: { ...prev.values, currentTag: e.target.value }
              }))}
              onKeyPress={handleTagKeyPress}
            />
            <Button
              type="button"
              onClick={handleAddTag}
              disabled={!formState.values.currentTag.trim()}
            >
              Add
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
          <div className="flex flex-col gap-y-2">
            <Label>Latitude</Label>
            <Input
              name="latitude"
              type="number"
              step="any"
              placeholder="e.g., 40.7128"
              required
              value={formState.values.latitude}
              onChange={(e) => handleFieldChange('latitude', e.target.value)}
              className={formState.errors.latitude ? 'border-destructive' : ''}
            />
            {formState.errors.latitude && (
              <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.latitude}</p>
            )}
          </div>

          <div className="flex flex-col gap-y-2">
            <Label>Longitude</Label>
            <Input
              name="longitude"
              type="number"
              step="any"
              placeholder="e.g., -74.0060"
              required
              value={formState.values.longitude}
              onChange={(e) => handleFieldChange('longitude', e.target.value)}
              className={formState.errors.longitude ? 'border-destructive' : ''}
            />
            {formState.errors.longitude && (
              <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.longitude}</p>
            )}
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Market Stand Images</Label>
          {formState.errors.images && (
            <p className="text-sm font-medium text-destructive mb-2">{formState.errors.images}</p>
          )}
          {images.length > 0 && (
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
              {images.map((url, index) => (
                <div key={index} className="relative aspect-square group">
                  <img
                    src={url}
                    alt={`Market stand image ${index + 1}`}
                    className="object-cover rounded-lg w-full h-full"
                  />
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => removeImage(index)}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}
          <ImageUpload
            onUploadComplete={(urls) => {
              setImages(prev => [...prev, ...urls]);
              toast.success("Images uploaded successfully");
            }}
            maxFiles={5}
          />
        </div>
      </CardContent>
      <CardFooter className="mt-5">
        <div className="flex-1 flex justify-end">
          <SubmitStandButton 
            title={marketStand ? "Save Changes" : "Create Market Stand"}
            isFormValid={isFormValid}
          />
        </div>
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/Sellform.tsx">
"use client";

import { SellProduct, type State } from "@/app/actions";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { redirect } from "next/navigation";
import Link from "next/link";
import { useEffect, useState } from "react";
import { useFormState, useFormStatus } from "react-dom";
import { MapPin, Plus, X } from "lucide-react";
import { toast } from "sonner";
import { Textarea } from "@/components/ui/textarea";
import { ImageUpload } from "@/components/ImageUpload";
import { Submitbutton } from "@/components/SubmitButtons";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import Image from "next/image";

interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  createdAt: Date;
  userId: string | null;
}

interface SellFormProps {
  marketStand?: MarketStand;
  initialData?: {
    name: string;
    price: number;
    description: string;
    images: string[];
    tags: string[];
    marketStandId: string;
    inventory?: number;
    inventoryUpdatedAt?: Date | null;
  };
  productId?: string;
}

function isState(state: State | Response): state is State {
  return (state as State).status !== undefined;
}

const sellProductAction = async (state: State | Response, formData: FormData) => {
  const result = await SellProduct(state as State, formData);
  return result;
};

export function SellForm({ marketStand, initialData, productId }: SellFormProps) {
  const initialState: State = { message: null, status: undefined };
  const [state, formAction] = useFormState(sellProductAction, initialState);
  const [images, setImages] = useState<string[]>(initialData?.images || []);
  const [tags, setTags] = useState<string[]>(initialData?.tags || []);
  const [currentTag, setCurrentTag] = useState('');

  const handleAddTag = () => {
    const tag = currentTag.trim();
    if (tag) {
      const capitalizedTag = tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase();
      if (!tags.includes(capitalizedTag)) {
        setTags(prev => [...prev, capitalizedTag]);
        setCurrentTag('');
      }
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setTags(prev => prev.filter(tag => tag !== tagToRemove));
  };

  const handleTagKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };
  
  useEffect(() => {
    if (isState(state) && state.status === "success" && state.message) {
      toast.success(state.message);
    } else if (isState(state) && state.status === "error" && state.message) {
      if (state.message.includes("Stripe account")) {
        toast.error(
          <div className="flex flex-col gap-2">
            <p>{state.message}</p>
            <Link href="/billing" className="text-sm text-blue-500 hover:underline">
              Go to billing settings
            </Link>
          </div>
        );
      } else {
        toast.error(state.message);
      }
    }
  }, [state]);

  return (
    <form action={formAction}>
      <CardHeader>
        <CardTitle>{productId ? 'Edit your product' : 'Sell your product with ease'}</CardTitle>
        <CardDescription>
          Please describe your product here in detail so that it can be sold
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-8">
        <div className="flex flex-col gap-y-2">
          <Label htmlFor="name">Name</Label>
          <Input
            id="name"
            name="name"
            type="text"
            placeholder="Name of your Product"
            required
            minLength={3}
            defaultValue={initialData?.name}
            aria-label="Product name"
          />
          {isState(state) && state.errors?.name?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.name[0]}</p>
          )}
        </div>

        {productId && <input type="hidden" name="productId" value={productId} />}
        <input 
          type="hidden" 
          name="marketStandId" 
          value={initialData?.marketStandId || marketStand?.id} 
        />

        {marketStand && (
          <div className="flex flex-col gap-y-4">
            <Label>Market Stand</Label>
            <div className="p-4 border rounded-lg">
              <h3 className="font-medium">{marketStand.name}</h3>
              <p className="text-sm text-muted-foreground mt-1">
                {marketStand.description || 'No description'}
              </p>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
          <div className="flex flex-col gap-y-2">
            <Label htmlFor="price">Price</Label>
            <Input
              id="price"
              placeholder="29.99"
              type="text"
              pattern="^\d*\.?\d{0,2}$"
              name="price"
              required
              defaultValue={initialData ? (initialData.price / 100).toFixed(2) : undefined}
              aria-label="Product price"
              title="Enter a valid price with up to 2 decimal places"
            />
            {isState(state) && state.errors?.price?.[0] && (
              <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.price[0]}</p>
            )}
          </div>

          <div className="flex flex-col gap-y-2">
            <Label htmlFor="inventory">Initial Inventory</Label>
            <Input
              id="inventory"
              placeholder="0"
              type="number"
              name="inventory"
              min={0}
              defaultValue={initialData?.inventory ?? 0}
              aria-label="Initial inventory amount"
            />
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <Label htmlFor="description">Description</Label>
          <Textarea
            id="description"
            name="description"
            placeholder="Please describe your product in detail..."
            required
            minLength={10}
            defaultValue={initialData?.description}
            aria-label="Product description"
          />
          {isState(state) && state.errors?.description?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">
              {state.errors.description[0]}
            </p>
          )}
        </div>

        <div className="flex flex-col gap-y-2 mb-8">
          <Label>Tags</Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {tags.map((tag, index) => (
              <div
                key={index}
                className="flex items-center gap-1 bg-secondary px-2 py-1 rounded-md"
              >
                <span>{tag}</span>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => handleRemoveTag(tag)}
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            ))}
          </div>
          <div className="flex gap-x-2">
            <Input
              type="text"
              placeholder="Add a tag"
              value={currentTag}
              onChange={(e) => setCurrentTag(e.target.value)}
              onKeyPress={handleTagKeyPress}
            />
            <Button
              type="button"
              onClick={handleAddTag}
              disabled={!currentTag.trim()}
            >
              Add
            </Button>
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <input type="hidden" name="images" value={JSON.stringify(images)} />
          <input type="hidden" name="tags" value={JSON.stringify(tags)} />
          <Label>Product Images</Label>
          {images.length > 0 && (
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
              {images.map((url, index) => (
                <div key={index} className="relative w-full h-48 group">
                  <Image
                    src={url}
                    alt={`Product image ${index + 1}`}
                    fill
                    sizes="(max-width: 768px) 50vw, 33vw"
                    className="rounded-lg object-cover"
                  />
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => setImages(images.filter((_, i) => i !== index))}
                    aria-label={`Remove image ${index + 1}`}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}
          <ImageUpload
            onUploadComplete={(urls) => {
              setImages(prev => [...prev, ...urls]);
              toast.success("Images uploaded successfully");
            }}
            maxFiles={5}
          />
          {isState(state) && state.errors?.images?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.images[0]}</p>
          )}
        </div>
      </CardContent>
      <CardFooter className="mt-5">
        <Submitbutton title={productId ? "Save Changes" : "Create your Product"} />
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/SettingsForm.tsx">
"use client";

import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { useFormState } from "react-dom";

import { useEffect } from "react";
import { toast } from "sonner";
import { type State, UpdateUserSettings } from "@/app/actions/settings";
import { Submitbutton } from "../SubmitButtons";

interface iAppProps {
  firstName: string;
  lastName: string;
  email: string;
}

export function SettingsForm({ email, firstName, lastName }: iAppProps) {
  const initalState: State = { message: "", status: undefined };
  const [state, formAction] = useFormState(UpdateUserSettings, initalState);

  useEffect(() => {
    if (state?.status === "error") {
      toast.error(state.message);
    } else if (state?.status === "success") {
      toast.success(state.message);
    }
  }, [state]);
  return (
    <form action={formAction}>
      <CardHeader>
        <CardTitle>Settings</CardTitle>
        <CardDescription>
          Here you will find settings regarding your account
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-5">
        <div className="flex flex-col gap-y-2">
          <Label>First Name</Label>
          <Input name="firstName" type="text" defaultValue={firstName} />
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Last Name</Label>
          <Input name="lastName" type="text" defaultValue={lastName} />
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Email</Label>
          <Input
            name="email"
            type="email"
            disabled
            defaultValue={"jan@alenix.de"}
          />
        </div>
      </CardContent>
      <CardFooter>
        <Submitbutton title="Update your settings" />
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/SubmitStandButton.tsx">
"use client";

import { useFormStatus } from "react-dom";
import { Button } from "../ui/button";

interface SubmitStandButtonProps {
  title: string;
  isFormValid: boolean;
}

export function SubmitStandButton({ title, isFormValid }: SubmitStandButtonProps) {
  const { pending } = useFormStatus();
  
  return (
    <Button 
      type="submit"
      disabled={!isFormValid || pending}
      className="min-w-[150px]"
    >
      {pending ? "Submitting..." : title}
    </Button>
  );
}
</file>

<file path="components/providers/SupabaseProvider.tsx">
"use client";

import { createContext, useContext, useEffect, useState } from "react";
import { User } from "@supabase/supabase-js";
import { getSupabaseBrowser } from "@/lib/supabase-browser";

interface SupabaseContextType {
  user: User | null;
  isLoading: boolean;
}

const SupabaseContext = createContext<SupabaseContextType>({
  user: null,
  isLoading: true,
});

export function SupabaseProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const supabase = getSupabaseBrowser();
    
    // Get initial session
    // console.log('[Supabase Auth] Checking initial session...');
    supabase.auth.getSession().then(({ data: { session } }) => {
// console.log('[Supabase Auth] Initial session:', JSON.stringify({
//   accessToken: session?.access_token ? '(present)' : null,
//   user: session?.user ? {
//     id: session.user.id,
//     email: session.user.email,
//     role: session.user.role,
//   } : null
// }, null, 2));
      setUser(session?.user ?? null);
      setIsLoading(false);
      // console.log('[Supabase Auth] Loading state set to:', false);
    });

    // Listen for auth changes
    // console.log('Listen for auth changes');
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
// console.log('[Supabase Auth] Auth state changed:', JSON.stringify({
//   event,
//   accessToken: session?.access_token ? '(present)' : null,
//   user: session?.user ? {
//     id: session.user.id,
//     email: session.user.email,
//     role: session.user.role,
//   } : null
// }, null, 2));
      
      // Update state
      setUser(session?.user ?? null);
      setIsLoading(false);
      // console.log('[Supabase Auth] Loading state set to:', false);
      
      // Sync with server
      // console.log('sync with server');
      if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
        const response = await fetch('/api/auth/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ event, session })
        });
        
        if (!response.ok) {
          // console.error('[Supabase Auth] Failed to sync session with server');
        }
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  return (
    <SupabaseContext.Provider value={{ user, isLoading }}>
      {children}
    </SupabaseContext.Provider>
  );
}

export const useSupabase = () => {
  const context = useContext(SupabaseContext);
  if (context === undefined) {
    throw new Error("useSupabase must be used within a SupabaseProvider");
  }
  return context;
};
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "../../lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="components/ui/carousel.tsx">
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "../../lib/utils"
import { Button } from "./button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full opacity-70 hover:opacity-100 transition-opacity",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      aria-label="View previous slide"
      title="Previous slide"
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full opacity-70 hover:opacity-100 transition-opacity",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      aria-label="View next slide"
      title="Next slide"
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "../../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="components/ui/sheet.tsx">
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "../../lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "../../lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="components/AuthDialog.tsx">
"use client";

import { useState } from "react";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { LogIn } from "lucide-react";
import { getSupabaseBrowser } from "@/lib/supabase-browser";
import { signInWithEmail, signUpWithEmail } from "@/app/actions/auth";

interface AuthDialogProps {
  mode?: 'login' | 'signup';
  trigger?: React.ReactNode;
  className?: string;
}

export function AuthDialog({ mode = 'login', trigger, className }: AuthDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [isEmailMode, setIsEmailMode] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSignUp, setIsSignUp] = useState(mode === 'signup');
  const [open, setOpen] = useState(false);

  const handleGoogleAuth = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const supabase = getSupabaseBrowser();
      await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}${window.location.pathname}`,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
          },
        },
      });
    } catch (error) {
      console.error('[Auth] Authentication error:', error);
      setError((error as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleEmailAuth = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      if (isSignUp) {
        await signUpWithEmail(email, password);
        setError("Please check your email to confirm your account");
      } else {
        await signInWithEmail(email, password);
        setOpen(false);
      }
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  const customTrigger = trigger || (
    <Button 
      variant="ghost" 
      size="sm" 
      className={`gap-2 ${className}`}
      disabled={isLoading}
    >
      <LogIn className="h-4 w-4" />
      {isSignUp ? "Sign Up" : "Login"}
    </Button>
  );

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {customTrigger}
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <div className="flex flex-col space-y-4 py-4">
          <h2 className="text-lg font-semibold text-center">
            {isSignUp ? "Create an account" : "Sign in to your account"}
          </h2>

          {!isEmailMode ? (
            <>
              <Button
                variant="outline"
                onClick={handleGoogleAuth}
                disabled={isLoading}
                className="w-full"
              >
                Continue with Google
              </Button>

              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <span className="w-full border-t" />
                </div>
                <div className="relative flex justify-center text-xs uppercase">
                  <span className="bg-background px-2 text-muted-foreground">
                    Or continue with
                  </span>
                </div>
              </div>

              <Button
                variant="outline"
                onClick={() => setIsEmailMode(true)}
                disabled={isLoading}
              >
                Continue with Email
              </Button>
            </>
          ) : (
            <form onSubmit={handleEmailAuth} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  name="email"
                  type="email"
                  required
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  name="password"
                  type="password"
                  required
                  disabled={isLoading}
                />
              </div>

              {error && (
                <div className="text-sm text-red-500 text-center">{error}</div>
              )}

              <Button
                type="submit"
                className="w-full"
                disabled={isLoading}
              >
                {isLoading
                  ? "Loading..."
                  : isSignUp
                  ? "Sign up"
                  : "Sign in"}
              </Button>

              <Button
                type="button"
                variant="ghost"
                className="w-full"
                onClick={() => setIsEmailMode(false)}
                disabled={isLoading}
              >
                Back to options
              </Button>
            </form>
          )}

          <div className="text-center text-sm">
            <button
              type="button"
              onClick={() => setIsSignUp(!isSignUp)}
              className="text-blue-600 hover:text-blue-500"
              disabled={isLoading}
            >
              {isSignUp
                ? "Already have an account? Sign in"
                : "Don't have an account? Sign up"}
            </button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/Editor.tsx">
"use client";

import { Button } from "./ui/button";
import {
  EditorContent,
  JSONContent,
  useEditor,
  type Editor,
} from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import { useState } from "react";
import {
  Bold,
  Italic,
  Strikethrough,
  Heading1,
  Heading2,
  Heading3,
} from "lucide-react";

export const MenuBar = ({ editor }: { editor: Editor | null }) => {
  if (!editor) {
    return null;
  }

  return (
    <div className="flex flex-wrap gap-2">
      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
        variant={editor.isActive("heading", { level: 1 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 1"
        title="Heading 1 (Ctrl+Alt+1)"
      >
        <Heading1 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        variant={editor.isActive("heading", { level: 2 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 2"
        title="Heading 2 (Ctrl+Alt+2)"
      >
        <Heading2 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        variant={editor.isActive("heading", { level: 3 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 3"
        title="Heading 3 (Ctrl+Alt+3)"
      >
        <Heading3 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleBold().run()}
        variant={editor.isActive("bold") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Bold"
        title="Bold (Ctrl+B)"
      >
        <Bold className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleItalic().run()}
        variant={editor.isActive("italic") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Italic"
        title="Italic (Ctrl+I)"
      >
        <Italic className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleStrike().run()}
        variant={editor.isActive("strike") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Strikethrough"
        title="Strikethrough (Ctrl+Shift+X)"
      >
        <Strikethrough className="h-4 w-4" />
      </Button>
    </div>
  );
};

export function TipTapEditor({
  setJson,
  json,
}: {
  setJson: (json: JSONContent) => void;
  json: JSONContent | null;
}) {
  const editor = useEditor({
    extensions: [StarterKit],
    content: json,
    editorProps: {
      attributes: {
        class: "focus:outline-none min-h-[150px] prose prose-sm sm:prose-base",
      },
    },
    onUpdate: ({ editor }) => {
      setJson(editor.getJSON());
    },
  });

  return (
    <div className="rounded-md border">
      <div className="border-b bg-muted/50 p-2">
        <MenuBar editor={editor} />
      </div>
      <EditorContent
        editor={editor}
        className="p-3 min-h-[150px]"
      />
    </div>
  );
}
</file>

<file path="components/FloatingTimer.tsx">
'use client';

import { useEffect, useState } from 'react';

interface FloatingTimerProps {
  updatedAt: Date;
}

export function FloatingTimer({ updatedAt }: FloatingTimerProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <div className="absolute top-2 right-2 bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm font-mono">
      {timeElapsed}
    </div>
  );
}
</file>

<file path="components/ImageUpload.tsx">
"use client";

import { useCallback, useState } from 'react';
import { Button } from './ui/button';
import { toast } from 'sonner';
import { useRouter } from 'next/navigation';

interface ImageUploadProps {
  onUploadComplete: (urls: string[]) => void;
  maxFiles?: number;
}

export function ImageUpload({
  onUploadComplete,
  maxFiles = 5,
}: ImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const router = useRouter();

  const handleFileChange = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) {
      return;
    }

    const files = Array.from(e.target.files).slice(0, maxFiles);
    setIsUploading(true);

    try {
      const uploadPromises = files.map(async (file) => {
        const formData = new FormData();
        formData.append('file', file);

        const response = await fetch('/api/upload', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(error);
        }

        const data = await response.json();
        return data.url;
      });

      const urls = await Promise.all(uploadPromises);
      onUploadComplete(urls);
      toast.success(`Successfully uploaded ${urls.length} image${urls.length === 1 ? '' : 's'}`);
    } catch (error) {
      console.error('Upload failed:', error);
      if (error instanceof Error) {
        toast.error(error.message);
      } else {
        toast.error('Failed to upload images');
      }
    } finally {
      setIsUploading(false);
      if (e.target) {
        e.target.value = ''; // Reset the input
      }
    }
  }, [maxFiles, onUploadComplete]);

  return (
    <div className="flex flex-col items-center gap-4">
      <input
        type="file"
        accept="image/*"
        multiple
        max={maxFiles}
        onChange={handleFileChange}
        className="hidden"
        id="image-upload"
        disabled={isUploading}
      />
      <label htmlFor="image-upload">
        <Button
          type="button"
          variant="outline"
          disabled={isUploading}
          className="cursor-pointer"
          asChild
        >
          <span>
            {isUploading ? 'Uploading...' : `Upload Images (Max ${maxFiles})`}
          </span>
        </Button>
      </label>
    </div>
  );
}
</file>

<file path="components/InventoryManager.tsx">
'use client';

import { useState } from "react";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Loader2 } from "lucide-react";

interface InventoryManagerProps {
  productId: string;
  currentInventory: number;
  lastUpdated: Date | string | null;
  isOwner: boolean;
}

export function InventoryManager({ productId, currentInventory, lastUpdated, isOwner }: InventoryManagerProps) {
  const [inventory, setInventory] = useState(currentInventory);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const handleUpdate = async () => {
    try {
      setIsLoading(true);
      setError("");

      const response = await fetch(`/api/product`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          id: productId,
          inventory: inventory,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update inventory");
      }

      // Refresh the page to show updated data
      window.location.reload();
    } catch (error) {
      console.error("Error updating inventory:", error);
      setError("Failed to update inventory");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="mt-6 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-muted-foreground">Inventory:</h3>
        <span className="text-sm font-medium">{currentInventory} units</span>
      </div>

      {lastUpdated && (
        <div className="flex items-center justify-between">
          <h3 className="text-sm font-medium text-muted-foreground">Last Updated:</h3>
          <span className="text-sm text-muted-foreground">
            {new Intl.DateTimeFormat("en-US", {
              dateStyle: "medium",
              timeStyle: "short",
            }).format(typeof lastUpdated === 'string' ? new Date(lastUpdated) : lastUpdated)}
          </span>
        </div>
      )}

      {isOwner && (
        <div className="space-y-4 border-t pt-4 mt-4">
          <h3 className="text-sm font-medium">Update Inventory</h3>
          <div className="flex items-center gap-4">
            <Input
              id="inventory-amount"
              type="number"
              min="0"
              value={inventory}
              onChange={(e) => setInventory(Number(e.target.value))}
              className="w-24"
              aria-label="New inventory amount"
              aria-describedby={error ? "inventory-error" : undefined}
            />
            <Button 
              onClick={handleUpdate} 
              disabled={isLoading || inventory === currentInventory}
              size="sm"
              aria-label={isLoading ? "Updating inventory..." : "Update inventory"}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  <span>Updating...</span>
                </>
              ) : (
                "Update"
              )}
            </Button>
          </div>
          {error && (
            <p 
              id="inventory-error" 
              className="text-sm font-medium text-destructive mt-1.5"
            >
              {error}
            </p>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/MapView.tsx">
interface MapViewProps {
  latitude: number;
  longitude: number;
  locationName: string;
}

export default function MapView({ latitude, longitude, locationName }: MapViewProps) {
  // Validate coordinates
  if (typeof latitude !== 'number' || typeof longitude !== 'number' || 
      isNaN(latitude) || isNaN(longitude)) {
    console.error('Invalid coordinates:', { latitude, longitude });
    return (
      <div className="w-full h-full min-h-[200px] flex items-center justify-center">
        Invalid coordinates
      </div>
    );
  }

  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS || '';
  const mapUrl = `https://www.google.com/maps/embed/v1/place?key=${apiKey}&q=${latitude},${longitude}&zoom=14`;

  return (
    <iframe
      width="100%"
      height="100%"
      style={{ minHeight: '200px', border: 0 }}
      loading="lazy"
      allowFullScreen
      referrerPolicy="no-referrer-when-downgrade"
      src={mapUrl}
      title={`Map showing location of ${locationName}`}
    />
  );
}
</file>

<file path="components/MarketStandCard.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { MapPin, Package } from "lucide-react";
import Image from "next/image";
import Link from "next/link";

interface MarketStandCardProps {
  stand: {
    id: string;
    name: string;
    description: string | null;
    locationName: string;
    locationGuide: string;
    latitude: number;
    longitude: number;
    images: string[];
    tags: string[];
    _count: {
      products: number;
    };
  };
}

export function MarketStandCard({ stand }: MarketStandCardProps) {
  if (!stand) {
    return null;
  }

  return (
    <Link href={`/market-stand/${stand.id}`} className="block transition-transform hover:scale-[1.02]">
      <Card key={stand.id} className="h-full hover:shadow-lg transition-shadow">
        <CardHeader>
          <CardTitle>{stand.name}</CardTitle>
        </CardHeader>
        <CardContent>
          {stand.images?.[0] && (
            <div className="relative w-full h-48 mb-4 rounded-lg overflow-hidden">
              <Image
                src={stand.images[0]}
                alt={stand.name}
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
              />
            </div>
          )}
          <p className="text-sm text-muted-foreground mb-4">
            {stand.description}
          </p>
          <div className="space-y-4">
            <div className="flex items-center gap-4 text-sm">
              <div className="flex items-center gap-1">
                <MapPin className="h-4 w-4" />
                {stand.locationName}
              </div>
              <div className="flex items-center gap-1">
                <Package className="h-4 w-4" />
                {stand._count.products} products
              </div>
            </div>
            {stand.tags?.length > 0 && (
              <div className="flex flex-wrap gap-2">
                {stand.tags.map((tag, index) => (
                  <div
                    key={index}
                    className="bg-secondary px-2 py-1 rounded-md text-xs"
                  >
                    {tag}
                  </div>
                ))}
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </Link>
  );
}
</file>

<file path="components/MarketStandQR.tsx">
'use client';

import QRCode from "react-qr-code";

interface MarketStandQRProps {
  marketStandId: string;
  size?: number;
}

export function MarketStandQR({ marketStandId, size = 128 }: MarketStandQRProps) {
  // Create a URL that includes the market stand ID
  const qrValue = `${process.env.NEXT_PUBLIC_APP_URL}/market-stand/${marketStandId}`;

  return (
    <div className="bg-white p-4 rounded-lg inline-block">
      <QRCode
        value={qrValue}
        size={size}
        style={{ height: "auto", maxWidth: "100%", width: "100%" }}
        viewBox={`0 0 ${size} ${size}`}
      />
    </div>
  );
}
</file>

<file path="components/MarketStandSelect.tsx">
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select";
import { MarketStand } from "@prisma/client";

interface MarketStandSelectProps {
  stands: MarketStand[];
  selectedId: string;
  onSelect: (standId: string) => void;
}

export function MarketStandSelect({ stands, selectedId, onSelect }: MarketStandSelectProps) {
  return (
    <div className="w-full space-y-2">
      <label className="text-sm font-medium">Select Market Stand</label>
      <Select value={selectedId} onValueChange={onSelect}>
        <SelectTrigger>
          <SelectValue placeholder="Select a market stand" />
        </SelectTrigger>
        <SelectContent>
          {stands.map((stand) => (
            <SelectItem key={stand.id} value={stand.id}>
              {stand.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="components/MarketStandsMap.tsx">
'use client';

import { useState, useCallback, useMemo } from 'react';
import { GoogleMap, useJsApiLoader, Marker, InfoWindow, Libraries } from '@react-google-maps/api';
import Link from 'next/link';

const libraries: Libraries = ['places', 'geometry'];

interface MarketStand {
  id: string;
  name: string;
  locationName: string;
  latitude: number;
  longitude: number;
  distance?: number;
  tags: string[];
}

interface MarketStandsMapProps {
  marketStands: MarketStand[];
  userLocation?: { lat: number; lng: number } | null;
}

const containerStyle = {
  width: '100%',
  height: '600px',
  borderRadius: '0.5rem'
};

export default function MarketStandsMap({ marketStands, userLocation }: MarketStandsMapProps) {
  const [selectedStand, setSelectedStand] = useState<MarketStand | null>(null);
  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS || '';

  const { isLoaded } = useJsApiLoader({
    id: 'google-map-script',
    googleMapsApiKey: apiKey,
    libraries
  });

  const onLoad = useCallback((map: google.maps.Map) => {
    if (marketStands.length === 0) return;
    
    const bounds = new google.maps.LatLngBounds();
    marketStands.forEach(stand => {
      bounds.extend({ lat: stand.latitude, lng: stand.longitude });
    });
    if (userLocation) {
      bounds.extend({ lat: userLocation.lat, lng: userLocation.lng });
    }
    map.fitBounds(bounds);
  }, [marketStands, userLocation]);

  const center = useMemo(() => {
    if (marketStands.length === 0) {
      return { lat: 0, lng: 0 };
    }
    return userLocation
      ? { lat: userLocation.lat, lng: userLocation.lng }
      : { lat: marketStands[0].latitude, lng: marketStands[0].longitude };
  }, [marketStands, userLocation]);

  if (!isLoaded) {
    return (
      <div className="w-full h-[600px] rounded-lg border flex items-center justify-center">
        Loading map...
      </div>
    );
  }

  if (marketStands.length === 0) {
    return (
      <div className="w-full h-[600px] rounded-lg border flex items-center justify-center">
        No market stands available
      </div>
    );
  }

  return (
    <div className="grid lg:grid-cols-[1fr,300px] gap-4">
      <GoogleMap
        mapContainerStyle={containerStyle}
        center={center}
        zoom={10}
        onLoad={onLoad}
        options={{
          styles: [
            {
              featureType: 'poi',
              elementType: 'labels',
              stylers: [{ visibility: 'off' }]
            }
          ]
        }}
      >
        {/* User location marker */}
        {userLocation && (
          <Marker
            position={{ lat: userLocation.lat, lng: userLocation.lng }}
            icon={{
              path: google.maps.SymbolPath.CIRCLE,
              scale: 7,
              fillColor: '#4F46E5',
              fillOpacity: 1,
              strokeWeight: 2,
              strokeColor: '#ffffff',
            }}
          />
        )}

        {/* Market stand markers */}
        {marketStands.map(stand => (
          <Marker
            key={stand.id}
            position={{ lat: stand.latitude, lng: stand.longitude }}
            onClick={() => setSelectedStand(stand)}
          />
        ))}

        {/* Info window for selected stand */}
        {selectedStand && (
          <InfoWindow
            position={{ lat: selectedStand.latitude, lng: selectedStand.longitude }}
            onCloseClick={() => setSelectedStand(null)}
          >
            <div className="p-2">
              <h3 className="font-medium mb-1">{selectedStand.name}</h3>
              <p className="text-sm text-gray-600 mb-2">{selectedStand.locationName}</p>
              {selectedStand.distance !== undefined && (
                <p className="text-sm text-primary mb-2">
                  {selectedStand.distance.toFixed(1)} km away
                </p>
              )}
              {selectedStand.tags && selectedStand.tags.length > 0 && (
                <div className="flex flex-wrap gap-1 mb-2">
                  {selectedStand.tags.map((tag, index) => (
                    <div
                      key={index}
                      className="bg-secondary px-2 py-0.5 rounded-md text-xs"
                    >
                      {tag}
                    </div>
                  ))}
                </div>
              )}
              <Link
                href={`/market-stand/${selectedStand.id}`}
                className="text-sm text-primary hover:underline"
              >
                View Details
              </Link>
            </div>
          </InfoWindow>
        )}
      </GoogleMap>

      <div className="bg-white rounded-lg p-4 shadow-sm h-[600px] overflow-y-auto">
        <h3 className="font-semibold text-lg mb-4">Market Stands</h3>
        <div className="space-y-3">
          {marketStands.map(stand => (
            <Link
              key={stand.id}
              href={`/market-stand/${stand.id}`}
              className="block p-3 rounded-md hover:bg-gray-50 transition-colors"
              onClick={() => setSelectedStand(stand)}
            >
              <h4 className="font-medium">{stand.name}</h4>
              <p className="text-sm text-muted-foreground">{stand.locationName}</p>
              {stand.distance !== undefined && (
                <p className="text-sm text-primary mt-1">
                  {stand.distance.toFixed(1)} km away
                </p>
              )}
              {stand.tags && stand.tags.length > 0 && (
                <div className="flex flex-wrap gap-1 mt-2">
                  {stand.tags.map((tag, index) => (
                    <div
                      key={index}
                      className="bg-secondary px-2 py-0.5 rounded-md text-xs"
                    >
                      {tag}
                    </div>
                  ))}
                </div>
              )}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/MarketStandViewNav.tsx">
import { MapPin, Grid } from "lucide-react";
import { Button } from "./ui/button";
import Link from "next/link";

interface MarketStandViewNavProps {
  currentView: 'grid' | 'map';
}

export function MarketStandViewNav({ currentView }: MarketStandViewNavProps) {
  return (
    <div className="flex gap-4">
      <Link href="/market-stand/grid">
        <Button variant={currentView === 'grid' ? 'default' : 'outline'}>
          <Grid className="h-4 w-4 mr-2" />
          Grid View
        </Button>
      </Link>
      <Link href="/market-stand/map">
        <Button variant={currentView === 'map' ? 'default' : 'outline'}>
          <MapPin className="h-4 w-4 mr-2" />
          Map View
        </Button>
      </Link>
    </div>
  );
}
</file>

<file path="components/MobileMenu.tsx">
"use client";

import { Button } from "./ui/button";
import { Sheet, SheetContent, SheetTrigger, SheetClose } from "./ui/sheet";
import { Menu } from "lucide-react";
import { navbarLinks } from "./NavbarLinks";
import Link from "next/link";
import { cn } from "../lib/utils";
import { usePathname } from "next/navigation";

export function MobileMenu() {
  const location = usePathname();
  
  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button 
          variant="outline" 
          size="icon"
          aria-label="Open menu"
        >
          <Menu className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-72">
        <nav className="mt-6 flex flex-col gap-1">
          {navbarLinks.map((item) => (
            <SheetClose asChild key={item.id}>
              <Link
                href={item.href}
                className={cn(
                  "flex items-center px-4 py-2 text-sm font-medium rounded-md transition-colors",
                  location === item.href
                    ? "bg-primary text-primary-foreground"
                    : "text-muted-foreground hover:bg-muted hover:text-primary"
                )}
              >
                {item.name}
              </Link>
            </SheetClose>
          ))}
        </nav>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="components/Navbar.tsx">
"use client";

import Link from "next/link";
import { NavbarLinks } from "./NavbarLinks";
import { UserNav } from "./UserNav";
import Image from "next/image";

export function Navbar() {
  return (
    <nav className="border-b">
      <div className="flex h-16 items-center px-4 max-w-7xl mx-auto">
        <Link href="/" className="flex items-center">
          <div className="relative w-[180px] h-[45px]">
            <Image
            src="/logos/cornucopia.svg"
            alt="Cornucopia"
            fill
            priority
            className="block dark:hidden"
          />
          <Image
            src="/logos/cornucopia-dark.svg"
            alt="Cornucopia"
            fill
            priority
            className="hidden dark:block"
            />
          </div>
        </Link>

        <NavbarLinks />

        <div className="ml-auto flex items-center space-x-4">
          <UserNav />
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="components/NavbarLinks.tsx">
"use client";

import { cn } from "../lib/utils";
import Link from "next/link";
import { usePathname } from "next/navigation";

export const navbarLinks = [
  {
    id: 0,
    name: "Home",
    href: "/",
  },
  {
    id: 1,
    name: "Market Stands",
    href: "/market-stand",
  },
  {
    id: 2,
    name: "How it Works",
    href: "/how-it-works",
  },
  {
    id: 3,
    name: "Our Mission",
    href: "/our-mission",
  },
];

export function NavbarLinks() {
  const location = usePathname();

  return (
    <div className="flex justify-center items-center gap-x-6 ml-10">
      {navbarLinks.map((item) => (
        <Link
          href={item.href}
          key={item.id}
          className={cn(
            location === item.href
              ? "text-primary font-medium"
              : "text-muted-foreground hover:text-primary",
            "transition-colors"
          )}
        >
          {item.name}
        </Link>
      ))}
    </div>
  );
}
</file>

<file path="components/NewestProducts.tsx">
import Link from "next/link";
import prisma from "../lib/db";
import { ProductCard } from "./ProductCard";

async function getData() {
  const data = await prisma.product.findMany({
    select: {
      price: true,
      description: true,
      name: true,
      id: true,
      images: true,
      updatedAt: true,
      inventory: true,
      marketStand: {
        select: {
          id: true,
          locationName: true
        }
      }
    },
    take: 4,
    orderBy: {
      updatedAt: "desc",
    },
  });

  return data;
}

export async function NewestProducts() {
  const data = await getData();
  return (
    <section className="mt-12">
      <div className="md:flex md:items-center md:justify-between">
        <h2 className="text-2xl font-extrabold tracking-tighter ">
          Newest Products
        </h2>
        <Link
          href="#"
          className="text-sm hidden font-medium text-primary hover:text-primary/90 md:block"
        >
          All Products <span>&rarr;</span>
        </Link>
      </div>

      <div className="grid gird-cols-1 lg:grid-cols-3 sm:grid-cols-2 mt-4 gap-10">
        {data.map((product) => (
          <ProductCard
            images={product.images}
            key={product.id}
            id={product.id}
            name={product.name}
            locationName={product.marketStand.locationName}
            updatedAt={product.updatedAt}
            inventory={product.inventory}
            marketStandId={product.marketStand.id}
          />
        ))}
      </div>
    </section>
  );
}
</file>

<file path="components/PaymentTab.tsx">
import { Card } from "./ui/card";
import { Button } from "./ui/button";
import { QrCode, CreditCard } from "lucide-react";
import Link from "next/link";
import { MarketStandQR } from "./MarketStandQR";
import { StripeConnectButton } from "./StripeConnectButton";

interface PaymentTabProps {
  marketStands: {
    id: string;
    name: string;
  }[];
  stripeConnected: boolean;
}

export function PaymentTab({ marketStands, stripeConnected }: PaymentTabProps) {
  return (
    <div className="space-y-4">
      <Card className="p-6">
        <div className="flex flex-col items-center text-center">
          <div className="mb-6">
            <div className="inline-block p-3 bg-primary/10 rounded-full mb-4">
              <CreditCard className="w-6 h-6 text-primary" />
            </div>
            <h2 className="text-xl font-semibold">Payment Processing</h2>
            <p className="text-muted-foreground mt-2 mb-4 max-w-md">
              You can list products without connecting a Stripe account, but you&apos;ll need to connect one to receive payments from customers.
            </p>
            <p className="text-sm text-muted-foreground mb-6 max-w-md">
              When connected, Stripe provides secure payment processing and automatic transfers to your bank account.
            </p>
          </div>

          {stripeConnected ? (
            <div className="space-y-4 w-full max-w-md">
              <div className="bg-green-50 text-green-700 p-4 rounded-lg">
                <p className="font-medium">✓ Stripe account connected</p>
                <p className="text-sm mt-1">Your account is ready to receive payments</p>
              </div>
            </div>
          ) : (
            <div className="w-full max-w-md">
              <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg mb-6">
                <p className="font-medium">Optional Setup</p>
                <p className="text-sm mt-1">
                  You can list products now, but customers won&apos;t be able to make purchases until you connect a Stripe account.
                </p>
              </div>
              <StripeConnectButton />
              <p className="text-sm text-muted-foreground mt-4">
                You&apos;ll be redirected to Stripe to complete the account setup
              </p>
            </div>
          )}
        </div>
      </Card>

      <Card className="p-6">
        <div className="flex flex-col items-center text-center">
          <div className="mb-6">
            <div className="inline-block p-3 bg-primary/10 rounded-full mb-4">
              <QrCode className="w-6 h-6 text-primary" />
            </div>
            <h2 className="text-xl font-semibold">Market Stand QR Codes</h2>
            <p className="text-muted-foreground mt-2 mb-6 max-w-md">
              Display these QR codes at your market stands. When customers scan them, they&apos;ll be able to view your products and make purchases once you&apos;ve connected your Stripe account.
            </p>
          </div>

          {marketStands.length > 0 ? (
            <div className="space-y-8 w-full">
              {marketStands.map(stand => (
                <div key={stand.id} className="space-y-4">
                  <h3 className="font-medium">{stand.name}</h3>
                  <div className="flex flex-col items-center space-y-6">
                    <MarketStandQR marketStandId={stand.id} size={200} />
                    <div className="text-sm text-muted-foreground space-y-2">
                      <p>• Place this QR code where customers can easily scan it</p>
                      <p>• Customers need to scan this to make purchases</p>
                      <p>• The QR code helps verify product availability</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="bg-muted p-4 rounded-lg text-center">
              <p className="text-muted-foreground">
                Set up your market stand to get your QR code
              </p>
              <Button 
                variant="secondary" 
                size="sm"
                className="mt-4"
                asChild
                aria-label="Set up your market stand"
              >
                <Link href="/market-stand/setup">
                  Set Up Market Stand
                </Link>
              </Button>
            </div>
          )}
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="components/ProductCard.tsx">
'use client';

import { Skeleton } from "./ui/skeleton";
import Image from "next/image";
import Link from "next/link";
import { useEffect, useState } from "react";

interface iAppProps {
  images: string[];
  name: string;
  id: string;
  locationName: string;
  updatedAt: string;
  inventory?: number;
  marketStandId: string;
  isQRAccess?: boolean;
  price?: number;
  tags?: string[];
}

export function ProductCard({
  images,
  id,
  name,
  locationName,
  updatedAt,
  inventory,
  marketStandId,
  isQRAccess = false,
  price,
  tags = [],
}: iAppProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <Link 
      href={`/product/${encodeURIComponent(id)}${isQRAccess ? '?qr=true' : ''}`}
      className="block"
    >
      <div className="rounded-lg overflow-hidden shadow-md hover:shadow-lg transition-shadow">
        <div className="relative aspect-[4/3] w-full">
          <div className="absolute top-2 right-2 flex gap-2 z-10">
            <div className="bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm font-mono">
              {timeElapsed}
            </div>
            {typeof inventory === 'number' && (
              <div className="bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm">
                {inventory} left
              </div>
            )}
          </div>
          <Image
            alt={name}
            src={images[0]}
            fill
            className="object-cover rounded-t-lg"
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            priority={false}
            loading="lazy"
          />
        </div>
        <div className="p-3 bg-white">
          <div className="flex items-center justify-between">
            <h2 className="font-semibold text-lg">{name}</h2>
            {typeof price === 'number' && (
              <p className="font-medium text-primary">
                {(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
              </p>
            )}
          </div>
          <p className="text-gray-600 text-sm mt-1">{locationName}</p>
          {tags.length > 0 && (
            <div className="flex flex-wrap gap-2 mt-2">
              {tags.map((tag: string, index: number) => (
                <div
                  key={index}
                  className="bg-secondary px-2 py-1 rounded-md text-xs"
                >
                  {tag}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </Link>
  );
}

export function LoadingProductCard() {
  return (
    <div className="rounded-lg overflow-hidden shadow-md">
      <Skeleton className="w-full h-[200px]" />
      <div className="p-3">
        <Skeleton className="h-6 w-3/4 mb-2" />
        <Skeleton className="h-4 w-1/2" />
      </div>
    </div>
  );
}
</file>

<file path="components/ProductDashboardCard.tsx">
'use client';

import { useState } from "react";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Loader2, Pencil } from "lucide-react";
import Image from "next/image";
import Link from "next/link";

interface ProductDashboardCardProps {
  id: string;
  name: string;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: Date | null;
}

export function ProductDashboardCard({ id, name, images, inventory, inventoryUpdatedAt }: ProductDashboardCardProps) {
  const [currentInventory, setCurrentInventory] = useState(inventory);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const handleUpdate = async () => {
    try {
      setIsLoading(true);
      setError("");

      const response = await fetch(`/api/product`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          id,
          inventory: currentInventory,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update inventory");
      }

      // Refresh the page to show updated data
      window.location.reload();
    } catch (error) {
      console.error("Error updating inventory:", error);
      setError("Failed to update inventory");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="rounded-lg overflow-hidden border bg-card text-card-foreground shadow-sm">
      <div className="relative h-[200px]">
        <Image
          alt={`Product image for ${name}`}
          src={images[0]}
          fill
          className="object-cover"
          priority
          sizes="(max-width: 768px) 100vw, 300px"
        />
      </div>
      <div className="p-4">
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-semibold">{name}</h3>
          <Link href={`/dashboard/edit-product/${id}`}>
            <Button 
              variant="ghost" 
              size="icon"
              aria-label={`Edit ${name}`}
              title={`Edit ${name}`}
            >
              <Pencil className="h-4 w-4" />
            </Button>
          </Link>
        </div>

        <div className="space-y-4">
          <div className="flex items-center justify-between text-sm text-muted-foreground">
            <span>Current Inventory:</span>
            <span>{inventory} units</span>
          </div>

          {inventoryUpdatedAt && (
            <div className="text-xs text-muted-foreground">
              Last updated: {new Intl.DateTimeFormat("en-US", {
                dateStyle: "medium",
                timeStyle: "short",
              }).format(new Date(inventoryUpdatedAt))}
            </div>
          )}

          <div className="flex items-center gap-2">
            <Input
              id={`inventory-${id}`}
              type="number"
              min="0"
              value={currentInventory}
              onChange={(e) => setCurrentInventory(Number(e.target.value))}
              className="w-24"
              aria-label={`Update inventory for ${name}`}
              aria-describedby={error ? `error-${id}` : undefined}
            />
            <Button 
              onClick={handleUpdate} 
              disabled={isLoading || currentInventory === inventory}
              size="sm"
              aria-label={isLoading ? "Updating inventory..." : "Update inventory"}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  <span>Updating...</span>
                </>
              ) : (
                "Update"
              )}
            </Button>
          </div>
          {error && (
            <p 
              id={`error-${id}`}
              className="text-sm font-medium text-destructive mt-1.5"
            >
              {error}
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ProductDescription.tsx">
"use client";

import { type JSONContent, useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";

export function ProductDescription({ content }: { content: JSONContent }) {
const editor = useEditor({
  editable: false,
  extensions: [StarterKit],
  content: content,
  editorProps: {
    attributes: {
      class: "prose prose-sm sm:prose-base",
    },
  },
  immediatelyRender: false,
});

  if (!editor) {
    return null;
  }

  return (
    <>
      <EditorContent editor={editor} />
    </>
  );
}
</file>

<file path="components/ProductEmail.tsx">
import {
  Body,
  Button,
  Container,
  Head,
  Html,
  Preview,
  Section,
  Tailwind,
  Text,
} from "@react-email/components";

export default function ProductEmail({ link }: { link: string }) {
  return (
    <Html>
      <Head />
      <Preview>Your product is here...</Preview>
      <Tailwind>
        <Body className="bg-white font-sans">
          <Container style={container}>
            <Text className="text-2xl font-semibold">Hi Friend,</Text>
            <Text className="text-lg text-gray-600">
              Thank you for buying your product at MarshalUI
            </Text>
            <Section className="w-full flex justify-center mt-7">
              <Button
                href={link}
                className="text-white bg-blue-500 rounded-lg px-10 py-4"
              >
                Your Download Link
              </Button>
            </Section>
            <Text className="text-lg">
              Best, <br /> MarshalUI Team
            </Text>
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
}

const container = {
  margin: "0 auto",
  padding: "20px 0 48px",
};
</file>

<file path="components/ProductRow.tsx">
import { LoadingProductCard, ProductCard } from "./ProductCard";
import Link from "next/link";
import { Suspense } from "react";
import { cache } from 'react';
import { Skeleton } from "./ui/skeleton";
import prisma from "../lib/db";
import type { Product, MarketStand } from "@prisma/client";

interface SerializedProduct {
  id: string;
  name: string;
  images: string[];
  updatedAt: string;
  price: number;
  tags: string[];
  locationName: string;
  distance?: number;
  marketStand: {
    id: string;
    name: string;
    latitude: number;
    longitude: number;
  };
}

interface ProductRowProps {
  title: string;
  link: string;
  userLocation?: { lat: number; lng: number } | null;
}


function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

const getData = cache(async ({ userLocation }: { userLocation?: { lat: number; lng: number } | null }) => {
  try {
    const products = await prisma.product.findMany({
      select: {
        name: true,
        id: true,
        images: true,
        updatedAt: true,
        price: true,
        tags: true,
        marketStand: {
          select: {
            id: true,
            name: true,
            latitude: true,
            longitude: true,
          }
        }
      },
      take: 6,
      orderBy: {
        updatedAt: 'desc'
      }
    });

    // Serialize dates and transform data
    const serializedProducts = products.map(product => ({
      ...product,
      updatedAt: product.updatedAt.toISOString(),
      locationName: product.marketStand?.name || 'Unknown Location',
      distance: userLocation && userLocation.lat && userLocation.lng && product.marketStand
        ? calculateDistance(
            userLocation.lat,
            userLocation.lng,
            product.marketStand.latitude,
            product.marketStand.longitude
          )
        : undefined
    }));

    return serializedProducts;
  } catch (error) {
    console.error('Error fetching products:', error);
    return [];
  }
});

export function ProductRow({ title, link, userLocation }: ProductRowProps) {
  return (
    <section className="mt-12">
      <Suspense fallback={<LoadingState />}>
        <LoadRows title={title} link={link} userLocation={userLocation} />
      </Suspense>
    </section>
  );
}

async function LoadRows({ title, link, userLocation }: ProductRowProps) {
  const data = await getData({ userLocation });
  return (
    <>
      <div className="md:flex md:items-center md:justify-between">
        <h2 className="text-2xl font-extrabold tracking-tighter">
          {title}
        </h2>
        <Link
          href={link}
          className="text-sm hidden font-medium text-primary hover:text-primary/90 md:block"
        >
          All Products <span>&rarr;</span>
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 mt-4 gap-10">
        {data.map((product: SerializedProduct) => (
          <ProductCard
            key={product.id}
            images={product.images}
            id={product.id}
            name={product.name}
            locationName={product.locationName}
            updatedAt={product.updatedAt}
            marketStandId={product.marketStand.id}
            price={product.price}
            tags={product.tags}
          />
        ))}
      </div>
    </>
  );
}

function LoadingState() {
  return (
    <div>
      <Skeleton className="h-8 w-56" />
      <div className="grid grid-cols-1 sm:grid-cols-2 mt-4 gap-10 lg:grid-cols-3">
        <LoadingProductCard />
        <LoadingProductCard />
        <LoadingProductCard />
      </div>
    </div>
  );
}
</file>

<file path="components/ProductTimer.tsx">
'use client';

import { useEffect, useState } from 'react';

interface ProductTimerProps {
  updatedAt: Date;
  size?: 'small' | 'normal';
}

export function ProductTimer({ updatedAt, size = 'normal' }: ProductTimerProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <div className={`absolute top-0 left-0 bg-black/60 text-white rounded-br-md font-mono
      ${size === 'small' ? 'px-2 py-1 text-xs' : 'px-3 py-1.5 text-sm'}`}>
      {timeElapsed}
    </div>
  );
}
</file>

<file path="components/StripeConnectButton.tsx">
"use client";

import { Button } from "./ui/button";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";

export function StripeConnectButton() {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleConnect = async () => {
    try {
      setLoading(true);
      const response = await fetch("/api/stripe/connect", {
        method: "POST",
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || `HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.url) {
        router.push(data.url);
      } else {
        throw new Error("No redirect URL received from Stripe");
      }
    } catch (error) {
      console.error("Failed to connect Stripe account:", error);
      toast.error(
        error instanceof Error 
          ? error.message 
          : "Failed to connect Stripe account. Please try again."
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button 
      onClick={handleConnect}
      disabled={loading}
      className="w-full relative"
      aria-label="Connect Stripe account for payments"
    >
      {loading ? (
        <>
          <span className="opacity-0">Connect Stripe Account</span>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="h-4 w-4 border-2 border-current border-r-transparent animate-spin rounded-full" />
          </div>
        </>
      ) : (
        "Connect Stripe Account"
      )}
    </Button>
  );
}
</file>

<file path="components/SubmitButtons.tsx">
"use client";

import { Button } from "./ui/button";
import { Loader2 } from "lucide-react";
import { useFormStatus } from "react-dom";

export function Submitbutton({ title, disabled }: { title: string; disabled?: boolean }) {
  const { pending } = useFormStatus();

  return (
    <>
      {pending || disabled ? (
        <Button 
          disabled={true}
          aria-label="Form submission in progress"
          className="min-w-[100px]"
        >
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Submitting...
        </Button>
      ) : (
        <Button 
          type="submit"
          aria-label={title}
          className="min-w-[100px]"
        >
          {title}
        </Button>
      )}
    </>
  );
}

export function BuyButton({ price }: { price: number }) {
  const { pending } = useFormStatus();

  return (
    <>
      {pending ? (
        <Button 
          disabled 
          size="lg" 
          className="w-full mt-10"
          aria-label="Purchase in progress"
        >
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Processing...
        </Button>
      ) : (
        <Button 
          type="submit" 
          size="lg" 
          className="w-full mt-10"
          aria-label={`Buy for ${(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`}
        >
          Buy for {(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
        </Button>
      )}
    </>
  );
}
</file>

<file path="components/UserNav.tsx">
"use client";

import { useSupabase } from "./providers/SupabaseProvider";
import { useState } from "react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Button } from "./ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "./ui/avatar";
import { AuthDialog } from "./AuthDialog";
import { getSupabaseBrowser } from "@/lib/supabase-browser";

export function UserNav() {
  const { user, isLoading } = useSupabase();
  const [isAuthenticating, setIsAuthenticating] = useState(false);


  const handleLogout = async () => {
    try {
      setIsAuthenticating(true);
      const supabase = getSupabaseBrowser();
      await supabase.auth.signOut();
      console.log('[Auth] Logout successful, redirecting to home');
      window.location.href = window.location.origin;
    } catch (error) {
      console.error('[Auth] Logout error:', error);
    } finally {
      setIsAuthenticating(false);
    }
  };

  const navigate = (path: string) => {
    console.log(`Navigating to: ${path}`);
    console.log('Current pathname:', window.location.pathname);
    console.log('User state:', user);
    const fullUrl = `${window.location.origin}${path}`;
    console.log('Full URL:', fullUrl);
    window.location.href = fullUrl;
  };

  if (isLoading || isAuthenticating) {
    return (
      <Button variant="ghost" size="sm" className="relative h-8 w-8">
        <Avatar>
          <AvatarFallback className="animate-pulse">...</AvatarFallback>
        </Avatar>
      </Button>
    );
  }

  if (!user) {
    return (
      <div className="flex items-center gap-4">
        <AuthDialog mode="login" />
        <AuthDialog 
          mode="signup" 
          trigger={
            <Button size="sm" disabled={isAuthenticating}>
              Sign Up
            </Button>
          }
        />
      </div>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="relative h-8 w-8">
          <Avatar>
            <AvatarImage
              src={user?.user_metadata?.avatar_url || ''}
              alt={user?.user_metadata?.given_name || 'User'}
            />
            <AvatarFallback>{user?.user_metadata?.given_name?.[0] || 'U'}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">{user?.user_metadata?.given_name || 'User'}</p>
            <p className="text-xs leading-none text-muted-foreground">
              {user?.email || ''}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/sell')}
        >
          Sell My Products
        </DropdownMenuItem>
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/dashboard/market-stand')}
        >
          Dashboard
        </DropdownMenuItem>
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/settings')}
        >
          Settings
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          className="cursor-pointer text-destructive focus:text-destructive"
          onClick={handleLogout}
          disabled={isAuthenticating}
        >
          Logout
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="lib/auth.ts">
import { cookies } from 'next/headers';
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';

export const createServerSupabaseClient = () =>
  createServerComponentClient({
    cookies,
  });

export const getUser = async () => {
  const supabase = createServerSupabaseClient();
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error) {
    console.error('Error fetching user:', error);
    return null;
  }

  // Serialize user data to handle any non-serializable objects
  return user ? JSON.parse(JSON.stringify(user)) : null;
};
</file>

<file path="lib/db.ts">
import { PrismaClient } from "@prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

const prismaClientSingleton = () => {
  return new PrismaClient({
    log: ['query', 'error', 'warn'],
  });
};

// PrismaClient is attached to the `global` object in development to prevent
// exhausting your database connection limit.
const prisma = global.prisma ?? prismaClientSingleton();

process.on('beforeExit', async () => {
  await prisma.$disconnect();
});

if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

export default prisma;
</file>

<file path="lib/stripe.ts">
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY is not set in environment variables");
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2023-10-16", // API version for Stripe v15.12.0
  typescript: true,
});
</file>

<file path="lib/supabase-browser.ts">
'use client';

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';

// Singleton instance for client-side
let clientInstance: ReturnType<typeof createClientComponentClient> | null = null;

export function getSupabaseBrowser() {
  if (!clientInstance) {
    clientInstance = createClientComponentClient();
  }
  return clientInstance;
}

// Helper function for uploading images
export async function uploadImage(
  file: File,
  bucket: string = 'images',
  path: string = ''
): Promise<string> {
  try {
    const supabase = getSupabaseBrowser();
    
    // Check if user is authenticated
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      throw new Error('Authentication required for image upload');
    }

    console.log(`Starting upload for file: ${file.name} to bucket: ${bucket}`);
    const fileName = `${path}${Date.now()}-${file.name}`;
    console.log(`Generated filename: ${fileName}`);

    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(fileName, file, {
        cacheControl: '3600',
        upsert: false,
      });

    if (error) {
      console.error('Upload error:', error);
      throw error;
    }

    console.log('Upload successful, data:', data);
    console.log('Getting public URL for path:', data.path);

    const { data: urlData } = await supabase.storage
      .from(bucket)
      .getPublicUrl(data.path);

    if (!urlData.publicUrl) {
      console.error('Failed to get public URL, urlData:', urlData);
      throw new Error('Failed to get public URL');
    }

    console.log('Successfully generated public URL:', urlData.publicUrl);
    return urlData.publicUrl;
  } catch (error) {
    console.error('Error in uploadImage:', error);
    throw error;
  }
}

// Helper function for deleting images
export async function deleteImage(
  url: string,
  bucket: string = 'images'
): Promise<void> {
  const supabase = getSupabaseBrowser();
  
  // Extract file path from URL
  const path = url.split(`${bucket}/`)[1];
  if (!path) throw new Error('Invalid image URL');

  const { error } = await supabase.storage
    .from(bucket)
    .remove([path]);

  if (error) {
    throw error;
  }
}

// Helper function for uploading multiple images
export async function uploadImages(
  files: File[],
  bucket: string = 'images',
  path: string = ''
): Promise<string[]> {
  const uploadPromises = files.map(file => uploadImage(file, bucket, path));
  return Promise.all(uploadPromises);
}
</file>

<file path="lib/supabase-server.ts">
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { cache } from 'react';

// Singleton instance for server-side
export const getSupabaseServer = cache(() => {
  const cookieStore = cookies();
  return createServerComponentClient({ cookies: () => cookieStore });
});
</file>

<file path="lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="prisma/migrations/20241229030000_add_location_details/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "profileImage" TEXT NOT NULL,
    "connectedAccountId" TEXT,
    "stripeConnectedLinked" BOOLEAN NOT NULL DEFAULT false,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "price" INTEGER NOT NULL,
    "description" TEXT NOT NULL,
    "images" TEXT[],
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MarketStand" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "images" TEXT[],
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,
    "locationName" TEXT NOT NULL,
    "locationGuide" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" TEXT NOT NULL,

    CONSTRAINT "MarketStand_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_id_key" ON "User"("id");

-- CreateIndex
CREATE UNIQUE INDEX "MarketStand_userId_key" ON "MarketStand"("userId");

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "MarketStand" ADD CONSTRAINT "MarketStand_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20241229164310_add_product_inventory_and_timestamp/migration.sql">
/*
  Warnings:

  - Added the required column `updatedAt` to the `Product` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "Product" ADD COLUMN     "inventory" INTEGER NOT NULL DEFAULT 0,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL;
</file>

<file path="prisma/migrations/20241229184041_add_inventory_timestamp/migration.sql">
-- AlterTable
ALTER TABLE "Product" ADD COLUMN     "inventoryUpdatedAt" TIMESTAMP(3);
</file>

<file path="prisma/migrations/20250115020106_add_tags_to_models/migration.sql">
/*
  Warnings:

  - Added the required column `updatedAt` to the `MarketStand` table without a default value. This is not possible if the table is not empty.

*/
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');

-- CreateEnum
CREATE TYPE "Status" AS ENUM ('PENDING', 'APPROVED', 'REJECTED', 'SUSPENDED');

-- DropIndex
DROP INDEX "MarketStand_userId_key";

-- AlterTable
ALTER TABLE "MarketStand" ADD COLUMN     "averageRating" DOUBLE PRECISION,
ADD COLUMN     "isActive" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "status" "Status" NOT NULL DEFAULT 'PENDING',
ADD COLUMN     "tags" TEXT[],
ADD COLUMN     "totalReviews" INTEGER NOT NULL DEFAULT 0,
ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL;

-- AlterTable
ALTER TABLE "Product" ADD COLUMN     "averageRating" DOUBLE PRECISION,
ADD COLUMN     "isActive" BOOLEAN NOT NULL DEFAULT true,
ADD COLUMN     "status" "Status" NOT NULL DEFAULT 'PENDING',
ADD COLUMN     "tags" TEXT[],
ADD COLUMN     "totalReviews" INTEGER NOT NULL DEFAULT 0;

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" "UserRole" NOT NULL DEFAULT 'USER';

-- CreateTable
CREATE TABLE "ProductReview" (
    "id" TEXT NOT NULL,
    "rating" INTEGER NOT NULL,
    "comment" TEXT NOT NULL,
    "images" TEXT[],
    "isVerifiedPurchase" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "productId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "helpfulVotes" INTEGER NOT NULL DEFAULT 0,
    "reportCount" INTEGER NOT NULL DEFAULT 0,
    "isVisible" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "ProductReview_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandReview" (
    "id" TEXT NOT NULL,
    "rating" INTEGER NOT NULL,
    "comment" TEXT NOT NULL,
    "images" TEXT[],
    "isVerifiedCustomer" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "helpfulVotes" INTEGER NOT NULL DEFAULT 0,
    "reportCount" INTEGER NOT NULL DEFAULT 0,
    "isVisible" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "StandReview_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductStatusHistory" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "oldStatus" "Status" NOT NULL,
    "newStatus" "Status" NOT NULL,
    "changedById" TEXT NOT NULL,
    "note" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ProductStatusHistory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandStatusHistory" (
    "id" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "oldStatus" "Status" NOT NULL,
    "newStatus" "Status" NOT NULL,
    "changedById" TEXT NOT NULL,
    "note" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "StandStatusHistory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductMetrics" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "addedToCart" INTEGER NOT NULL DEFAULT 0,
    "purchases" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,
    "conversionRate" DOUBLE PRECISION,

    CONSTRAINT "ProductMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductDailyMetrics" (
    "id" TEXT NOT NULL,
    "productMetricId" TEXT NOT NULL,
    "date" TIMESTAMP(3) NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "addedToCart" INTEGER NOT NULL DEFAULT 0,
    "purchases" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "ProductDailyMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandMetrics" (
    "id" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "totalViews" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "totalOrders" INTEGER NOT NULL DEFAULT 0,
    "totalRevenue" INTEGER NOT NULL DEFAULT 0,
    "averageOrderValue" DOUBLE PRECISION,
    "returningCustomers" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "StandMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandDailyMetrics" (
    "id" TEXT NOT NULL,
    "standMetricId" TEXT NOT NULL,
    "date" TIMESTAMP(3) NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "orders" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "StandDailyMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserEngagement" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "lastVisit" TIMESTAMP(3) NOT NULL,
    "totalVisits" INTEGER NOT NULL DEFAULT 0,
    "totalPurchases" INTEGER NOT NULL DEFAULT 0,
    "totalSpent" INTEGER NOT NULL DEFAULT 0,
    "favoriteStands" TEXT[],
    "searchHistory" TEXT[],
    "categoryViews" JSONB NOT NULL,

    CONSTRAINT "UserEngagement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VisitorSession" (
    "id" TEXT NOT NULL,
    "sessionId" TEXT NOT NULL,
    "userId" TEXT,
    "startTime" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "endTime" TIMESTAMP(3),
    "deviceType" TEXT,
    "browser" TEXT,
    "ipAddress" TEXT,
    "pagesViewed" JSONB NOT NULL,

    CONSTRAINT "VisitorSession_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "ProductMetrics_productId_key" ON "ProductMetrics"("productId");

-- CreateIndex
CREATE UNIQUE INDEX "StandMetrics_marketStandId_key" ON "StandMetrics"("marketStandId");

-- CreateIndex
CREATE UNIQUE INDEX "UserEngagement_userId_key" ON "UserEngagement"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "VisitorSession_sessionId_key" ON "VisitorSession"("sessionId");

-- AddForeignKey
ALTER TABLE "ProductReview" ADD CONSTRAINT "ProductReview_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductReview" ADD CONSTRAINT "ProductReview_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandReview" ADD CONSTRAINT "StandReview_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandReview" ADD CONSTRAINT "StandReview_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductStatusHistory" ADD CONSTRAINT "ProductStatusHistory_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductStatusHistory" ADD CONSTRAINT "ProductStatusHistory_changedById_fkey" FOREIGN KEY ("changedById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandStatusHistory" ADD CONSTRAINT "StandStatusHistory_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandStatusHistory" ADD CONSTRAINT "StandStatusHistory_changedById_fkey" FOREIGN KEY ("changedById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductMetrics" ADD CONSTRAINT "ProductMetrics_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductDailyMetrics" ADD CONSTRAINT "ProductDailyMetrics_productMetricId_fkey" FOREIGN KEY ("productMetricId") REFERENCES "ProductMetrics"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandMetrics" ADD CONSTRAINT "StandMetrics_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandDailyMetrics" ADD CONSTRAINT "StandDailyMetrics_standMetricId_fkey" FOREIGN KEY ("standMetricId") REFERENCES "StandMetrics"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserEngagement" ADD CONSTRAINT "UserEngagement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "VisitorSession" ADD CONSTRAINT "VisitorSession_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum Status {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

model User {
  id                    String                @id @unique
  email                 String
  firstName             String
  lastName              String
  profileImage          String
  connectedAccountId    String?
  stripeConnectedLinked Boolean               @default(false)
  role                  UserRole              @default(USER)
  products              Product[]
  marketStands          MarketStand[]
  productStatusChanges  ProductStatusHistory[]
  standStatusChanges    StandStatusHistory[]
  productReviews        ProductReview[]
  standReviews          StandReview[]
  engagement           UserEngagement?
  sessions             VisitorSession[]      
}

model MarketStand {
  id              String               @id @default(uuid())
  name            String
  description     String?
  images          String[]
  tags            String[]
  latitude        Float
  longitude       Float
  locationName    String
  locationGuide   String
  status          Status               @default(PENDING)
  isActive        Boolean              @default(true)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  userId          String
  user            User                 @relation(fields: [userId], references: [id])
  products        Product[]            @relation("ProductToMarketStand")
  statusHistory   StandStatusHistory[]
  reviews         StandReview[]
  averageRating   Float?
  totalReviews    Int                  @default(0)
  metrics         StandMetrics?
}

model Product {
  id                String                @id @default(uuid())
  name              String
  price             Int
  description       String
  images            String[]
  tags              String[]
  inventory         Int                   @default(0)
  inventoryUpdatedAt DateTime?
  status            Status                @default(PENDING)
  isActive          Boolean               @default(true)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  userId            String
  user              User                  @relation(fields: [userId], references: [id])
  marketStand       MarketStand          @relation("ProductToMarketStand", fields: [marketStandId], references: [id])
  marketStandId     String
  statusHistory     ProductStatusHistory[]
  reviews           ProductReview[]
  averageRating     Float?
  totalReviews      Int                  @default(0)
  metrics           ProductMetrics?
}

model ProductReview {
  id                 String    @id @default(uuid())
  rating             Int
  comment            String
  images             String[]
  isVerifiedPurchase Boolean   @default(false)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  productId          String
  product            Product   @relation(fields: [productId], references: [id])
  userId             String
  user               User      @relation(fields: [userId], references: [id])
  helpfulVotes       Int       @default(0)
  reportCount        Int       @default(0)
  isVisible          Boolean   @default(true)
}

model StandReview {
  id                 String      @id @default(uuid())
  rating             Int
  comment            String
  images             String[]
  isVerifiedCustomer Boolean     @default(false)
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  marketStandId      String
  marketStand        MarketStand @relation(fields: [marketStandId], references: [id])
  userId             String
  user               User        @relation(fields: [userId], references: [id])
  helpfulVotes       Int         @default(0)
  reportCount        Int         @default(0)
  isVisible          Boolean     @default(true)
}

model ProductStatusHistory {
  id          String    @id @default(uuid())
  productId   String
  product     Product   @relation(fields: [productId], references: [id])
  oldStatus   Status
  newStatus   Status
  changedById String
  changedBy   User      @relation(fields: [changedById], references: [id])
  note        String
  createdAt   DateTime  @default(now())
}

model StandStatusHistory {
  id            String      @id @default(uuid())
  marketStandId String
  marketStand   MarketStand @relation(fields: [marketStandId], references: [id])
  oldStatus     Status
  newStatus     Status
  changedById   String
  changedBy     User        @relation(fields: [changedById], references: [id])
  note          String
  createdAt     DateTime    @default(now())
}

model ProductMetrics {
  id              String    @id @default(uuid())
  productId       String    @unique
  product         Product   @relation(fields: [productId], references: [id])
  views           Int       @default(0)
  uniqueViews     Int       @default(0)
  addedToCart     Int       @default(0)
  purchases       Int       @default(0)
  revenue         Int       @default(0)
  conversionRate  Float?
  dailyMetrics    ProductDailyMetrics[]
}

model ProductDailyMetrics {
  id              String         @id @default(uuid())
  productMetricId String
  productMetrics  ProductMetrics @relation(fields: [productMetricId], references: [id])
  date            DateTime
  views           Int           @default(0)
  uniqueViews     Int           @default(0)
  addedToCart     Int           @default(0)
  purchases       Int           @default(0)
  revenue         Int           @default(0)
}

model StandMetrics {
  id                String    @id @default(uuid())
  marketStandId     String    @unique
  marketStand       MarketStand @relation(fields: [marketStandId], references: [id])
  totalViews        Int       @default(0)
  uniqueViews       Int       @default(0)
  totalOrders       Int       @default(0)
  totalRevenue      Int       @default(0)
  averageOrderValue Float?
  returningCustomers Int      @default(0)
  dailyMetrics      StandDailyMetrics[]
}

model StandDailyMetrics {
  id              String       @id @default(uuid())
  standMetricId   String
  standMetrics    StandMetrics @relation(fields: [standMetricId], references: [id])
  date            DateTime
  views           Int         @default(0)
  uniqueViews     Int         @default(0)
  orders          Int         @default(0)
  revenue         Int         @default(0)
}

model UserEngagement {
  id              String    @id @default(uuid())
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id])
  lastVisit       DateTime
  totalVisits     Int       @default(0)
  totalPurchases  Int       @default(0)
  totalSpent      Int       @default(0)
  favoriteStands  String[]
  searchHistory   String[]
  categoryViews   Json
}

model VisitorSession {
  id           String    @id @default(uuid())
  sessionId    String    @unique
  userId       String?
  user         User?     @relation(fields: [userId], references: [id])
  startTime    DateTime  @default(now())
  endTime      DateTime?
  deviceType   String?
  browser      String?
  ipAddress    String?
  pagesViewed  Json
}
</file>

<file path="public/logos/cornucopia-dark.svg">
<svg width="400" height="100" viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Wave line -->
  <path 
    d="M20 40 Q100 40, 150 20, 200 30, 250 20, 300 30, 350 20, 380 30" 
    stroke="#ffffff" 
    stroke-width="8" 
    stroke-linecap="round"
    fill="none"
  />
  
  <!-- Text with better positioning -->
  <text 
    x="20" 
    y="85" 
    font-family="Arial" 
    font-size="48" 
    font-weight="bold" 
    fill="#ffffff"
    letter-spacing="2"
  >
    CORNUCOPIA
  </text>
</svg>
</file>

<file path="public/logos/cornucopia.svg">
<svg width="400" height="100" viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Wave line -->
  <path 
    d="M20 40 Q100 40, 150 20, 200 30, 250 20, 300 30, 350 20, 380 30" 
    stroke="#2E7D32" 
    stroke-width="8" 
    stroke-linecap="round"
    fill="none"
  />
  
  <!-- Text with better positioning -->
  <text 
    x="20" 
    y="85" 
    font-family="Arial" 
    font-size="48" 
    font-weight="bold" 
    fill="#2E7D32"
    letter-spacing="2"
  >
    CORNUCOPIA
  </text>
</svg>
</file>

<file path="public/logos/icon-svg.svg">
<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.89349 14.151C7.65331 19.6769 13.6542 22.7594 19.2968 21.036C24.9394 19.3126 38.304 10.3154 36.5442 4.78952C34.7843 -0.736348 18.5666 -0.698355 12.9239 1.02505C7.28131 2.74845 4.13367 8.62514 5.89349 14.151Z" fill="#2563EB"/>
<path d="M2.48395 44.4517C5.79589 47.6951 11.165 47.6951 14.477 44.4517C17.7889 41.2083 23.7851 30.0776 20.4737 26.8342C17.1618 23.591 5.79589 29.4634 2.48395 32.7066C-0.827984 35.95 -0.827984 41.2083 2.48395 44.4517Z" fill="#2563EB"/>
<path d="M34.175 47.6401C39.8844 49.1381 45.7529 45.8202 47.2829 40.229C48.8123 34.6378 48.1945 18.7673 42.4851 17.269C36.7757 15.771 28.1376 29.2126 26.6076 34.8038C25.0777 40.3948 28.4657 46.1418 34.175 47.6401Z" fill="#2563EB"/>
</svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="types/product.ts">
export interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
  marketStandId: string;
}

export interface ExtendedProduct extends Product {
  distance?: number;
  user?: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    profileImage: string;
  };
  marketStand?: {
    id: string;
    name: string;
    latitude: number;
    longitude: number;
    locationName: string;
  };
}
</file>

<file path=".eslintrc.json">
{
  "extends": ["next/core-web-vitals"],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "warn",
    "@typescript-eslint/no-explicit-any": "warn",
    "react/no-unescaped-entities": "off"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

#AI Context
ClineContext.txt
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
</file>

<file path="middleware.ts">
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

const protectedRoutes = [
  '/sell',
  '/settings',
  '/billing',
  '/product',
  '/dashboard/market-stand',
  '/dashboard/sell',
  '/dashboard/settings'
];

// Public routes that should never redirect
const publicRoutes = ['/', '/login', '/signup', '/auth-error'];

export async function middleware(request: NextRequest) {
  try {
    const response = NextResponse.next();
    const supabase = createMiddlewareClient({ req: request, res: response });

    // Get the current session
    console.log('[Middleware] Checking auth for path:', request.nextUrl.pathname);
    const {
      data: { session },
      error: sessionError
    } = await supabase.auth.getSession();
    
    if (sessionError) {
      console.error('[Middleware] Session error:', sessionError);
      return NextResponse.redirect(new URL('/auth-error', request.url));
    }
    
    // Serialize session state before logging or passing to response
    const serializedSession = session ? JSON.parse(JSON.stringify({
      hasSession: true,
      accessToken: session.access_token ? '(present)' : null,
      user: {
        id: session.user.id,
        email: session.user.email,
        role: session.user.role
      }
    })) : {
      hasSession: false,
      accessToken: null,
      user: null
    };
    
    console.log('[Middleware] Session state:', serializedSession);
    
    const pathname = request.nextUrl.pathname;

    // Handle /dashboard redirect
    if (pathname === '/dashboard') {
      if (!session) {
        console.log('[Middleware] No session, redirecting to home');
        return NextResponse.redirect(new URL('/', request.url));
      }
      console.log('[Middleware] Has session, redirecting to dashboard/market-stand');
      return NextResponse.redirect(new URL('/dashboard/market-stand', request.url));
    }

    // Check if the request is for a protected route
    const isProtectedRoute = protectedRoutes.some(route => 
      pathname.startsWith(route)
    );
    console.log('[Middleware] Route protection:', {
      path: pathname,
      isProtected: isProtectedRoute
    });

// Check if it's a public route
const isPublicRoute = publicRoutes.some(route => 
  pathname === route || pathname.startsWith(route)
);
console.log('[Middleware] Route access:', {
  path: pathname,
  isPublic: isPublicRoute
});

// Handle protected routes
if (isProtectedRoute) {
  if (!session) {
    console.log('[Middleware] Protected route access denied, redirecting to login');
    const returnUrl = encodeURIComponent(pathname);
    return NextResponse.redirect(new URL(`/?returnUrl=${returnUrl}`, request.url));
  }
  // User is authenticated, allow access to protected route
  return response;
}

// For public routes, continue
if (isPublicRoute) {
  return response;
}

// For all other routes, continue if authenticated
if (session) {
  return response;
}

// Redirect to home for unauthenticated users
return NextResponse.redirect(new URL('/', request.url));

  } catch (e) {
    console.error('Middleware error:', e);
    return NextResponse.redirect(new URL('/auth-error', request.url));
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public (public files)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|public).*)',
  ],
};
</file>

<file path="next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: ['@prisma/client'],
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'uploadthing.com',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'utfs.io',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'bzkj7i8mse.ufs.sh',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'fzlelklnibjzpgrquzrq.supabase.co',
        pathname: '/storage/v1/object/public/**',
      },
    ],
  },
}

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "digital-marketplace-yt",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate"
  },
  "dependencies": {
    "@hello-pangea/dnd": "^17.0.0",
    "@prisma/client": "^5.22.0",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@react-email/components": "0.0.17",
    "@react-google-maps/api": "^2.20.5",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/auth-helpers-react": "^0.5.0",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.12",
    "@tiptap/pm": "^2.3.2",
    "@tiptap/react": "^2.3.2",
    "@tiptap/starter-kit": "^2.3.2",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/lodash": "^4.17.13",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "embla-carousel-react": "^8.0.4",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "lucide-react": "^0.378.0",
    "next": "^14.2.22",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-qr-code": "^2.0.15",
    "resend": "^3.2.0",
    "sonner": "^1.4.41",
    "stripe": "^17.5.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/typography": "^0.5.15",
    "@types/google.maps": "^3.58.1",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.19.1",
    "@typescript-eslint/parser": "^8.19.1",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "^15.1.4",
    "postcss": "^8.4.49",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
  }
}
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";
import { withUt } from "uploadthing/tw";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography"),
    require("@tailwindcss/aspect-ratio"),
  ],
} satisfies Config;

export default withUt(config);
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/lib/*": ["lib/*"],
      "@/*": ["./*"],
      "@components/*": ["components/*"]
    },
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
