This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  actions/
    auth.ts
    geocode.ts
    home-products.ts
    local-products.ts
    locals.ts
    market-stand-products.ts
    market-stand.ts
    market-stands.ts
    products.ts
    settings.ts
    upload.ts
  admin/
    analytics/
      columns.tsx
      page.tsx
    settings/
      page.tsx
    users/
      page.tsx
    layout.tsx
    page.tsx
  api/
    admin/
      activity/
        route.ts
      performance/
        route.ts
      stats/
        route.ts
    auth/
      admin/
        route.ts
      callback/
        route.ts
      creation/
        route.ts
      storage-token/
        route.ts
      sync/
        route.ts
    local/
      [id]/
        products/
          route.ts
    market-stand/
      [id]/
        products/
          route.ts
        route.ts
      route.ts
      types.ts
      utils.ts
      validation.ts
    product/
      [id]/
        quantity/
          route.ts
      inventory/
        route.ts
      route.ts
    stripe/
      connect/
        success/
          route.ts
        route.ts
      route.ts
    test/
      analytics/
        route.ts
      auth-setup/
        route.ts
      setup/
        route.ts
    test-env/
      route.ts
    upload/
      route.ts
    user/
      route.ts
  auth/
    admin/
      login/
        page.tsx
    callback/
      route.ts
    login/
      page.tsx
  auth-error/
    auth-error-client.tsx
    page.tsx
  billing/
    page.tsx
  dashboard/
    [...route]/
      route.ts
    analytics/
      columns.tsx
      page.tsx
    events/
      page.tsx
    farm-page/
      page.tsx
    local/
      page.tsx
    market-stand/
      setup/
        edit/
          [id]/
            page.tsx
        new/
          page.tsx
        loading.tsx
        page.tsx
      market-stand-client.tsx
      page.tsx
    orders/
      page.tsx
    sell/
      page.tsx
      sell-client.tsx
    settings/
      page.tsx
    support/
      page.tsx
    layout.tsx
    page.tsx
  hooks/
    useUserLocation.ts
  how-it-works/
    layout.tsx
    page.tsx
  local/
    [id]/
      edit/
        page.tsx
      local-profile.tsx
      page.tsx
    setup/
      page.tsx
  market-stand/
    [id]/
      edit/
        page.tsx
      farm-profile.tsx
      page.tsx
    grid/
      MarketStandsGrid.tsx
      page.tsx
    map/
      loading.tsx
      page.tsx
    page.tsx
  navigate/
    [id]/
      page.tsx
  offline/
    page.tsx
  our-mission/
    page.tsx
  payment/
    cancel/
      page.tsx
    success/
      page.tsx
  product/
    [id]/
      edit/
        loading.tsx
        page.tsx
      loading.tsx
      page.tsx
  return/
    [id]/
      page.tsx
  sell/
    loading.tsx
    page.tsx
    sell-client.tsx
  settings/
    loading.tsx
    page.tsx
  actions.ts
  error.tsx
  globals.css
  home-client.tsx
  layout.tsx
  loading.tsx
  page.tsx
components/
  admin/
    AdminNav.tsx
  dashboard/
    MarketStandSelector.tsx
    ProductCatalogList.tsx
    ProductList.tsx
    ProductQuantityControl.tsx
    Sidebar.tsx
  form/
    AuthForm.tsx
    HoursInput.tsx
    LocalForm.tsx
    MarketStandForm.tsx
    Sellform.tsx
    SettingsForm.tsx
    SubmitStandButton.tsx
  ProductGrid/
    error.tsx
    index.tsx
    ProductGridClient.tsx
  providers/
    EnvProvider.tsx
    PostHogProvider.tsx
    ProductCacheProvider.tsx
    SupabaseProvider.tsx
    ThemeProvider.tsx
  skeletons/
    ProductCardSkeleton.tsx
  ui/
    alert.tsx
    avatar.tsx
    badge.tsx
    button.tsx
    card.tsx
    carousel.tsx
    data-table.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    line-chart.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    switch.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
  AuthDialog.tsx
  Editor.tsx
  ErrorBoundary.tsx
  FloatingTimer.tsx
  ImageUpload.tsx
  InventoryManager.tsx
  LoadingState.tsx
  LoadingStateGrid.tsx
  LocalCard.tsx
  MapView.tsx
  MapViewClient.tsx
  MapViewEditable.tsx
  MarketStandCard.tsx
  MarketStandHours.tsx
  MarketStandQR.tsx
  MarketStandSelect.tsx
  MarketStandsMap.tsx
  MarketStandViewNav.tsx
  MobileMenu.tsx
  Navbar.tsx
  NavbarLinks.tsx
  NewestProducts.tsx
  PaymentTab.tsx
  ProductCard.tsx
  ProductDashboardCard.tsx
  ProductDescription.tsx
  ProductEmail.tsx
  ProductRow.tsx
  ProductTimer.tsx
  ServiceWorkerRegistration.tsx
  StripeConnectButton.tsx
  SubmitButtons.tsx
  UnderConstruction.tsx
  UserNav.tsx
  ZipSearchBanner.tsx
hooks/
  index.ts
  useAuth.ts
  useForm.ts
  useMarketStands.ts
  useProducts.ts
  useUserLocation.ts
lib/
  cache/
    redis.ts
    revalidation.ts
  dto/
    marketStand.dto.ts
    product.dto.ts
  repositories/
    marketStandRepository.ts
    productRepository.ts
  services/
    marketStandService.ts
    productService.ts
  utils/
    format.ts
    index.ts
    validation.ts
  validators/
    marketStandSchemas.ts
    productSchemas.ts
  analytics.ts
  auth.ts
  CLEAN_ARCHITECTURE.md
  config.ts
  db.ts
  error-handler.ts
  logger.ts
  rate-limit.ts
  serializers.ts
  stripe.ts
  supabase-browser.ts
  supabase-config.ts
  supabase-route.ts
  supabase-server.ts
  utils.ts
nextjs/
  app/
    globals.css
    layout.tsx
    page.tsx
  public/
    file.svg
    globe.svg
    next.svg
    vercel.svg
    window.svg
  .gitignore
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  README.md
  tailwind.config.ts
  tsconfig.json
prisma/
  migrations/
    20250106_optimize_indexes/
      migration.sql
    20250206152338_init/
      migration.sql
    20250211020323_add_market_stand_hours/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  logos/
    cornucopia-dark.svg
    cornucopia-mountain-tree.svg
    cornucopia.svg
  next.svg
  sw.js
  vercel.svg
types/
  api.ts
  hours.ts
  index.ts
  marketStand.ts
  product.ts
  user.ts
.env.example
.eslintrc.json
.gitignore
AUTH_SETUP_INSTRUCTIONS.md
check-image-urls.sql
ClineContext.txt
components.json
fix-duplicate-products.sql
fix-image-urls.sql
fix-urls-extract-filename.sql
middleware.ts
next.config.mjs
package.json
postcss.config.mjs
README_PERFORMANCE.md
README.md
REFACTOR_PLAN.md
SUPABASE_MIGRATION_CHECKLIST.md
SUPABASE_SETUP_GUIDE.md
supabase-setup.sql
tailwind.config.ts
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/actions/auth.ts">
'use server'

import { getSupabaseServer } from '@/lib/supabase-server';
import { getAuthRedirectUrl } from '@/lib/supabase-config';
import jwt from 'jsonwebtoken';

if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
  throw new Error('Missing env.NEXT_PUBLIC_SUPABASE_URL');
}
if (!process.env.SUPABASE_JWT_SECRET) {
  throw new Error('Missing env.SUPABASE_JWT_SECRET');
}

export async function signInWithEmail(email: string, password: string) {
  const supabase = getSupabaseServer();
  
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    throw error;
  }

  return data;
}

export async function signUpWithEmail(email: string, password: string) {
  const supabase = getSupabaseServer();
  
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: getAuthRedirectUrl('/dashboard'),
    },
  });

  if (error) {
    throw error;
  }

  return data;
}

export async function signOut() {
  const supabase = getSupabaseServer();
  await supabase.auth.signOut();
}

export async function getUser() {
  const supabase = getSupabaseServer();
  const { data: { session } } = await supabase.auth.getSession();
  return session?.user ?? null;
}

export async function getSupabaseToken() {
  const user = await getUser();
  
  if (!user || !user.id) {
    throw new Error('Not authenticated');
  }

  // Create a JWT that Supabase will accept
  const payload = {
    aud: 'authenticated',
    exp: Math.floor(Date.now() / 1000) + (60 * 60), // 1 hour from now
    sub: user.id,
    email: user.email,
    role: 'authenticated'
  };

  if (!process.env.SUPABASE_JWT_SECRET) {
    throw new Error('Missing SUPABASE_JWT_SECRET');
  }
  const token = jwt.sign(payload, process.env.SUPABASE_JWT_SECRET as jwt.Secret);
  return token;
}
</file>

<file path="app/actions/geocode.ts">
'use server';

interface GeocodingResponse {
  lat: number;
  lng: number;
  source: 'browser' | 'zipcode';
  accuracy?: number;
}

export async function geocodeZipCode(zipCode: string): Promise<GeocodingResponse | null> {
  try {
    // Using Zippopotam.us API - free, no auth required, and specifically for ZIP codes
    const response = await fetch(
      `https://api.zippopotam.us/us/${zipCode}`,
      { 
        cache: 'no-store', // Disable caching to ensure fresh results
        next: { revalidate: 0 }
      }
    );

    if (!response.ok) {
      return null;
    }

    const data = await response.json();
    
    if (!data.places?.[0]) {
      return null;
    }

    // API returns coordinates as strings, convert to numbers
    const lat = parseFloat(data.places[0].latitude);
    const lng = parseFloat(data.places[0].longitude);

    if (isNaN(lat) || isNaN(lng)) {
      return null;
    }

    return { 
      lat, 
      lng,
      source: 'zipcode',
      accuracy: 5000 // ZIP codes typically have accuracy within 5km
    };
  } catch (error) {
    return null;
  }
}

export async function getBrowserLocation(): Promise<GeocodingResponse | null> {
  return new Promise((resolve) => {
    if (!navigator.geolocation) {
      resolve(null);
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        resolve({
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          source: 'browser',
          accuracy: position.coords.accuracy
        });
      },
      () => resolve(null),
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    );
  });
}
</file>

<file path="app/actions/home-products.ts">
'use server';

import { getProducts, type ProductResponse } from "./products";
import { handleDatabaseError } from "@/lib/error-handler";

export interface LocationType {
  coords: {
    lat: number;
    lng: number;
    accuracy?: number;
    timestamp?: number;
  };
  source: 'browser' | 'zipcode';
}

export interface SerializedProduct extends ProductResponse {
  distance: number | null;
  marketStand: {
    id: string;
    name: string;
    latitude: number;
    longitude: number;
    locationName: string;
    user: {
      firstName: string;
      profileImage: string;
    };
  };
}

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // Distance in km
}

export const getHomeProducts = async (userLocation: LocationType | null, cursor?: string): Promise<SerializedProduct[]> => {
  try {
    console.log('Fetching products with location:', userLocation);
    const products = await getProducts({
      limit: cursor ? 12 : 50, // Fetch more initially for local filtering
      cursor,
      isActive: true,
      marketStandId: undefined,
    });

    console.log('Raw products:', products.length);

    const productsWithDistance = products.map((product: ProductResponse) => {
      if (!product.marketStand?.latitude || !product.marketStand?.longitude) {
        return { ...product, distance: null };
      }
      
      const distance = userLocation
        ? calculateDistance(
            userLocation.coords.lat,
            userLocation.coords.lng,
            product.marketStand.latitude,
            product.marketStand.longitude
          )
        : null;

      return {
        ...product,
        distance
      };
    });

    // Sort by distance if location available, otherwise by newest
    const sortedProducts = [...productsWithDistance].sort((a, b) => {
      if (!userLocation) {
        // Sort by newest if no location
        return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
      }
      if (a.distance === null || b.distance === null) return 0;
      return a.distance - b.distance;
    }) as SerializedProduct[];

    console.log('Sorted products:', sortedProducts.length);

    // Log initial state
    console.log('Processing products:', {
      total: sortedProducts.length,
      hasLocation: !!userLocation,
      locationSource: userLocation?.source,
      cursor
    });

    // If we have a location, separate local and non-local products
    if (userLocation) {
      // Log location details
      console.log('Location details:', {
        lat: userLocation.coords.lat,
        lng: userLocation.coords.lng,
        source: userLocation.source,
        accuracy: userLocation.coords.accuracy
      });

      // Filter and log each product's distance
      const productsWithDistanceInfo = sortedProducts.map(p => ({
        id: p.id,
        name: p.name,
        distance: p.distance,
        isLocal: p.distance !== null && p.distance <= 241.4
      }));
      console.log('Product distances:', productsWithDistanceInfo);

      // Use a larger radius for zip code locations since they're less precise
      const localRadius = userLocation.source === 'zipcode' ? 321.87 : 241.4; // 200 miles for zip, 150 miles for browser
      
      const localProducts = sortedProducts.filter(p => p.distance !== null && p.distance <= localRadius);
      const otherProducts = sortedProducts.filter(p => p.distance === null || p.distance > localRadius);
      
      console.log('Filtered products:', {
        local: localProducts.length,
        other: otherProducts.length,
        radius: localRadius,
        cursor
      });

      // If loading initial products and we have less than 12 local products
      if (!cursor && localProducts.length < 12) {
        const combined = [...localProducts, ...otherProducts];
        console.log('Returning combined products:', combined.length);
        return combined;
      }
      
      // If loading more products, return non-local products
      if (cursor) {
        console.log('Returning explore products:', otherProducts.length);
        return otherProducts;
      }

      // Initial load with enough local products
      console.log('Returning local products:', localProducts.length);
      return localProducts;
    }

    // No location, return all products sorted by date
    console.log('Returning all products:', sortedProducts.length);
    return sortedProducts;
  } catch (error) {
    // Use the error handler utility to handle the error consistently
    const errorData = handleDatabaseError(error, "Failed to fetch home products", {
      hasLocation: !!userLocation,
      locationSource: userLocation?.source,
      cursor
    });
    
    console.error('Error fetching home products:', errorData);
    return [];
  }
};
</file>

<file path="app/actions/local-products.ts">
"use server";

import prisma, { executeWithRetry } from "@/lib/db";
import { getProducts, type ProductResponse } from "./products";
import { handleDatabaseError } from "@/lib/error-handler";
import { serializeProducts } from "@/lib/serializers";

export interface SerializedProduct extends ProductResponse {
  distance: number | null;
  marketStand: {
    id: string;
    name: string;
    latitude: number;
    longitude: number;
    locationName: string;
    user: {
      firstName: string;
      profileImage: string;
    };
  };
}

export async function getLocalProducts(localId: string): Promise<SerializedProduct[]> {
  try {
    const products = await executeWithRetry(() => prisma.product.findMany({
      where: {
        localId,
        isActive: true,
        status: 'APPROVED',
        inventory: {
          gt: 0
        }
      },
      orderBy: {
        updatedAt: 'desc'
      },
      include: {
        marketStand: {
          select: {
            id: true,
            name: true,
            locationName: true,
            latitude: true,
            longitude: true,
            user: {
              select: {
                firstName: true,
                profileImage: true
              }
            }
          }
        }
      }
    }));

    // Use the serializer to convert Prisma models to plain objects
    const serializedProducts = serializeProducts(products);
    
    // Add distance property (null for local products)
    return serializedProducts.map(product => ({
      ...product,
      distance: null // Local products don't need distance calculation
    })) as SerializedProduct[];
  } catch (error) {
    // Use the error handler utility to handle the error consistently
    const errorData = handleDatabaseError(error, "Failed to fetch local products", {
      localId
    });
    
    console.error('Error fetching local products:', errorData);
    return [];
  }
}
</file>

<file path="app/actions/locals.ts">
"use server";

import prisma, { executeWithRetry } from "lib/db";
import { revalidatePath } from "next/cache";
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";

export async function createLocal(formData: FormData) {
  const user = await getUser();
  if (!user?.id) {
    throw new Error("Not authenticated");
  }

  const name = formData.get("name") as string;
  const description = formData.get("description") as string;
  const story = formData.get("story") as string;
  const farmingPractices = formData.get("farmingPractices") as string;
  const wholesaleInfo = formData.get("wholesaleInfo") as string;
  const website = formData.get("website") as string;
  const socialMedia = formData.get("socialMedia") as string;
  const locationName = formData.get("locationName") as string;
  const locationGuide = formData.get("locationGuide") as string;
  const latitude = parseFloat(formData.get("latitude") as string);
  const longitude = parseFloat(formData.get("longitude") as string);
  const images = JSON.parse(formData.get("images") as string) as string[];
  const teamMembers = JSON.parse(formData.get("teamMembers") as string);
  const certifications = JSON.parse(formData.get("certifications") as string);
  const seasonalSchedule = JSON.parse(formData.get("seasonalSchedule") as string);
  const events = JSON.parse(formData.get("events") as string);
  const operatingHours = JSON.parse(formData.get("operatingHours") as string);

  const local = await executeWithRetry(() => prisma.local.create({
    data: {
      name,
      description,
      story,
      farmingPractices,
      wholesaleInfo,
      website,
      socialMedia: socialMedia.split("\n").filter(Boolean),
      locationName,
      locationGuide,
      latitude,
      longitude,
      images,
      teamMembers,
      certifications,
      seasonalSchedule,
      events,
      operatingHours,
      userId: user.id,
      status: "PENDING",
      isActive: true
    }
  }));

  revalidatePath(`/local/${local.id}`);
  redirect(`/local/${local.id}`);
}

export async function updateLocal(id: string, formData: FormData) {
  const user = await getUser();
  if (!user?.id) {
    throw new Error("Not authenticated");
  }

  const local = await executeWithRetry(() => prisma.local.findUnique({
    where: { id },
    select: { userId: true }
  }));

  if (!local || local.userId !== user.id) {
    throw new Error("Not authorized");
  }

  const name = formData.get("name") as string;
  const description = formData.get("description") as string;
  const story = formData.get("story") as string;
  const farmingPractices = formData.get("farmingPractices") as string;
  const wholesaleInfo = formData.get("wholesaleInfo") as string;
  const website = formData.get("website") as string;
  const socialMedia = formData.get("socialMedia") as string;
  const locationName = formData.get("locationName") as string;
  const locationGuide = formData.get("locationGuide") as string;
  const latitude = parseFloat(formData.get("latitude") as string);
  const longitude = parseFloat(formData.get("longitude") as string);
  const images = JSON.parse(formData.get("images") as string) as string[];
  const teamMembers = JSON.parse(formData.get("teamMembers") as string);
  const certifications = JSON.parse(formData.get("certifications") as string);
  const seasonalSchedule = JSON.parse(formData.get("seasonalSchedule") as string);
  const events = JSON.parse(formData.get("events") as string);
  const operatingHours = JSON.parse(formData.get("operatingHours") as string);

  await executeWithRetry(() => prisma.local.update({
    where: { id },
    data: {
      name,
      description,
      story,
      farmingPractices,
      wholesaleInfo,
      website,
      socialMedia: socialMedia.split("\n").filter(Boolean),
      locationName,
      locationGuide,
      latitude,
      longitude,
      images,
      teamMembers,
      certifications,
      seasonalSchedule,
      events,
      operatingHours
    }
  }));

  revalidatePath(`/local/${id}`);
}
</file>

<file path="app/actions/market-stand-products.ts">
'use server';

import { type SerializedProduct } from "./home-products";
import { handleDatabaseError } from "@/lib/error-handler";
export type { SerializedProduct };

export async function getMarketStandProducts(marketStandId: string): Promise<SerializedProduct[]> {
  try {
    const response = await fetch(`${process.env.NEXT_PUBLIC_APP_URL}/api/market-stand/${marketStandId}/products`);
    
    if (!response.ok) {
      throw new Error('Failed to fetch market stand products');
    }

    const products = await response.json();
    
    return products.map((product: any) => ({
      ...product,
      updatedAt: new Date(product.updatedAt).toISOString(),
      distance: null // Market stand products don't need distance calculation
    }));
  } catch (error) {
    // Use the error handler utility to handle the error consistently
    const errorData = handleDatabaseError(error, "Failed to fetch market stand products", {
      marketStandId,
      apiUrl: `${process.env.NEXT_PUBLIC_APP_URL}/api/market-stand/${marketStandId}/products`
    });
    
    console.error('Error fetching market stand products:', errorData);
    return [];
  }
}
</file>

<file path="app/actions/market-stand.ts">
'use server';

import { marketStandService } from "@/lib/services/marketStandService";
import { MarketStandDTO, WeeklyHours } from "@/lib/dto/marketStand.dto";
import { createErrorResponse, createNotFoundResponse } from "@/lib/error-handler";
import { Status } from "@prisma/client";

/**
 * Create a new market stand
 * Uses the market stand service layer for business logic and validation
 */
export async function CreateMarketStand(
  _: { status: undefined; message: null },
  formData: FormData
) {
  try {
    const userId = formData.get("userId") as string;
    const name = formData.get("name") as string;
    const description = formData.get("description") as string;
    const locationName = formData.get("locationName") as string;
    const locationGuide = formData.get("locationGuide") as string;
    const latitude = parseFloat(formData.get("latitude") as string);
    const longitude = parseFloat(formData.get("longitude") as string);
    const website = formData.get("website") as string;
    const images = JSON.parse(formData.get("images") as string) as string[];
    const tags = JSON.parse(formData.get("tags") as string) as string[];
    const socialMedia = JSON.parse(formData.get("socialMedia") as string) as string[];
    const hours = JSON.parse(formData.get("hours") as string) as WeeklyHours;

    const marketStand = await marketStandService.createMarketStand({
      userId,
      name,
      description,
      locationName,
      locationGuide,
      latitude,
      longitude,
      website: website || null,
      images,
      tags,
      socialMedia,
      hours,
      status: Status.PENDING,
      isActive: true,
    });

    return { success: true, marketStand };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error creating market stand"
    };
  }
}

/**
 * Update an existing market stand
 * Uses the market stand service layer for business logic and validation
 */
export async function UpdateMarketStand(
  _: { status: undefined; message: null },
  formData: FormData
) {
  try {
    const id = formData.get("id") as string;
    const name = formData.get("name") as string;
    const description = formData.get("description") as string;
    const locationName = formData.get("locationName") as string;
    const locationGuide = formData.get("locationGuide") as string;
    const latitude = parseFloat(formData.get("latitude") as string);
    const longitude = parseFloat(formData.get("longitude") as string);
    const website = formData.get("website") as string;
    const images = JSON.parse(formData.get("images") as string) as string[];
    const tags = JSON.parse(formData.get("tags") as string) as string[];
    const socialMedia = JSON.parse(formData.get("socialMedia") as string) as string[];
    const hours = JSON.parse(formData.get("hours") as string) as WeeklyHours;

    const marketStand = await marketStandService.updateMarketStand(id, {
      name,
      description,
      locationName,
      locationGuide,
      latitude,
      longitude,
      website: website || null,
      images,
      tags,
      socialMedia,
      hours,
    });

    return { success: true, marketStand };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : "Error updating market stand"
    };
  }
}
</file>

<file path="app/actions/market-stands.ts">
'use server';

import { cache } from 'react';
import { revalidatePath } from 'next/cache';
import { Prisma } from '@prisma/client';
import db from "@/lib/db";
import { handleDatabaseError } from "@/lib/error-handler";
import { serializeMarketStands } from "@/lib/serializers";

export interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  createdAt: Date;
  tags: string[];
  products: Array<{
    id: string;
    name: string;
    description: string;
    price: number;
    images: string[];
    createdAt: Date;
    updatedAt: Date;
  }>;
  user: {
    firstName: string;
    profileImage: string;
  };
  _count?: {
    products: number;
  };
  lastProductUpdate?: Date | null;
}

export const getUserMarketStands = cache(async (userId: string): Promise<MarketStand[]> => {
  try {
    const stands = await db.marketStand.findMany({
      where: {
        userId: userId,
        isActive: true
      },
      include: {
        products: true,
        user: {
          select: {
            firstName: true,
            profileImage: true
          }
        },
        _count: {
          select: {
            products: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    // Use the serializer to convert Prisma models to plain objects
    return serializeMarketStands(stands);
  } catch (error) {
    // Use the error handler utility to handle the error consistently
    const errorData = handleDatabaseError(error, "Failed to fetch user market stands", {
      userId
    });
    
    console.error('Error fetching user market stands:', errorData);
    
    // Return empty array as fallback
    return [];
  }
});

export const getMarketStands = cache(async (): Promise<MarketStand[]> => {
  try {
    const stands = await db.marketStand.findMany({
      where: {
        isActive: true
      },
      include: {
        products: true,
        user: {
          select: {
            firstName: true,
            profileImage: true
          }
        }
      }
    });

    // Use the serializer to convert Prisma models to plain objects
    return serializeMarketStands(stands);
  } catch (error) {
    // Use the error handler utility to handle the error consistently
    const errorData = handleDatabaseError(error, "Failed to fetch market stands");
    
    console.error('Error fetching market stands:', errorData);
    
    // Re-throw database connection errors that should be handled by the UI
    if (error instanceof Prisma.PrismaClientInitializationError) {
      throw new Error('Database connection error. Please try again later.');
    }
    
    // For other errors, return empty array as fallback
    return [];
  }
});
</file>

<file path="app/actions/products.ts">
"use server";

import { productService } from "@/lib/services/productService";
import { ProductWithMarketStandDTO } from "@/lib/dto/product.dto";
import { Status } from "@prisma/client";

// Re-export the DTO type for backwards compatibility
export type ProductResponse = ProductWithMarketStandDTO;

interface GetProductsParams {
  userId?: string;
  marketStandId?: string;
  limit?: number;
  cursor?: string;
  isActive?: boolean;
}

/**
 * Get products with filtering
 * Uses the product service layer for business logic
 */
export async function getProducts(params: GetProductsParams): Promise<ProductResponse[]> {
  return await productService.getProducts({
    ...params,
    limit: params.limit ?? 50,
    isActive: params.isActive ?? true,
  });
}

/**
 * Get a single product by ID
 * Uses the product service layer for business logic
 */
export async function getProduct(id: string): Promise<ProductResponse | null> {
  return await productService.getProductById(id);
}

type CreateProductInput = {
  name: string;
  description: string;
  price: number;
  images: string[];
  inventory: number;
  inventoryUpdatedAt?: string | null;
  status: Status;
  isActive: boolean;
  userId: string;
  marketStandId: string;
  tags: string[];
};

/**
 * Create a new product
 * Uses the product service layer for business logic and validation
 */
export async function createProduct(data: CreateProductInput): Promise<ProductResponse> {
  return await productService.createProduct(data);
}

type UpdateProductInput = Partial<Omit<CreateProductInput, 'userId' | 'marketStandId'>>;

/**
 * Update an existing product
 * Uses the product service layer for business logic and validation
 */
export async function updateProduct(
  id: string,
  data: UpdateProductInput
): Promise<ProductResponse> {
  return await productService.updateProduct(id, data);
}

/**
 * Delete a product
 * Uses the product service layer for business logic
 */
export async function deleteProduct(id: string): Promise<void> {
  return await productService.deleteProduct(id);
}
</file>

<file path="app/actions/settings.ts">
"use server";

import { createServerSupabaseClient } from "@/lib/auth";
import prisma from "@/lib/db";
import { z } from "zod";

const userSettingsSchema = z.object({
  firstName: z.string().min(1, { message: "First name is required" }),
  lastName: z.string().min(1, { message: "Last name is required" }),
});

export type State = {
  status: "error" | "success" | undefined;
  message: string | null;
};

export async function UpdateUserSettings(prevState: State, formData: FormData): Promise<State> {
  const supabase = createServerSupabaseClient();
  const { data: { session } } = await supabase.auth.getSession();
  const user = session?.user;

  if (!user) {
    return {
      status: "error",
      message: "Not authenticated"
    };
  }

  const validateFields = userSettingsSchema.safeParse({
    firstName: formData.get("firstName")?.toString() ?? "",
    lastName: formData.get("lastName")?.toString() ?? "",
  });

  if (!validateFields.success) {
    return {
      status: "error",
      message: "Please check your inputs and try again."
    };
  }

  try {
    await prisma.user.update({
      where: {
        id: user.id
      },
      data: {
        firstName: validateFields.data.firstName,
        lastName: validateFields.data.lastName,
      }
    });

    return {
      status: "success",
      message: "Settings updated successfully"
    };
  } catch {
    return {
      status: "error",
      message: "Failed to update settings. Please try again."
    };
  }
}
</file>

<file path="app/actions/upload.ts">
'use server'

import { getUser } from '@/lib/auth';
import { createServerSupabaseClient } from '@/lib/auth';

export async function uploadImageWithAuth(
  fileBase64: string,
  filename: string,
  bucket: string = 'product-images',
  path: string = ''
): Promise<string> {
  const user = await getUser();
  if (!user) {
    throw new Error('Authentication required for image upload');
  }

  const supabase = createServerSupabaseClient();
  const fileName = `${path}${Date.now()}-${filename}`;
  
  // Convert base64 to buffer
  const base64Data = fileBase64.split(',')[1] || fileBase64;
  const buffer = Buffer.from(base64Data, 'base64');

  const { data, error } = await supabase.storage
    .from(bucket)
    .upload(`${user.id}/${fileName}`, buffer, {
      cacheControl: '3600',
      upsert: false,
    });

  if (error) {
    throw error;
  }

  const { data: urlData } = await supabase.storage
    .from(bucket)
    .getPublicUrl(`${user.id}/${data.path}`);

  if (!urlData.publicUrl) {
    throw new Error('Failed to get public URL');
  }

  return urlData.publicUrl;
}

export async function uploadImagesWithAuth(
  files: { base64: string; name: string }[],
  bucket: string = 'product-images',
  path?: string
): Promise<string[]> {
  const uploadPromises = files.map(file => 
    uploadImageWithAuth(file.base64, file.name, bucket, path)
  );
  return Promise.all(uploadPromises);
}
</file>

<file path="app/admin/analytics/columns.tsx">
import { ColumnDef } from "@tanstack/react-table"
import { Badge } from "@/components/ui/badge"
import { formatDistanceToNow } from 'date-fns'

type RecentActivity = {
  id: string
  name: string
  price: number
  status: string
  createdAt: Date
  user: {
    firstName: string
    lastName: string
    role: string
  }
  marketStand: {
    name: string
    status: string
  }
}

export const columns: ColumnDef<RecentActivity>[] = [
  {
    accessorKey: "name",
    header: "Product",
    cell: ({ row }) => {
      return (
        <div className="flex flex-col">
          <span className="font-medium">{row.getValue("name")}</span>
          <span className="text-sm text-gray-500">{row.original.marketStand.name}</span>
        </div>
      )
    }
  },
  {
    accessorKey: "user",
    header: "Vendor",
    cell: ({ row }) => {
      const user = row.original.user
      return (
        <div className="flex flex-col">
          <span>{`${user.firstName} ${user.lastName}`}</span>
          <Badge variant="outline" className="w-fit">{user.role}</Badge>
        </div>
      )
    }
  },
  {
    accessorKey: "price",
    header: "Price",
    cell: ({ row }) => {
      const amount = parseFloat(row.getValue("price"))
      const formatted = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
      }).format(amount / 100)
 
      return <div className="font-medium">{formatted}</div>
    }
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as string
      return (
        <Badge 
          variant={
            status === 'APPROVED' ? 'default' :
            status === 'PENDING' ? 'secondary' :
            'destructive'
          }
        >
          {status.toLowerCase()}
        </Badge>
      )
    }
  },
  {
    accessorKey: "createdAt",
    header: "Created",
    cell: ({ row }) => {
      return formatDistanceToNow(new Date(row.getValue("createdAt")), { addSuffix: true })
    }
  }
]
</file>

<file path="app/admin/analytics/page.tsx">
import { Suspense } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import prisma from '@/lib/db'
import { LineChart } from '@/components/ui/line-chart'
import { DataTable } from '@/components/ui/data-table'
import { columns } from './columns'

async function getAdminAnalyticsData() {
  // Get total counts with more detailed breakdowns
  const [
    totalBusinesses,
    totalVendors,
    totalCustomers,
    totalProducts,
    pendingBusinesses,
    activeUsers,
    totalReviews
  ] = await Promise.all([
    prisma.marketStand.count({ where: { isActive: true } }),
    prisma.user.count({ where: { role: 'USER' } }),
    prisma.user.count(),
    prisma.product.count({ where: { isActive: true } }),
    prisma.marketStand.count({ where: { status: 'PENDING' } }),
    prisma.user.count({ 
      where: { 
        sessions: { some: { endTime: { gt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) } } }
      } 
    }),
    prisma.productReview.count()
  ])

  // Get platform metrics
  const orderMetrics = await prisma.standMetrics.findMany({
    select: {
      dailyMetrics: {
        select: {
          date: true,
          orders: true,
          revenue: true,
          views: true,
          uniqueViews: true
        },
        orderBy: {
          date: 'asc'
        },
        take: 30 // Last 30 days
      }
    }
  })

  // Get user growth data
  const userGrowth = await prisma.user.groupBy({
    by: ['role'],
    _count: true,
    orderBy: {
      _count: {
        role: 'desc'
      }
    }
  })

  // Get recent activity
  const recentActivity = await prisma.product.findMany({
    where: {
      isActive: true
    },
    select: {
      id: true,
      name: true,
      price: true,
      status: true,
      createdAt: true,
      user: {
        select: {
          firstName: true,
          lastName: true,
          role: true
        }
      },
      marketStand: {
        select: {
          name: true,
          status: true
        }
      }
    },
    orderBy: {
      createdAt: 'desc'
    },
    take: 10
  })

  return {
    totalBusinesses,
    totalVendors,
    totalCustomers,
    totalProducts,
    pendingBusinesses,
    activeUsers,
    totalReviews,
    orderMetrics,
    userGrowth,
    recentActivity
  }
}

export default async function AdminAnalyticsDashboard() {
  const {
    totalBusinesses,
    totalVendors,
    totalCustomers,
    totalProducts,
    pendingBusinesses,
    activeUsers,
    totalReviews,
    orderMetrics,
    userGrowth,
    recentActivity
  } = await getAdminAnalyticsData()

  // Process data for charts
  const platformMetrics = orderMetrics.flatMap(metric => 
    metric.dailyMetrics.map(daily => ({
      date: daily.date,
      orders: daily.orders,
      revenue: daily.revenue / 100, // Convert cents to dollars
      views: daily.views,
      uniqueViews: daily.uniqueViews
    }))
  )

  // Calculate engagement rate
  const avgEngagementRate = platformMetrics.reduce((acc, curr) => 
    acc + (curr.uniqueViews > 0 ? (curr.orders / curr.uniqueViews) * 100 : 0), 0
  ) / platformMetrics.length

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Platform Analytics</h1>
        <div className="text-sm text-gray-500">
          Last updated: {new Date().toLocaleString()}
        </div>
      </div>
      
      {/* Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Businesses</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totalBusinesses}</div>
            <p className="text-xs text-gray-500">Pending: {pendingBusinesses}</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Users</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{activeUsers}</div>
            <p className="text-xs text-gray-500">Total: {totalCustomers}</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Products</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totalProducts}</div>
            <p className="text-xs text-gray-500">Reviews: {totalReviews}</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Engagement Rate</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{avgEngagementRate.toFixed(1)}%</div>
            <p className="text-xs text-gray-500">30-day average</p>
          </CardContent>
        </Card>
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <Card>
          <CardHeader>
            <CardTitle>Revenue Trends</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart 
              data={platformMetrics}
              xField="date"
              yField="revenue"
              height={300}
              valuePrefix="$"
            />
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>User Engagement</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart 
              data={platformMetrics}
              xField="date"
              yField="uniqueViews"
              height={300}
            />
          </CardContent>
        </Card>
      </div>

      {/* Recent Activity Table */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <Suspense fallback={<div>Loading...</div>}>
            <DataTable columns={columns} data={recentActivity} />
          </Suspense>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/admin/settings/page.tsx">
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { getSupabaseServer } from '@/lib/supabase-server'
import prisma from '@/lib/db'
import { redirect } from 'next/navigation'

async function checkSuperAdmin() {
  const supabase = getSupabaseServer()
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session?.user) {
    redirect('/')
  }

  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true }
  })

  if (!user || user.role !== 'SUPER_ADMIN') {
    redirect('/admin')
  }
}

async function getSystemStats() {
  const [
    totalStorage,
    totalUploads,
    databaseSize,
    activeConnections
  ] = await Promise.all([
    prisma.$queryRaw<{ size: string }[]>`
      SELECT pg_size_pretty(sum(pg_total_relation_size(schemaname || '.' || tablename))::bigint) as size
      FROM pg_tables
      WHERE schemaname = 'public'
    `.then(result => result[0].size),
    prisma.product.count({
      where: {
        images: { isEmpty: false }
      }
    }),
    prisma.$queryRaw<{ size: string }[]>`
      SELECT pg_size_pretty(pg_database_size(current_database())) as size
    `.then(result => result[0].size),
    prisma.$queryRaw<{ count: string }[]>`
      SELECT count(*)::text as count
      FROM pg_stat_activity
      WHERE datname = current_database()
    `.then(result => result[0].count)
  ])

  return {
    totalStorage,
    totalUploads,
    databaseSize,
    activeConnections
  }
}

export default async function AdminSettingsPage() {
  // Check if user is super admin
  await checkSuperAdmin()

  // Get system stats
  const stats = await getSystemStats()

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">System Settings</h1>
        <div className="text-sm text-gray-500">
          Last updated: {new Date().toLocaleString()}
        </div>
      </div>

      {/* System Stats */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Storage</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalStorage}</div>
            <p className="text-xs text-gray-500">Database + Uploads</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Uploads</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalUploads}</div>
            <p className="text-xs text-gray-500">Product Images</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Database Size</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.databaseSize}</div>
            <p className="text-xs text-gray-500">PostgreSQL</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Connections</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.activeConnections}</div>
            <p className="text-xs text-gray-500">Database Sessions</p>
          </CardContent>
        </Card>
      </div>

      {/* Configuration Sections */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>Analytics Configuration</CardTitle>
          </CardHeader>
          <CardContent className="space-y-2">
            <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
              <div>
                <h3 className="font-medium">PostHog Integration</h3>
                <p className="text-sm text-gray-500">Event tracking and analytics</p>
              </div>
              <div className="text-sm font-medium text-green-600">Connected</div>
            </div>
            <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
              <div>
                <h3 className="font-medium">Data Retention</h3>
                <p className="text-sm text-gray-500">Event history storage period</p>
              </div>
              <div className="text-sm font-medium">90 days</div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>System Health</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <h3 className="font-medium">API Status</h3>
                  <p className="text-sm text-gray-500">REST and GraphQL endpoints</p>
                </div>
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  Healthy
                </span>
              </div>
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <h3 className="font-medium">Database Status</h3>
                  <p className="text-sm text-gray-500">PostgreSQL connection</p>
                </div>
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  Connected
                </span>
              </div>
              <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div>
                  <h3 className="font-medium">Storage Status</h3>
                  <p className="text-sm text-gray-500">File upload service</p>
                </div>
                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                  Available
                </span>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/admin/users/page.tsx">
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { DataTable } from '@/components/ui/data-table'
import prisma from '@/lib/db'
import { formatDistanceToNow } from 'date-fns'
import { Badge } from '@/components/ui/badge'
import { ColumnDef } from '@tanstack/react-table'
import { UserRole } from '@prisma/client'

type UserWithRelations = {
  id: string
  email: string
  firstName: string
  lastName: string
  role: UserRole
  createdAt: Date
  marketStands: Array<{
    id: string
    isActive: boolean
  }>
  products: Array<{
    id: string
    isActive: boolean
  }>
}

// Define columns for the users table
const columns: ColumnDef<UserWithRelations>[] = [
  {
    id: "name",
    header: "Name",
    cell: ({ row }) => {
      const user = row.original
      return (
        <div className="flex flex-col">
          <span className="font-medium">{`${user.firstName} ${user.lastName}`}</span>
          <span className="text-sm text-gray-500">{user.email}</span>
        </div>
      )
    }
  },
  {
    id: "role",
    header: "Role",
    accessorFn: row => row.role,
    cell: ({ row }) => {
      const role = row.getValue("role") as UserRole
      return (
        <Badge 
          variant={
            role === 'SUPER_ADMIN' ? 'destructive' :
            role === 'ADMIN' ? 'default' :
            'secondary'
          }
        >
          {role.toLowerCase().replace('_', ' ')}
        </Badge>
      )
    }
  },
  {
    id: "createdAt",
    header: "Joined",
    accessorFn: row => row.createdAt,
    cell: ({ row }) => {
      return formatDistanceToNow(new Date(row.getValue("createdAt")), { addSuffix: true })
    }
  },
  {
    id: "marketStands",
    header: "Stands",
    accessorFn: row => row.marketStands,
    cell: ({ row }) => {
      const stands = row.original.marketStands
      return (
        <div className="text-center">
          <span className="font-medium">{stands.length}</span>
          {stands.length > 0 && (
            <div className="text-xs text-gray-500">
              {stands.filter(s => s.isActive).length} active
            </div>
          )}
        </div>
      )
    }
  },
  {
    id: "products",
    header: "Products",
    accessorFn: row => row.products,
    cell: ({ row }) => {
      const products = row.original.products
      return (
        <div className="text-center">
          <span className="font-medium">{products.length}</span>
          {products.length > 0 && (
            <div className="text-xs text-gray-500">
              {products.filter(p => p.isActive).length} active
            </div>
          )}
        </div>
      )
    }
  }
]

async function getUsersData() {
  const users = await prisma.$queryRaw<UserWithRelations[]>`
    SELECT 
      u.id,
      u.email,
      u."firstName",
      u."lastName",
      u.role,
      u."createdAt",
      COALESCE(
        (
          SELECT json_agg(json_build_object('id', ms.id, 'isActive', ms."isActive"))
          FROM "MarketStand" ms
          WHERE ms."userId" = u.id
        ),
        '[]'::json
      ) as "marketStands",
      COALESCE(
        (
          SELECT json_agg(json_build_object('id', p.id, 'isActive', p."isActive"))
          FROM "Product" p
          WHERE p."userId" = u.id
        ),
        '[]'::json
      ) as products
    FROM "User" u
    ORDER BY u."createdAt" DESC
  `

  return users
}

export default async function UsersPage() {
  const users = await getUsersData()

  // Get role counts
  const roleCounts = users.reduce((acc, user) => {
    acc[user.role] = (acc[user.role] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  return (
    <div className="space-y-8">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Users</h1>
        <div className="text-sm text-gray-500">
          Last updated: {new Date().toLocaleString()}
        </div>
      </div>

      {/* Role Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Regular Users</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{roleCounts.USER || 0}</div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Admins</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{roleCounts.ADMIN || 0}</div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Super Admins</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{roleCounts.SUPER_ADMIN || 0}</div>
          </CardContent>
        </Card>
      </div>

      {/* Users Table */}
      <Card>
        <CardHeader>
          <CardTitle>All Users</CardTitle>
        </CardHeader>
        <CardContent>
          <DataTable columns={columns} data={users} />
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/admin/layout.tsx">
import { redirect } from 'next/navigation'
import { getSupabaseServer } from '@/lib/supabase-server'
import { createClient } from '@supabase/supabase-js'
import prisma from '@/lib/db'
import Link from 'next/link'
import { AdminNav } from '@/components/admin/AdminNav'

async function getUser() {
  const supabase = getSupabaseServer()
  const { data: { session }, error } = await supabase.auth.getSession()

  if (error) {
    console.error('Error getting session:', error)
    return null
  }

  if (!session?.user) {
    return null
  }

  // Check role from user metadata first
  const role = session.user.user_metadata?.role
  if (role && ['ADMIN', 'SUPER_ADMIN'].includes(role)) {
    return { role }
  }

  // Fallback to database check
  const user = await prisma.user.findUnique({
    where: { id: session.user.id },
    select: { role: true }
  })

  if (!user || !['ADMIN', 'SUPER_ADMIN'].includes(user.role)) {
    return null
  }

  // Update Supabase metadata if it doesn't match
  if (role !== user.role) {
    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )

    await adminClient.auth.admin.updateUserById(
      session.user.id,
      {
        user_metadata: {
          ...session.user.user_metadata,
          role: user.role
        }
      }
    )
  }

  return user
}

export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode
}) {
  try {
    const user = await getUser()

    // Redirect if not admin
    if (!user || (user.role !== 'ADMIN' && user.role !== 'SUPER_ADMIN')) {
      console.log('[AdminLayout] Access denied:', user?.role)
      redirect('/')
    }

    return (
      <div className="min-h-screen bg-gray-100">
        {/* Admin Header */}
        <header className="bg-white shadow">
          <div className="mx-auto px-4 sm:px-6 lg:px-8">
            <div className="flex h-16 justify-between">
              <div className="flex">
                <div className="flex flex-shrink-0 items-center">
                  <Link href="/admin" className="text-xl font-bold">
                    Admin Portal
                  </Link>
                </div>
                <AdminNav isSuperAdmin={user.role === 'SUPER_ADMIN'} />
              </div>
            </div>
          </div>
        </header>

        {/* Main Content */}
        <main className="py-10">
          <div className="mx-auto max-w-7xl sm:px-6 lg:px-8">
            {children}
          </div>
        </main>
      </div>
    )
  } catch (error) {
    console.error('Error in admin layout:', error)
    redirect('/auth/login')
  }
}
</file>

<file path="app/admin/page.tsx">
'use client'

import { Card } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { cn } from '@/lib/utils'

interface DashboardStats {
  totalUsers: number
  pendingStands: number
  pendingProducts: number
  reportedReviews: number
}

interface Activity {
  type: 'stand' | 'product'
  name: string
  oldStatus: string
  newStatus: string
  changedBy: string
  note: string
  createdAt: string
}

export default function AdminDashboard() {
  const [stats, setStats] = useState<DashboardStats>({
    totalUsers: 0,
    pendingStands: 0,
    pendingProducts: 0,
    reportedReviews: 0
  })
  const [activities, setActivities] = useState<Activity[]>([])
  const router = useRouter()

  useEffect(() => {
    async function fetchData() {
      const [statsResponse, activityResponse] = await Promise.all([
        fetch('/api/admin/stats'),
        fetch('/api/admin/activity')
      ])
      const [statsData, activityData] = await Promise.all([
        statsResponse.json(),
        activityResponse.json()
      ])
      setStats(statsData)
      setActivities(activityData.activities)
    }
    fetchData()
  }, [])

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-sm text-gray-500">
          Last updated: {new Date().toLocaleString()}
        </p>
      </div>

      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-4">
        <Card className="p-6 bg-blue-50">
          <h3 className="text-lg font-medium text-gray-900">Total Users</h3>
          <p className="mt-2 text-3xl font-bold text-blue-600">{stats.totalUsers}</p>
          <p className="mt-1 text-sm text-gray-500">Platform users</p>
        </Card>

        <Card className="p-6 bg-yellow-50">
          <h3 className="text-lg font-medium text-gray-900">Pending Stands</h3>
          <p className="mt-2 text-3xl font-bold text-yellow-600">{stats.pendingStands}</p>
          <p className="mt-1 text-sm text-gray-500">Awaiting approval</p>
        </Card>

        <Card className="p-6 bg-purple-50">
          <h3 className="text-lg font-medium text-gray-900">Pending Products</h3>
          <p className="mt-2 text-3xl font-bold text-purple-600">{stats.pendingProducts}</p>
          <p className="mt-1 text-sm text-gray-500">Awaiting review</p>
        </Card>

        <Card className="p-6 bg-red-50">
          <h3 className="text-lg font-medium text-gray-900">Reported Reviews</h3>
          <p className="mt-2 text-3xl font-bold text-red-600">{stats.reportedReviews}</p>
          <p className="mt-1 text-sm text-gray-500">Need attention</p>
        </Card>
      </div>

      <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
        <Card className="p-6">
          <h3 className="text-lg font-medium text-gray-900">Quick Actions</h3>
          <div className="mt-4 space-y-4">
            <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
              <Button
                variant="outline"
                className="w-full justify-start space-x-2"
                onClick={() => router.push('/admin/users')}
              >
                <span>View All Users</span>
              </Button>

              <Button
                variant="outline"
                className="w-full justify-start space-x-2"
                onClick={() => router.push('/admin/analytics')}
              >
                <span>View Analytics</span>
              </Button>

              <Button
                variant="outline"
                className="w-full justify-start space-x-2 text-yellow-600"
                onClick={() => router.push('/admin/market-stand/pending')}
              >
                <span>Review Pending Stands</span>
                {stats.pendingStands > 0 && (
                  <span className="ml-auto rounded-full bg-yellow-100 px-2 py-0.5 text-xs">
                    {stats.pendingStands}
                  </span>
                )}
              </Button>

              <Button
                variant="outline"
                className="w-full justify-start space-x-2 text-purple-600"
                onClick={() => router.push('/admin/products/pending')}
              >
                <span>Review Pending Products</span>
                {stats.pendingProducts > 0 && (
                  <span className="ml-auto rounded-full bg-purple-100 px-2 py-0.5 text-xs">
                    {stats.pendingProducts}
                  </span>
                )}
              </Button>

              <Button
                variant="outline"
                className="w-full justify-start space-x-2 text-red-600"
                onClick={() => router.push('/admin/reviews/reported')}
              >
                <span>Review Reported Reviews</span>
                {stats.reportedReviews > 0 && (
                  <span className="ml-auto rounded-full bg-red-100 px-2 py-0.5 text-xs">
                    {stats.reportedReviews}
                  </span>
                )}
              </Button>

              <Button
                variant="outline"
                className="w-full justify-start space-x-2"
                onClick={() => router.push('/admin/settings')}
              >
                <span>Platform Settings</span>
              </Button>
            </div>
          </div>
        </Card>

        <Card className="p-6">
          <h3 className="text-lg font-medium text-gray-900">Recent Activity</h3>
          <div className="mt-4 space-y-4">
            {activities.length === 0 ? (
              <p className="text-sm text-gray-500">No recent activity</p>
            ) : (
              <div className="space-y-4">
                {activities.map((activity, index) => (
                  <div key={index} className="flex items-start space-x-3">
                    <div className={cn(
                      "mt-0.5 w-2 h-2 rounded-full",
                      activity.type === 'stand' ? 'bg-yellow-500' : 'bg-purple-500'
                    )} />
                    <div className="flex-1 space-y-1">
                      <p className="text-sm">
                        <span className="font-medium">{activity.name}</span>
                        {' '}status changed from{' '}
                        <span className="font-medium">{activity.oldStatus.toLowerCase()}</span>
                        {' '}to{' '}
                        <span className="font-medium">{activity.newStatus.toLowerCase()}</span>
                      </p>
                      <p className="text-xs text-gray-500">
                        by {activity.changedBy} • {new Date(activity.createdAt).toLocaleString()}
                      </p>
                      {activity.note && (
                        <p className="text-sm text-gray-600 mt-1">
                          Note: {activity.note}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Card>
      </div>
    </div>
  )
}
</file>

<file path="app/api/admin/activity/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'
import { createRouteHandlerClient } from '@/lib/supabase-route'

export async function GET() {
  try {
    // Check authentication and admin role
    const supabase = createRouteHandlerClient()
    const { data: { session } } = await supabase.auth.getSession()

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    })

    if (!user || !['ADMIN', 'SUPER_ADMIN'].includes(user.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Fetch recent activity
    const [
      recentStandStatusChanges,
      recentProductStatusChanges
    ] = await Promise.all([
      // Recent stand status changes
      prisma.standStatusHistory.findMany({
        take: 5,
        orderBy: { createdAt: 'desc' },
        include: {
          marketStand: {
            select: { name: true }
          },
          changedBy: {
            select: { firstName: true, lastName: true }
          }
        }
      }),

      // Recent product status changes
      prisma.productStatusHistory.findMany({
        take: 5,
        orderBy: { createdAt: 'desc' },
        include: {
          product: {
            select: { name: true }
          },
          changedBy: {
            select: { firstName: true, lastName: true }
          }
        }
      })
    ])

    // Combine and sort activities
    const activities = [
      ...recentStandStatusChanges.map(change => ({
        type: 'stand',
        name: change.marketStand.name,
        oldStatus: change.oldStatus,
        newStatus: change.newStatus,
        changedBy: `${change.changedBy.firstName} ${change.changedBy.lastName}`,
        note: change.note,
        createdAt: change.createdAt
      })),
      ...recentProductStatusChanges.map(change => ({
        type: 'product',
        name: change.product.name,
        oldStatus: change.oldStatus,
        newStatus: change.newStatus,
        changedBy: `${change.changedBy.firstName} ${change.changedBy.lastName}`,
        note: change.note,
        createdAt: change.createdAt
      }))
    ].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
    .slice(0, 5)

    return NextResponse.json({ activities })
  } catch (error) {
    console.error('Error fetching admin activity:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/admin/performance/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getConnectionMetrics } from '@/lib/db';
import { checkRedisHealth } from '@/lib/cache/redis';

/**
 * Performance Monitoring API Endpoint
 * Provides insights into database and cache performance
 * Requires admin authentication
 */

export async function GET(request: NextRequest) {
  try {
    // TODO: Add admin authentication check here
    // const session = await getServerSession();
    // if (!session || session.user.role !== 'ADMIN') {
    //   return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    // }

    const [dbMetrics, redisHealthy] = await Promise.all([
      getConnectionMetrics(),
      checkRedisHealth(),
    ]);

    const performanceData = {
      timestamp: new Date().toISOString(),
      database: {
        metrics: dbMetrics,
        status: dbMetrics ? 'healthy' : 'degraded',
      },
      cache: {
        redis: {
          status: redisHealthy ? 'healthy' : 'unhealthy',
        },
      },
      recommendations: generateRecommendations(dbMetrics, redisHealthy),
    };

    return NextResponse.json(performanceData);
  } catch (error) {
    console.error('Performance monitoring error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch performance metrics' },
      { status: 500 }
    );
  }
}

/**
 * Generate performance recommendations based on metrics
 */
function generateRecommendations(
  dbMetrics: any,
  redisHealthy: boolean
): string[] {
  const recommendations: string[] = [];

  if (!redisHealthy) {
    recommendations.push('Redis cache is unhealthy. Check connection configuration.');
  }

  if (!dbMetrics) {
    recommendations.push('Unable to retrieve database metrics. Monitoring may be disabled.');
  }

  // Add more sophisticated recommendations based on actual metrics
  if (dbMetrics?.counters) {
    const queryCount = dbMetrics.counters['prisma_client_queries_total'];
    if (queryCount > 10000) {
      recommendations.push('High query volume detected. Consider implementing more aggressive caching.');
    }
  }

  if (recommendations.length === 0) {
    recommendations.push('All systems operating normally.');
  }

  return recommendations;
}
</file>

<file path="app/api/admin/stats/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'
import { createRouteHandlerClient } from '@/lib/supabase-route'

export async function GET() {
  try {
    // Check authentication and admin role
    const supabase = createRouteHandlerClient()
    const { data: { session } } = await supabase.auth.getSession()

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    })

    if (!user || !['ADMIN', 'SUPER_ADMIN'].includes(user.role)) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Fetch dashboard statistics
    const [
      totalUsers,
      pendingStands,
      pendingProducts,
      reportedReviews
    ] = await Promise.all([
      // Total users
      prisma.user.count(),

      // Pending stands (those awaiting approval)
      prisma.marketStand.count({
        where: {
          status: 'PENDING',
          isActive: true
        }
      }),

      // Pending products (those awaiting review)
      prisma.product.count({
        where: {
          status: 'PENDING',
          isActive: true
        }
      }),

      // Reported reviews (those flagged for attention)
      Promise.all([
        prisma.productReview.count({
          where: {
            reportCount: { gt: 0 },
            isVisible: true
          }
        }),
        prisma.standReview.count({
          where: {
            reportCount: { gt: 0 },
            isVisible: true
          }
        })
      ]).then(([productReviews, standReviews]) => productReviews + standReviews)
    ])

    return NextResponse.json({
      totalUsers,
      pendingStands,
      pendingProducts,
      reportedReviews
    })
  } catch (error) {
    console.error('Error fetching admin stats:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/auth/admin/route.ts">
import { createRouteHandlerClient } from '@/lib/supabase-route'
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'

export async function POST(request: Request) {
  try {
    const { email, password } = await request.json()
    const supabase = createRouteHandlerClient()

    // Sign in user
    const { data: { session }, error } = await supabase.auth.signInWithPassword({
      email,
      password
    })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 401 })
    }

    if (!session?.user) {
      return NextResponse.json({ error: 'No session found' }, { status: 401 })
    }

    // Check if user is admin
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    })

    if (!user || !['ADMIN', 'SUPER_ADMIN'].includes(user.role)) {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 })
    }

    // Set auth cookie
    const response = NextResponse.json({ 
      success: true,
      user: {
        id: session.user.id,
        email: session.user.email,
        role: user.role
      }
    })

    const projectRef = process.env.NEXT_PUBLIC_SUPABASE_URL!.match(/(?:\/\/|^)(.*?)\.supabase/)?.[1];
    if (!projectRef) throw new Error('Could not determine project ref');

    response.cookies.set(`sb-${projectRef}-auth-token`, JSON.stringify({
      access_token: session.access_token,
      refresh_token: session.refresh_token,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      expires_in: 3600,
      token_type: 'bearer',
      user: session.user
    }), {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge: 60 * 60 // 1 hour
    });

    return response
  } catch (error) {
    console.error('Admin auth error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
</file>

<file path="app/api/auth/callback/route.ts">
export const dynamic = 'force-dynamic';

import { createRouteHandlerClient } from '@/lib/supabase-route';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  try {
    const requestUrl = new URL(request.url);
    const code = requestUrl.searchParams.get('code');
    const returnTo = requestUrl.searchParams.get('returnTo');

    console.log('[Auth Callback] Processing with code:', code ? 'present' : 'missing');
    console.log('[Auth Callback] Return path:', returnTo || 'default');

    if (!code) {
      console.error('[Auth Callback] No code provided');
      return NextResponse.redirect(new URL('/', requestUrl.origin));
    }

    const supabase = createRouteHandlerClient();
    
    // Exchange the code for a session
    const { error } = await supabase.auth.exchangeCodeForSession(code);

    if (error) {
      console.error('[Auth Callback] Session exchange error:', error);
      return NextResponse.redirect(new URL('/', requestUrl.origin));
    }

    // Get the session to confirm it was set
    const { data: { session } } = await supabase.auth.getSession();
    console.log('[Auth Callback] Session established:', session ? 'yes' : 'no');

    // Only redirect to protected routes if we have a session
    if (session) {
      const redirectPath = returnTo || '/dashboard/market-stand';
      console.log('[Auth Callback] Redirecting to:', redirectPath);
      return NextResponse.redirect(new URL(redirectPath, requestUrl.origin));
    } else {
      console.log('[Auth Callback] No session, redirecting to home');
      return NextResponse.redirect(new URL('/', requestUrl.origin));
    }
  } catch (error) {
    console.error('[Auth Callback] Error:', error);
    return NextResponse.redirect(new URL('/', request.url));
  }
}
</file>

<file path="app/api/auth/creation/route.ts">
import prisma from "@/lib/db";
import { getSupabaseServer } from '@/lib/supabase-server';
import { NextResponse } from "next/server";
import { unstable_noStore as noStore } from "next/cache";

export async function GET(request: Request) {
  noStore();
  const supabase = getSupabaseServer();
  const { data: { session } } = await supabase.auth.getSession();

  if (!session?.user) {
    throw new Error("Not authenticated");
  }

  const user = session.user;

  let dbUser = await prisma.user.findUnique({
    where: {
      id: user.id,
    },
  });

  if (!dbUser) {
    // Create user without Stripe integration for now
    dbUser = await prisma.user.create({
      data: {
        id: user.id,
        firstName: user.user_metadata?.name?.split(' ')[0] ?? "",
        lastName: user.user_metadata?.name?.split(' ')[1] ?? "",
        email: user.email ?? "",
        profileImage:
          user.user_metadata?.avatar_url ?? `https://avatar.vercel.sh/${user.user_metadata?.name?.split(' ')[0]}`,
        connectedAccountId: null,
        stripeConnectedLinked: false,
      },
    });
  }

  // Use the NEXT_PUBLIC_APP_URL from env or fallback to request origin
  const response = NextResponse.redirect(
    process.env.NEXT_PUBLIC_APP_URL || new URL(request.url).origin
  );


  return response;
}
</file>

<file path="app/api/auth/storage-token/route.ts">
import { createServerSupabaseClient } from "@/lib/auth";
import { getUser } from "@/lib/auth";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    const user = await getUser();
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const supabase = createServerSupabaseClient();

    // Create a scoped token that only allows uploads to the user's directory
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    if (sessionError || !session) {
      return new NextResponse("Session error", { status: 401 });
    }

    // Get storage bucket policy
    const { data, error } = await supabase.storage
      .from('products')
      .createSignedUrl(`${user.id}/upload-policy`, 60); // 60 seconds expiry

    if (error) {
      return new NextResponse("Failed to create upload policy", { status: 500 });
    }

    return NextResponse.json({
      url: data.signedUrl,
      path: `${user.id}/upload-policy`
    });
  } catch {
    return new NextResponse("Internal server error", { status: 500 });
  }
}
</file>

<file path="app/api/auth/sync/route.ts">
import { getSupabaseServer } from '@/lib/supabase-server';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';

export async function POST(request: Request) {
  try {
    const { event, session } = await request.json();
    
    // Get server client
    const supabase = getSupabaseServer();

    // Common headers for all responses
    const headers = {
      'Content-Type': 'application/json',
      'Cache-Control': 'private, no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0'
    };
    
    if (event === 'SIGNED_IN' || event === 'INITIAL' || event === 'TOKEN_REFRESHED') {
      // Set the session cookie
      const response = new NextResponse(JSON.stringify({ 
        status: 'success',
        event,
        timestamp: Date.now()
      }), {
        status: 200,
        headers
      });
      
      // Set auth cookie
      if (session) {
        // Explicitly set the session with the provided session data
        await supabase.auth.setSession({
          access_token: session.access_token,
          refresh_token: session.refresh_token
        });
      }
      
      return response;
    }
    
    if (event === 'SIGNED_OUT') {
      // Clear the session cookie
      const response = new NextResponse(JSON.stringify({ 
        status: 'success',
        event,
        timestamp: Date.now()
      }), {
        status: 200,
        headers
      });
      
      // Sign out to clear the session
      await supabase.auth.signOut();
      
      return response;
    }
    
    return new NextResponse(JSON.stringify({ 
      status: 'ignored',
      event,
      timestamp: Date.now()
    }), {
      status: 200,
      headers
    });
    
  } catch (error) {
    console.error('Auth sync error:', error);
    return new NextResponse(JSON.stringify({ 
      error: 'Internal Server Error',
      timestamp: Date.now()
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-store'
      }
    });
  }
}
</file>

<file path="app/api/local/[id]/products/route.ts">
import { NextResponse } from "next/server";
import { getLocalProducts } from "@/app/actions/local-products";

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const products = await getLocalProducts(params.id);
    return NextResponse.json(products);
  } catch (error) {
    console.error('Failed to fetch local products:', error);
    return NextResponse.json(
      { error: 'Failed to fetch local products' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/market-stand/[id]/products/route.ts">
import { NextResponse } from "next/server";
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getUser();
    
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // Verify market stand ownership
    const marketStand = await prisma.marketStand.findUnique({
      where: {
        id: params.id,
        userId: user.id,
      },
    });

    if (!marketStand) {
      return new NextResponse("Not Found", { status: 404 });
    }

    // Get products for the market stand
    const products = await prisma.product.findMany({
      where: {
        marketStandId: params.id,
      },
      select: {
        id: true,
        name: true,
        price: true,
        images: true,
        inventory: true,
        updatedAt: true,
      },
    });

    // Format products for response
    const formattedProducts = products.map(product => ({
      id: product.id,
      name: product.name,
      price: product.price,
      image: product.images[0] || '', // Use first image or empty string
      quantity: product.inventory || 0,
      updatedAt: product.updatedAt,
    }));

    return NextResponse.json(formattedProducts);
  } catch (error) {
    console.error('[MARKET_STAND_PRODUCTS_GET]', error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/market-stand/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import prisma from "lib/db";
import { 
  MarketStandDetailResponse,
  ErrorResponse, 
  detailViewSelect,
  DetailedProduct,
  ValidationErrorResponse 
} from "../types";
import { 
  createErrorResponse, 
  validateMarketStandId
} from "../utils";
import { Prisma } from "@prisma/client";
import { safeValidateMarketStandInput } from "../validation";

// Type for raw Prisma response
type PrismaMarketStand = Prisma.MarketStandGetPayload<{
  select: typeof detailViewSelect;
}>;

/**
 * Transforms a Prisma product to match our API response type
 */
function transformProduct(product: PrismaMarketStand["products"][0]): DetailedProduct {
  return {
    ...product,
    createdAt: product.createdAt.toISOString(),
    updatedAt: product.updatedAt.toISOString(),
    inventoryUpdatedAt: product.inventoryUpdatedAt?.toISOString() ?? null,
    status: product.status.toString(),
  };
}

/**
 * Transforms Prisma response to match our API response type
 */
function transformMarketStandResponse(
  stand: PrismaMarketStand
): MarketStandDetailResponse {
  return {
    ...stand,
    createdAt: stand.createdAt.toISOString(),
    products: stand.products.map(transformProduct),
    user: {
      id: stand.user.id,
      firstName: stand.user.firstName,
      lastName: stand.user.lastName,
      profileImage: stand.user.profileImage
    }
  };
}

export const GET = async (
  req: Request,
  { params }: { params: { id: string } }
) => {
const { id } = params;

  try {
    const marketStand = await prisma.marketStand.findUnique({
      where: { id },
      select: detailViewSelect
    });

    if (!marketStand) {
      return new NextResponse(
        JSON.stringify({ error: "Market stand not found" }), 
        { status: 404 }
      );
    }

    const response = transformMarketStandResponse(marketStand);
    return NextResponse.json(response);
  } catch (error) {
    return createErrorResponse(error);
  }
};

/**
 * Updates a market stand by ID
 */
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
): Promise<NextResponse<MarketStandDetailResponse | ErrorResponse | ValidationErrorResponse>> {
  try {
    // Validate ID format
    if (!validateMarketStandId(params.id)) {
      throw new Error("Invalid market stand ID format");
    }

    // Parse and validate request body
    const body = await request.json();
    const validationResult = safeValidateMarketStandInput(body);
    
    if (!validationResult.success) {
      const validationError: ValidationErrorResponse = {
        error: "Validation error",
        details: validationResult.error.formErrors
      };
      return NextResponse.json(validationError, { status: 400 });
    }

    // Update market stand with validated data
    const updatedStand = await prisma.marketStand.update({
      where: { id: params.id },
      data: {
        name: validationResult.data.name,
        description: validationResult.data.description,
        images: validationResult.data.images,
        latitude: validationResult.data.latitude,
        longitude: validationResult.data.longitude,
        locationName: validationResult.data.locationName,
        locationGuide: validationResult.data.locationGuide,
        tags: validationResult.data.tags
      },
      select: detailViewSelect
    });

    // Transform and return response
    return NextResponse.json(transformMarketStandResponse(updatedStand));
  } catch (error) {
    return createErrorResponse(error);
  }
}

export const DELETE = async (
  req: Request,
  { params }: { params: { id: string } }
) => {
const { id } = params;

  try {
    await prisma.marketStand.delete({
      where: { id }
    });
 
    return NextResponse.json({ success: true });
  } catch (error) {
    return createErrorResponse(error);
  }
 };
</file>

<file path="app/api/market-stand/route.ts">
import { NextResponse } from "next/server";
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";

export async function GET() {
  try {
    const user = await getUser();
    
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const marketStands = await prisma.marketStand.findMany({
      where: {
        userId: user.id,
      },
      select: {
        id: true,
        name: true,
        description: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        images: true,
        tags: true,
        _count: {
          select: {
            products: true,
          },
        },
        products: {
          orderBy: {
            updatedAt: 'desc',
          },
          take: 1,
          select: {
            updatedAt: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    // Ensure data is serializable
    const serializedStands = marketStands.map(stand => ({
      ...stand,
      description: stand.description || null,
      tags: stand.tags || [],
      _count: {
        products: stand._count.products
      },
      lastProductUpdate: stand.products[0]?.updatedAt || null,
      products: undefined // Remove products array from response
    }));

    return NextResponse.json(serializedStands);
  } catch (error) {
    console.error('[MARKET_STAND_GET]', error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/market-stand/types.ts">
import { Prisma } from "@prisma/client";
import { z } from "zod";

/**
 * Base market stand properties
 */
export interface BaseMarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  createdAt: string;
  tags: string[];
  website: string | null;
  socialMedia: string[];
}

/**
 * Product properties for market stand responses
 */
export interface MarketStandProduct {
  id: string;
  name: string;
  description: string;
  price: number;
  images: string[];
  createdAt: string;
  updatedAt: string;
}

/**
 * Extended product properties for detailed views
 */
export interface DetailedProduct extends MarketStandProduct {
  inventory: number;
  inventoryUpdatedAt: string | null;
  status: string;
  isActive: boolean;
  tags: string[];
  averageRating: number | null;
  totalReviews: number;
}

/**
 * User properties for market stand responses
 */
export interface MarketStandUser {
  firstName: string;
  profileImage: string;
}

/**
 * Extended user properties for detailed views
 */
export interface DetailedUser extends MarketStandUser {
  id: string;
  lastName: string;
}

/**
 * Market stand response for list view
 */
export interface MarketStandListResponse extends BaseMarketStand {
  products: MarketStandProduct[];
  user: MarketStandUser;
}

/**
 * Market stand response for detailed view
 */
export interface MarketStandDetailResponse extends BaseMarketStand {
  products: DetailedProduct[];
  user: DetailedUser;
}

/**
 * Base error response structure
 */
export interface ErrorResponse {
  error: string;
  details?: unknown;
}

/**
 * Validation error response structure
 */
export interface ValidationErrorResponse extends ErrorResponse {
  error: "Validation error";
  details: z.ZodError["formErrors"];
}

/**
 * Type guard for validation error response
 */
export function isValidationError(error: unknown): error is ValidationErrorResponse {
  return (
    typeof error === "object" &&
    error !== null &&
    "error" in error &&
    error.error === "Validation error" &&
    "details" in error
  );
}

/**
 * Prisma select object for list view
 */
export const listViewSelect = {
  id: true,
  name: true,
  description: true,
  images: true,
  latitude: true,
  longitude: true,
  locationName: true,
  locationGuide: true,
  createdAt: true,
  tags: true,
  website: true,
  socialMedia: true,
  products: {
    select: {
      id: true,
      name: true,
      description: true,
      price: true,
      images: true,
      createdAt: true,
      updatedAt: true
    }
  },
  user: {
    select: {
      firstName: true,
      profileImage: true
    }
  }
} satisfies Prisma.MarketStandSelect;

/**
 * Prisma select object for detailed view
 */
export const detailViewSelect = {
  id: true,
  name: true,
  description: true,
  images: true,
  latitude: true,
  longitude: true,
  locationName: true,
  locationGuide: true,
  createdAt: true,
  tags: true,
  website: true,
  socialMedia: true,
  products: {
    select: {
      id: true,
      name: true,
      description: true,
      price: true,
      images: true,
      inventory: true,
      inventoryUpdatedAt: true,
      status: true,
      isActive: true,
      createdAt: true,
      updatedAt: true,
      tags: true,
      averageRating: true,
      totalReviews: true
    }
  },
  user: {
    select: {
      id: true,
      firstName: true,
      lastName: true,
      profileImage: true
    }
  }
} satisfies Prisma.MarketStandSelect;
</file>

<file path="app/api/market-stand/utils.ts">
import { NextResponse } from "next/server";
import { Prisma } from "@prisma/client";
import { ErrorResponse } from "./types";

/**
 * Serializes Date objects to ISO strings in an object
 */
export function serializeDates<T extends Record<string, unknown>>(obj: T): T {
  const serialized = { ...obj } as T;
  
  for (const [key, value] of Object.entries(obj)) {
    if (value instanceof Date) {
      (serialized as Record<string, unknown>)[key] = value.toISOString();
    } else if (Array.isArray(value)) {
      (serialized as Record<string, unknown>)[key] = value.map(item => 
        typeof item === 'object' && item !== null ? serializeDates(item) : item
      );
    } else if (typeof value === 'object' && value !== null) {
      (serialized as Record<string, unknown>)[key] = serializeDates(value as Record<string, unknown>);
    }
  }
  
  return serialized;
}

/**
 * Creates a standardized error response
 */
export function createErrorResponse(
  error: unknown,
  defaultMessage = "An unexpected error occurred"
): NextResponse<ErrorResponse> {
  // Handle Prisma errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    return NextResponse.json(
      {
        error: "Database error",
        details: error.message
      },
      { status: 400 }
    );
  }

  // Handle not found errors
  if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === "P2025") {
    return NextResponse.json(
      { error: "Resource not found" },
      { status: 404 }
    );
  }

  // Handle validation errors
  if (error instanceof Prisma.PrismaClientValidationError) {
    return NextResponse.json(
      {
        error: "Validation error",
        details: error.message
      },
      { status: 400 }
    );
  }

  // Handle generic errors
  const statusCode = error instanceof Error && 
    'statusCode' in error ? 
    (error as Error & { statusCode: number }).statusCode : 
    500;

  return NextResponse.json(
    {
      error: error instanceof Error ? error.message : defaultMessage,
      details: process.env.NODE_ENV === "development" ? error : undefined
    },
    { status: statusCode }
  );
}

/**
 * Validates market stand ID format
 */
export function validateMarketStandId(id: string): boolean {
  // Add any specific ID format validation logic here
  return typeof id === "string" && id.length > 0;
}

/**
 * Wraps an async route handler with error handling
 */
export function withErrorHandling<T, E = ErrorResponse>(
  handler: () => Promise<NextResponse<T>>
): Promise<NextResponse<T | E>> {
  return handler().catch(error => createErrorResponse(error) as NextResponse<E>);
}

/**
 * Type guard to check if response is an error
 */
export function isErrorResponse(response: unknown): response is ErrorResponse {
  return typeof response === "object" && 
    response !== null && 
    "error" in response;
}
</file>

<file path="app/api/market-stand/validation.ts">
import { z } from "zod";

/**
 * Schema for market stand creation/update
 */
export const marketStandSchema = z.object({
  name: z.string()
    .min(3, "Name must be at least 3 characters long")
    .max(100, "Name must be less than 100 characters"),
  
  description: z.string()
    .min(10, "Description must be at least 10 characters long")
    .max(1000, "Description must be less than 1000 characters")
    .nullable(),
  
  images: z.array(z.string().url("Invalid image URL"))
    .min(1, "At least one image is required")
    .max(10, "Maximum of 10 images allowed"),
  
  latitude: z.number()
    .min(-90, "Latitude must be between -90 and 90")
    .max(90, "Latitude must be between -90 and 90"),
  
  longitude: z.number()
    .min(-180, "Longitude must be between -180 and 180")
    .max(180, "Longitude must be between -180 and 180"),
  
  locationName: z.string()
    .min(3, "Location name must be at least 3 characters long")
    .max(100, "Location name must be less than 100 characters"),
  
  locationGuide: z.string()
    .min(10, "Location guide must be at least 10 characters long")
    .max(500, "Location guide must be less than 500 characters"),
  
  tags: z.array(z.string())
    .max(10, "Maximum of 10 tags allowed")
    .optional()
    .default([]),
    
  website: z.string()
    .url("Website must be a valid URL")
    .optional()
    .nullable(),
    
  socialMedia: z.array(z.string().url("Social media links must be valid URLs"))
    .max(5, "Maximum of 5 social media links allowed")
    .optional()
    .default([]),
  
  userId: z.string()
    .min(1, "User ID is required")
});

/**
 * Type for validated market stand input
 */
export type MarketStandInput = z.infer<typeof marketStandSchema>;

/**
 * Validates market stand input data
 */
export function validateMarketStandInput(data: unknown): MarketStandInput {
  return marketStandSchema.parse(data);
}

/**
 * Safely validates market stand input data, returning errors if invalid
 */
export function safeValidateMarketStandInput(data: unknown) {
  return marketStandSchema.safeParse(data);
}
</file>

<file path="app/api/product/[id]/quantity/route.ts">
import { NextResponse } from "next/server";
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const user = await getUser();
    
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const body = await request.json();
    const { quantity } = body;

    if (typeof quantity !== 'number' || quantity < 0) {
      return new NextResponse("Invalid quantity", { status: 400 });
    }

    // Verify product ownership through market stand
    const product = await prisma.product.findFirst({
      where: {
        id: params.id,
        marketStand: {
          userId: user.id,
        },
      },
      include: {
        marketStand: true,
      },
    });

    if (!product) {
      return new NextResponse("Not Found", { status: 404 });
    }

    // Update product inventory
    const updatedProduct = await prisma.product.update({
      where: {
        id: params.id,
      },
      data: {
        inventory: quantity,
        inventoryUpdatedAt: new Date(),
      },
      select: {
        id: true,
        name: true,
        price: true,
        images: true,
        inventory: true,
      },
    });

    // Format response
    const formattedProduct = {
      id: updatedProduct.id,
      name: updatedProduct.name,
      price: updatedProduct.price,
      image: updatedProduct.images[0] || '',
      quantity: updatedProduct.inventory || 0,
    };

    return NextResponse.json(formattedProduct);
  } catch (error) {
    console.error('[PRODUCT_QUANTITY_UPDATE]', error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/product/inventory/route.ts">
import { NextResponse } from "next/server";
import { UpdateInventory } from "@/app/actions";

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const result = await UpdateInventory({ status: undefined, message: null }, formData);
    
    if (!result.ok) {
      const data = await result.json();
      return NextResponse.json({ error: data.error }, { status: result.status });
    }

    return NextResponse.json({ success: true });
  } catch (err) {
    return NextResponse.json(
      { 
        error: "Failed to update inventory",
        details: err instanceof Error ? err.message : "Unknown error"
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/product/route.ts">
import prisma from "@/lib/db";
import { NextResponse } from "next/server";
import { getUser } from "@/lib/auth";

export async function PATCH(req: Request) {
  try {
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const body = await req.json();
    const { id, inventory } = body;

    if (!id || typeof inventory !== 'number') {
      return new NextResponse("Invalid request data", { status: 400 });
    }

    // Check if product exists and belongs to user
    const product = await prisma.product.findUnique({
      where: {
        id,
        userId: user.id
      }
    });

    if (!product) {
      return new NextResponse("Product not found or unauthorized", { status: 404 });
    }

    // Update product inventory with user check
    const updatedProduct = await prisma.product.update({
      where: {
        id,
        userId: user.id // Ensure user owns the product
      },
      data: {
        inventory,
        inventoryUpdatedAt: new Date()
      }
    });

    return NextResponse.json(updatedProduct);
  } catch {
    return new NextResponse("Internal error", { status: 500 });
  }
}

export async function PUT(req: Request) {
  try {
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const body = await req.json();
    const { id, ...updateData } = body;

    if (!id) {
      return new NextResponse("Invalid request data", { status: 400 });
    }

    // Check if product exists and belongs to user
    const product = await prisma.product.findUnique({
      where: {
        id,
        userId: user.id
      }
    });

    if (!product) {
      return new NextResponse("Product not found or unauthorized", { status: 404 });
    }

    // Update product with user check
    const updatedProduct = await prisma.product.update({
      where: {
        id,
        userId: user.id // Ensure user owns the product
      },
      data: {
        ...updateData,
        updatedAt: new Date()
      }
    });

    return NextResponse.json(updatedProduct);
  } catch {
    return new NextResponse("Internal error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/connect/success/route.ts">
import { NextResponse } from "next/server";
import prisma from "../../../../../lib/db";
import { getUser } from "@/lib/auth";

export async function GET() {
  try {
    // 1. Verify user authentication
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // 2. Verify environment variables
    if (!process.env.NEXT_PUBLIC_APP_URL) {
      return new NextResponse("Server configuration error", { status: 500 });
    }

    // 3. Update user's Stripe connection status
    try {
      const updatedUser = await prisma.user.update({
        where: { id: user.id },
        data: { stripeConnectedLinked: true },
        select: { connectedAccountId: true }
      });

      if (!updatedUser.connectedAccountId) {
        return new NextResponse("Invalid account state", { status: 400 });
      }

      // 4. Redirect back to dashboard with success message
      const redirectUrl = new URL(`${process.env.NEXT_PUBLIC_APP_URL}/dashboard`);
      redirectUrl.searchParams.set("stripe", "success");
      
      return NextResponse.redirect(redirectUrl.toString());
    } catch {
      return new NextResponse("Failed to update account status", { status: 500 });
    }
  } catch {
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/connect/route.ts">
import { stripe } from "@/lib/stripe";
import { NextResponse } from "next/server";
import prisma from "@/lib/db";
import Stripe from "stripe";
import { getUser } from "@/lib/auth";

export async function POST() {
  try {
    // 1. Verify user authentication
    const user = await getUser();

    if (!user || !user.id) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    // 2. Check if user already has a Stripe account
    try {
      const existingUser = await prisma.user.findUnique({
        where: { id: user.id },
        select: { connectedAccountId: true }
      });

      if (existingUser?.connectedAccountId) {
        return new NextResponse("Stripe account already connected", { status: 400 });
      }
    } catch {
      return new NextResponse("Database error", { status: 500 });
    }

    // 3. Verify environment variables
    if (!process.env.NEXT_PUBLIC_APP_URL) {
      return new NextResponse("Server configuration error", { status: 500 });
    }

    // 4. Create Stripe Connect account
    let account: Stripe.Response<Stripe.Account>;
    try {
      account = await stripe.accounts.create({
        type: "express",
        country: "US",
        email: user.email || undefined,
        capabilities: {
          card_payments: { requested: true },
          transfers: { requested: true },
        },
        tos_acceptance: {
          service_agreement: 'recipient'
        }
      });
    } catch {
      return new NextResponse("Failed to create Stripe account", { status: 500 });
    }

    // 5. Update user with connected account ID
    try {
      await prisma.user.update({
        where: { id: user.id },
        data: { connectedAccountId: account.id }
      });
    } catch {
      // Try to clean up the created Stripe account
      try {
        await stripe.accounts.del(account.id);
      } catch {
        // If cleanup fails, we still want to return the error for the update operation
      }
      return new NextResponse("Failed to update user record", { status: 500 });
    }

    // 6. Create account link for onboarding
    try {
      const accountLink = await stripe.accountLinks.create({
        account: account.id,
        refresh_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/market-stand/setup`,
        return_url: `${process.env.NEXT_PUBLIC_APP_URL}/api/stripe/connect/success`,
        type: "account_onboarding",
      });

      return NextResponse.json({ url: accountLink.url });
    } catch {
      return new NextResponse("Failed to create onboarding link", { status: 500 });
    }
  } catch {
    return new NextResponse("Internal Error", { status: 500 });
  }
}
</file>

<file path="app/api/stripe/route.ts">
import ProductEmail from "@/components/ProductEmail";
import { stripe } from "@/lib/stripe";
import { headers } from "next/headers";
import { Resend } from "resend";

// Only initialize Resend if API key is available
const resend = process.env.RESEND_API_KEY ? new Resend(process.env.RESEND_API_KEY) : null;

export async function POST(req: Request) {
  const body = await req.text();

  const signature = headers().get("Stripe-Signature") as string;

  let event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_SECRET_WEBHOOK as string
    );
  } catch (err: unknown) {
    const errorMessage = err instanceof Error ? err.message : "webhook error";
    return new Response(errorMessage, { status: 400 });
  }

  switch (event.type) {
    case "checkout.session.completed": {
      const session = event.data.object;

      const link = session.metadata?.link;

      // Only attempt to send email if Resend is initialized
      if (resend) {
        await resend.emails.send({
          from: "MarshalUI <onboarding@resend.dev>",
          to: ["your_email"],
          subject: "Your Product from MarshalUI",
          react: ProductEmail({
            link: link as string,
          }),
        });
      }

      break;
    }
  }

  return new Response(null, { status: 200 });
}
</file>

<file path="app/api/test/analytics/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'
import { Analytics } from '@/lib/analytics'

export async function GET() {
  try {
    // Create test market stand
    const stand = await prisma.marketStand.create({
      data: {
        name: "Test Stand",
        description: "A test market stand",
        images: [],
        tags: ["test"],
        latitude: 37.7749,
        longitude: -122.4194,
        locationName: "San Francisco",
        locationGuide: "Test location",
        isActive: true,
        userId: "test-user", // You'll need to replace this with a real user ID
        metrics: {
          create: {
            dailyMetrics: {
              create: Array.from({ length: 30 }).map((_, i) => ({
                date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000),
                orders: Math.floor(Math.random() * 20),
                revenue: Math.floor(Math.random() * 10000),
                views: Math.floor(Math.random() * 100),
                uniqueViews: Math.floor(Math.random() * 50)
              }))
            }
          }
        }
      }
    })

    // Track the event in PostHog
    Analytics.track('test_data_created', {
      standId: stand.id
    })

    return NextResponse.json({ success: true, stand })
  } catch (error) {
    console.error('Error creating test data:', error)
    return NextResponse.json({ error: 'Failed to create test data' }, { status: 500 })
  }
}
</file>

<file path="app/api/test/auth-setup/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'
import { Analytics } from '@/lib/analytics'
import { createRouteHandlerClient } from '@/lib/supabase-route'
import { createClient } from '@supabase/supabase-js'
import { Status } from '@prisma/client'

const TEST_USER_EMAIL = 'test@example.com'
const TEST_USER_PASSWORD = 'test123456'

export async function GET() {
  try {
    const supabase = createRouteHandlerClient()

    // Create or sign in user with admin client
    const adminClient = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )

    // Try to sign in first
    let { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
      email: TEST_USER_EMAIL,
      password: TEST_USER_PASSWORD
    })

    // If user doesn't exist, create one
    if (signInError && signInError.message.includes('Invalid login credentials')) {
      // Create user with admin role
      const { data: createData, error: createError } = await adminClient.auth.admin.createUser({
        email: TEST_USER_EMAIL,
        password: TEST_USER_PASSWORD,
        email_confirm: true,
        user_metadata: {
          first_name: 'Test',
          last_name: 'User',
          role: 'ADMIN'
        }
      })

      if (createError) {
        throw createError
      }

      // Sign in with the newly created user
      const { data: newSignInData, error: newSignInError } = await supabase.auth.signInWithPassword({
        email: TEST_USER_EMAIL,
        password: TEST_USER_PASSWORD
      })

      if (newSignInError) {
        throw newSignInError
      }

      signInData = newSignInData
    } else if (signInError) {
      throw signInError
    }

    if (!signInData.user) {
      throw new Error('Failed to create or retrieve user')
    }

    // Update user metadata in Supabase
    await adminClient.auth.admin.updateUserById(
      signInData.user.id,
      {
        user_metadata: {
          role: 'ADMIN',
          firstName: 'Test',
          lastName: 'User'
        }
      }
    )

    // Create or update user in our database with admin role
    const user = await prisma.user.upsert({
      where: { id: signInData.user.id },
      update: {
        role: 'ADMIN',
        firstName: 'Test',
        lastName: 'User',
        profileImage: 'https://via.placeholder.com/150'
      },
      create: {
        id: signInData.user.id,
        email: TEST_USER_EMAIL,
        firstName: 'Test',
        lastName: 'User',
        profileImage: 'https://via.placeholder.com/150',
        role: 'ADMIN'
      }
    })

    // Ensure user metadata is up to date
    await adminClient.auth.admin.updateUserById(
      signInData.user.id,
      {
        user_metadata: {
          first_name: 'Test',
          last_name: 'User',
          role: 'ADMIN'
        }
      }
    )

    // Refresh session to include updated metadata
    const { data: { session: refreshedSession } } = await supabase.auth.refreshSession()
    if (refreshedSession) {
      signInData.session = refreshedSession
    }

    // Refresh session to include updated metadata
    await supabase.auth.refreshSession()

    // Create test market stand
    const stand = await prisma.marketStand.create({
      data: {
        name: "Test Farm Stand",
        description: "A test market stand for analytics",
        images: [],
        tags: ["organic", "local"],
        latitude: 37.7749,
        longitude: -122.4194,
        locationName: "San Francisco",
        locationGuide: "Test location",
        isActive: true,
        userId: user.id,
        metrics: {
          create: {
            dailyMetrics: {
              create: Array.from({ length: 30 }).map((_, i) => ({
                date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000),
                orders: Math.floor(Math.random() * 20),
                revenue: Math.floor(Math.random() * 10000),
                views: Math.floor(Math.random() * 100),
                uniqueViews: Math.floor(Math.random() * 50)
              }))
            }
          }
        }
      }
    })

    // Create test products
    const products = await Promise.all(
      Array.from({ length: 5 }).map((_, i) => 
        prisma.product.create({
          data: {
            name: `Test Product ${i + 1}`,
            price: Math.floor(Math.random() * 5000) + 500, // $5-$55
            description: `Description for test product ${i + 1}`,
            images: [],
            tags: ["test"],
            inventory: Math.floor(Math.random() * 100),
            isActive: true,
            userId: user.id,
            marketStandId: stand.id,
            status: [Status.APPROVED, Status.PENDING, Status.REJECTED][Math.floor(Math.random() * 3)]
          }
        })
      )
    )

    // Track setup in PostHog
    Analytics.track('test_auth_setup_completed', {
      userId: user.id,
      standId: stand.id,
      productCount: products.length
    })

    // Create response with session data and set cookies
    const response = NextResponse.json({ 
      success: true, 
      message: 'Test user created and authenticated',
      data: {
        email: TEST_USER_EMAIL,
        password: TEST_USER_PASSWORD,
        user,
        stand,
        products,
        session: signInData.session
      }
    })

    // Set auth cookie with session
    if (signInData.session) {
      const projectRef = process.env.NEXT_PUBLIC_SUPABASE_URL!.match(/(?:\/\/|^)(.*?)\.supabase/)?.[1];
      if (!projectRef) throw new Error('Could not determine project ref');

      // Set the session cookie using the same format as Supabase
      response.cookies.set(`sb-${projectRef}-auth-token`, JSON.stringify({
        access_token: signInData.session.access_token,
        refresh_token: signInData.session.refresh_token,
        expires_at: Math.floor(Date.now() / 1000) + 3600,
        expires_in: 3600,
        token_type: 'bearer',
        user: signInData.user
      }), {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 // 1 hour
      });

      // Also set the refresh token cookie
      response.cookies.set(`sb-${projectRef}-refresh-token`, signInData.session.refresh_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 * 30 // 30 days
      });
    }

    return response
  } catch (error) {
    console.error('Error in auth setup:', error)
    return NextResponse.json({ error: 'Failed to setup test auth' }, { status: 500 })
  }
}
</file>

<file path="app/api/test/setup/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'
import { Analytics } from '@/lib/analytics'
import { Status } from '@prisma/client'

export async function GET() {
  try {
    // Create test user
    const user = await prisma.user.create({
      data: {
        id: "test-user",
        email: "test@example.com",
        firstName: "Test",
        lastName: "User",
        profileImage: "https://via.placeholder.com/150",
        role: "USER"
      }
    })

    // Create test market stand
    const stand = await prisma.marketStand.create({
      data: {
        name: "Test Farm Stand",
        description: "A test market stand for analytics",
        images: [],
        tags: ["organic", "local"],
        latitude: 37.7749,
        longitude: -122.4194,
        locationName: "San Francisco",
        locationGuide: "Test location",
        isActive: true,
        userId: user.id,
        metrics: {
          create: {
            dailyMetrics: {
              create: Array.from({ length: 30 }).map((_, i) => ({
                date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000),
                orders: Math.floor(Math.random() * 20),
                revenue: Math.floor(Math.random() * 10000),
                views: Math.floor(Math.random() * 100),
                uniqueViews: Math.floor(Math.random() * 50)
              }))
            }
          }
        }
      }
    })

    // Create test products
    const products = await Promise.all(
      Array.from({ length: 5 }).map((_, i) => 
        prisma.product.create({
          data: {
            name: `Test Product ${i + 1}`,
            price: Math.floor(Math.random() * 5000) + 500, // $5-$55
            description: `Description for test product ${i + 1}`,
            images: [],
            tags: ["test"],
            inventory: Math.floor(Math.random() * 100),
            isActive: true,
            userId: user.id,
            marketStandId: stand.id,
            status: [Status.APPROVED, Status.PENDING, Status.REJECTED][Math.floor(Math.random() * 3)]
          }
        })
      )
    )

    // Track the setup in PostHog
    Analytics.track('test_setup_completed', {
      userId: user.id,
      standId: stand.id,
      productCount: products.length
    })

    return NextResponse.json({ 
      success: true, 
      data: {
        user,
        stand,
        products
      }
    })
  } catch (error) {
    console.error('Error creating test data:', error)
    return NextResponse.json({ error: 'Failed to create test data' }, { status: 500 })
  }
}
</file>

<file path="app/api/test-env/route.ts">
import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({
    DATABASE_URL: process.env.DATABASE_URL || 'not set',
    NODE_ENV: process.env.NODE_ENV || 'not set',
    envKeys: Object.keys(process.env),
  });
}
</file>

<file path="app/api/upload/route.ts">
import { createServerSupabaseClient } from "@/lib/auth";
import { getUser } from "@/lib/auth";
import { NextResponse } from "next/server";

// Disable body parsing, as we'll handle raw body ourselves for file uploads
export const dynamic = 'force-dynamic';

export async function POST(req: Request) {
  try {
    const user = await getUser();
    if (!user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const formData = await req.formData();
    const file = formData.get('file') as File;
    if (!file) {
      return new NextResponse("No file provided", { status: 400 });
    }

    const supabase = createServerSupabaseClient();

    // Create a buffer from the file
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Upload to user's folder with proper permissions
    const fileName = `${user.id}/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
    let uploadResult = await supabase.storage
      .from('products')
      .upload(fileName, buffer, {
        contentType: file.type,
        duplex: 'half',
        upsert: false
      });

    if (uploadResult.error) {
      if (uploadResult.error.message.includes('row-level security')) {
        // Set up bucket policy if it doesn't exist
        await supabase.storage.from('products').upload(`${user.id}/.keep`, new Uint8Array(0), {
          upsert: true
        });
        
        // Try upload again
        uploadResult = await supabase.storage
          .from('products')
          .upload(fileName, buffer, {
            contentType: file.type,
            duplex: 'half',
            upsert: false
          });
          
        if (uploadResult.error) {
          return new NextResponse(uploadResult.error.message, { status: 500 });
        }
      } else {
        return new NextResponse(uploadResult.error.message, { status: 500 });
      }
    }

    if (!uploadResult.data) {
      return new NextResponse("Failed to upload file", { status: 500 });
    }

    // Get the public URL
    const { data: urlData } = supabase.storage
      .from('products')
      .getPublicUrl(uploadResult.data.path);

    if (!urlData?.publicUrl) {
      return new NextResponse("Failed to get public URL", { status: 500 });
    }

    return NextResponse.json({ url: urlData.publicUrl });
  } catch (error) {
    return new NextResponse(
      error instanceof Error ? error.message : "Internal server error", 
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/user/route.ts">
import { createRouteHandlerClient } from '@/lib/supabase-route';
import { NextResponse } from 'next/server';

export async function GET() {
  try {
    const supabase = createRouteHandlerClient();
    
    const { data: { user }, error } = await supabase.auth.getUser();
    
    if (error || !user) {
      return new NextResponse(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
      });
    }

    // Get user's market stand ID from your database
    const { data: profile } = await supabase
      .from('profiles')
      .select('market_stand_id')
      .eq('id', user.id)
      .single();

    return NextResponse.json({
      id: user.id,
      email: user.email,
      marketStandId: profile?.market_stand_id
    });
  } catch (err) {
    return new NextResponse(JSON.stringify({ 
      error: 'Internal Server Error',
      details: err instanceof Error ? err.message : 'Unknown error'
    }), {
      status: 500,
    });
  }
}
</file>

<file path="app/auth/admin/login/page.tsx">
'use client'

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { useState } from 'react'
import { useRouter } from 'next/navigation'

export default function AdminLoginPage() {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const router = useRouter()

  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault()
    setIsLoading(true)
    setError('')

    const formData = new FormData(event.currentTarget)
    const email = formData.get('email') as string
    const password = formData.get('password') as string

    try {
      const response = await fetch('/api/auth/admin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || 'Failed to sign in')
      }

      // Redirect to admin dashboard on success
      router.push('/admin')
    } catch (error) {
      console.error('Login error:', error)
      setError(error instanceof Error ? error.message : 'Failed to sign in')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-center">Admin Login</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            {error && (
              <div className="p-3 text-sm text-red-500 bg-red-50 rounded-md">
                {error}
              </div>
            )}
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="admin@example.com"
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                name="password"
                type="password"
                placeholder="••••••••"
                required
                disabled={isLoading}
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? 'Signing in...' : 'Sign In'}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/auth/callback/route.ts">
import { createRouteHandlerClient } from '@/lib/supabase-route'
import { createClient } from '@supabase/supabase-js'
import { NextResponse } from 'next/server'
import prisma from '@/lib/db'

export async function GET(request: Request) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')

  if (code) {
    const supabase = createRouteHandlerClient()
    
    // Exchange the code for a session
    let { data: { session }, error } = await supabase.auth.exchangeCodeForSession(code)
    
    if (error) {
      console.error('Error exchanging code for session:', error)
      return NextResponse.redirect(new URL('/auth/login', requestUrl.origin))
    }

    if (!session) {
      return NextResponse.redirect(new URL('/auth/login', requestUrl.origin))
    }

    // Get user role from database
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true }
    })

    // Update user metadata with role
    if (user && session) {
      const adminClient = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!,
        {
          auth: {
            autoRefreshToken: false,
            persistSession: false
          }
        }
      )

      await adminClient.auth.admin.updateUserById(
        session.user.id,
        {
          user_metadata: {
            ...session.user.user_metadata,
            role: user.role
          }
        }
      )

      // Get fresh session with updated metadata
      const { data: { session: updatedSession } } = await supabase.auth.refreshSession()
      session = updatedSession || session
    }

    const response = NextResponse.redirect(new URL('/dashboard/analytics', requestUrl.origin))

    // Set auth cookies
    if (session) {
      const projectRef = process.env.NEXT_PUBLIC_SUPABASE_URL!.match(/(?:\/\/|^)(.*?)\.supabase/)?.[1];
      if (!projectRef) throw new Error('Could not determine project ref');

      // Set the session cookie using the same format as Supabase
      response.cookies.set(`sb-${projectRef}-auth-token`, JSON.stringify({
        access_token: session.access_token,
        refresh_token: session.refresh_token,
        expires_at: Math.floor(Date.now() / 1000) + 60 * 60 * 24 * 7, // 7 days
        expires_in: 60 * 60 * 24 * 7, // 7 days
        token_type: 'bearer',
        user: session.user
      }), {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 * 7 // 7 days
      });

      // Also set the refresh token cookie with longer expiration
      response.cookies.set(`sb-${projectRef}-refresh-token`, session.refresh_token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        path: '/',
        maxAge: 60 * 60 * 24 * 30 // 30 days
      });
    }

    return response
  }

  // URL to redirect to after sign in process completes
  const redirectTo = requestUrl.searchParams.get('returnTo') || '/dashboard/market-stand'
  return NextResponse.redirect(new URL(redirectTo, requestUrl.origin))
}
</file>

<file path="app/auth/login/page.tsx">
import { AuthDialog } from "@/components/AuthDialog";
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";

export default async function LoginPage({
  searchParams,
}: {
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  const user = await getUser();
  const returnTo = searchParams.returnTo as string;

  if (user) {
    redirect(returnTo || '/dashboard/market-stand');
  }

  return (
    <div className="container mx-auto flex flex-col items-center justify-center min-h-[calc(100vh-4rem)] py-6">
      <div className="w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold tracking-tight">
            Welcome back
          </h1>
          <p className="text-muted-foreground mt-2">
            Sign in to your account to continue
          </p>
        </div>

        <div className="mt-10">
          <AuthDialog 
            mode="login"
            returnTo={returnTo}
            trigger={
              <button className="w-full py-2.5 px-4 bg-primary text-primary-foreground rounded-lg font-medium hover:bg-primary/90">
                Sign in
              </button>
            }
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/auth-error/auth-error-client.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { useRouter, useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";

const errorMessages = {
  no_code: "Authentication code was not provided",
  session_error: "There was an error with your session",
  verification_error: "Could not verify your authentication status",
  no_session: "Unable to create a session",
  unexpected: "An unexpected error occurred",
};

export default function AuthErrorClient() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [countdown, setCountdown] = useState(3);

  const error = searchParams.get("error") || "unexpected";
  const message = searchParams.get("message");

  useEffect(() => {
    // Auto-redirect after 5 seconds
    if (countdown > 0) {
      const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
      return () => clearTimeout(timer);
    } else {
      router.push("/");
    }
  }, [countdown, router]);

  return (
    <div className="flex min-h-[60vh] flex-col items-center justify-center text-center">
      <div className="max-w-md space-y-6 px-4">
        <h1 className="text-2xl font-bold">Authentication Error</h1>
        
        <p className="text-muted-foreground">
          {errorMessages[error as keyof typeof errorMessages]}
          {message && (
            <span className="block mt-2 text-sm text-destructive">
              Details: {decodeURIComponent(message)}
            </span>
          )}
        </p>

        <div className="space-y-2">
          <p className="text-sm text-muted-foreground">
            Redirecting to home in {countdown} seconds...
          </p>
          
          <div className="flex justify-center gap-4">
            <Button
              variant="outline"
              onClick={() => router.push("/")}
            >
              Return Home
            </Button>
            <Button
              onClick={() => {
                router.push("/?retry=true");
              }}
            >
              Try Again
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/auth-error/page.tsx">
import { Suspense } from "react";
import AuthErrorClient from "./auth-error-client";

export default function AuthError() {
  return (
    <Suspense fallback={
      <div className="flex min-h-[60vh] flex-col items-center justify-center">
        <div className="max-w-md space-y-6 px-4 text-center">
          <h1 className="text-2xl font-bold">Loading...</h1>
        </div>
      </div>
    }>
      <AuthErrorClient />
    </Suspense>
  );
}
</file>

<file path="app/billing/page.tsx">
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { getUser } from "@/lib/auth";
import { AlertCircle } from "lucide-react";
import { unstable_noStore as noStore } from "next/cache";

export default async function BillingRoute() {
  noStore();
  const user = await getUser();

  if (!user) {
    throw new Error("Authentication required");
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader>
          <CardTitle>Billing</CardTitle>
          <CardDescription>
            Find all your details regarding your payments
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg flex items-start gap-3">
            <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
            <div>
              <p className="font-medium">Payment Integration Temporarily Disabled</p>
              <p className="text-sm mt-1">
                Stripe integration is currently disabled for testing purposes. Payment functionality will be available soon.
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </section>
  );
}
</file>

<file path="app/dashboard/[...route]/route.ts">
export const dynamic = 'force-dynamic';
</file>

<file path="app/dashboard/analytics/columns.tsx">
import { ColumnDef } from "@tanstack/react-table"
import { Badge } from "@/components/ui/badge"
import { formatDistanceToNow } from 'date-fns'

type Product = {
  id: string
  name: string
  price: number
  status: string
  createdAt: Date
  marketStand: {
    name: string
  }
}

export const columns: ColumnDef<Product>[] = [
  {
    accessorKey: "name",
    header: "Product",
    cell: ({ row }) => {
      return (
        <div className="flex flex-col">
          <span className="font-medium">{row.getValue("name")}</span>
          <span className="text-sm text-gray-500">{row.original.marketStand.name}</span>
        </div>
      )
    }
  },
  {
    accessorKey: "price",
    header: "Price",
    cell: ({ row }) => {
      const amount = parseFloat(row.getValue("price"))
      const formatted = new Intl.NumberFormat("en-US", {
        style: "currency",
        currency: "USD",
      }).format(amount / 100)
 
      return <div className="font-medium">{formatted}</div>
    }
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as string
      return (
        <Badge 
          variant={
            status === 'APPROVED' ? 'default' :
            status === 'PENDING' ? 'secondary' :
            'destructive'
          }
        >
          {status.toLowerCase()}
        </Badge>
      )
    }
  },
  {
    accessorKey: "createdAt",
    header: "Created",
    cell: ({ row }) => {
      return formatDistanceToNow(new Date(row.getValue("createdAt")), { addSuffix: true })
    }
  }
]
</file>

<file path="app/dashboard/analytics/page.tsx">
import { Suspense } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import prisma from '@/lib/db'
import { LineChart } from '@/components/ui/line-chart'
import { DataTable } from '@/components/ui/data-table'
import { columns } from './columns'
import { getSupabaseServer } from '@/lib/supabase-server'

async function getUserAnalyticsData() {
  const supabase = getSupabaseServer()
  const { data: { session } } = await supabase.auth.getSession()
  
  if (!session?.user) {
    return null
  }

  const userId = session.user.id

  // Get user's market stands and products
  const [
    userStands,
    totalProducts,
    totalOrders,
    totalRevenue
  ] = await Promise.all([
    prisma.marketStand.count({ 
      where: { 
        userId,
        isActive: true 
      } 
    }),
    prisma.product.count({ 
      where: { 
        userId,
        isActive: true 
      } 
    }),
    prisma.standMetrics.findMany({
      where: {
        marketStand: {
          userId
        }
      },
      select: {
        totalOrders: true
      }
    }).then(metrics => metrics.reduce((sum, m) => sum + m.totalOrders, 0)),
    prisma.standMetrics.findMany({
      where: {
        marketStand: {
          userId
        }
      },
      select: {
        totalRevenue: true
      }
    }).then(metrics => metrics.reduce((sum, m) => sum + m.totalRevenue, 0))
  ])

  // Get order metrics for charts
  const orderMetrics = await prisma.standMetrics.findMany({
    where: {
      marketStand: {
        userId
      }
    },
    select: {
      dailyMetrics: {
        select: {
          date: true,
          orders: true,
          revenue: true,
          views: true
        },
        orderBy: {
          date: 'asc'
        },
        take: 30 // Last 30 days
      }
    }
  })

  // Get recent products
  const recentProducts = await prisma.product.findMany({
    where: {
      userId,
      isActive: true
    },
    select: {
      id: true,
      name: true,
      price: true,
      status: true,
      createdAt: true,
      marketStand: {
        select: {
          name: true
        }
      }
    },
    orderBy: {
      createdAt: 'desc'
    },
    take: 5
  })

  return {
    userStands,
    totalProducts,
    totalOrders,
    totalRevenue,
    orderMetrics,
    recentProducts
  }
}

export default async function UserAnalyticsDashboard() {
  const data = await getUserAnalyticsData()

  if (!data) {
    return <div>Please sign in to view analytics.</div>
  }

  const {
    userStands,
    totalProducts,
    totalOrders,
    totalRevenue,
    orderMetrics,
    recentProducts
  } = data

  // Process data for charts
  const metrics = orderMetrics.flatMap(metric => 
    metric.dailyMetrics.map(daily => ({
      date: daily.date,
      orders: daily.orders,
      revenue: daily.revenue / 100, // Convert cents to dollars
      views: daily.views
    }))
  )

  return (
    <div className="space-y-8">
      <h1 className="text-3xl font-bold">Your Analytics</h1>
      
      {/* Stats Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Your Stands</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{userStands}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Active Products</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totalProducts}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Orders</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{totalOrders}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
              }).format(totalRevenue / 100)}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <Card>
          <CardHeader>
            <CardTitle>Orders</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart 
              data={metrics}
              xField="date"
              yField="orders"
              height={300}
            />
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Revenue</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart 
              data={metrics}
              xField="date"
              yField="revenue"
              height={300}
              valuePrefix="$"
            />
          </CardContent>
        </Card>
      </div>

      {/* Recent Products */}
      <Card>
        <CardHeader>
          <CardTitle>Recent Products</CardTitle>
        </CardHeader>
        <CardContent>
          <Suspense fallback={<div>Loading...</div>}>
            <DataTable columns={columns} data={recentProducts} />
          </Suspense>
        </CardContent>
      </Card>
    </div>
  )
}
</file>

<file path="app/dashboard/events/page.tsx">
import { UnderConstruction } from "@/components/UnderConstruction";

export default function EventsPage() {
  return <UnderConstruction />;
}
</file>

<file path="app/dashboard/farm-page/page.tsx">
import { UnderConstruction } from "@/components/UnderConstruction";

export default function FarmPage() {
  return <UnderConstruction />;
}
</file>

<file path="app/dashboard/local/page.tsx">
export const dynamic = 'force-dynamic';

import { getUser } from "@/lib/auth";
import prisma, { executeWithRetry } from "@/lib/db";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";
import { LocalCard } from "@/components/LocalCard";
import { redirect } from "next/navigation";

async function getLocals(userId: string) {
  try {
    const locals = await executeWithRetry(() => prisma.local.findMany({
      where: {
        userId: userId,
      },
      select: {
        id: true,
        name: true,
        description: true,
        locationName: true,
        images: true,
        _count: {
          select: {
            products: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    }));

    // Ensure data is serializable and handle nulls
    return locals.map(local => ({
      ...local,
      description: local.description ?? null,
      images: local.images ?? [],
      _count: {
        products: local._count.products
      }
    }));
  } catch (err) {
    console.error('Failed to fetch locals:', err);
    return [];
  }
}

export default async function LocalDashboard() {
  const user = await getUser();
  
  if (!user) {
    redirect('/');
  }

  const locals = await getLocals(user.id);

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold">My Farm/Ranch Profiles</h1>
          <p className="text-muted-foreground">
            Manage your farm and ranch profiles
          </p>
        </div>
        <Link href="/local/setup">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            New Profile
          </Button>
        </Link>
      </div>

      {locals.length === 0 ? (
        <div className="text-center py-12">
          <h3 className="text-lg font-medium mb-2">No profiles yet</h3>
          <p className="text-muted-foreground mb-4">
            Create your first farm/ranch profile to showcase your operation
          </p>
          <Link href="/local/setup">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Create Profile
            </Button>
          </Link>
        </div>
      ) : (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {locals.map((local) => (
            <LocalCard 
              key={local.id}
              local={local}
              userId={user.id}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/dashboard/market-stand/setup/edit/[id]/page.tsx">
import { Card } from "@/components/ui/card";
import { unstable_noStore as noStore } from "next/cache";
import { MarketStandForm } from "@/components/form/MarketStandForm";
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";
import { WeeklyHours } from "@/types/hours";
import Link from "next/link";
import { redirect, notFound } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";

interface EditMarketStandPageProps {
  params: {
    id: string;
  };
}

export default async function EditMarketStandPage({ params }: EditMarketStandPageProps) {
  noStore();
  
  try {
    const user = await getUser();

    if (!user) {
      redirect('/');
    }

    // Get the market stand
    const marketStand = await prisma.marketStand.findUnique({
      where: { 
        id: params.id,
        userId: user.id.toString() // Ensure the user owns this market stand
      }
    });

    if (!marketStand) {
      notFound();
    }

    // Transform the Prisma model to match MarketStandForm props
    const transformedStand = {
      id: marketStand.id,
      name: marketStand.name,
      description: marketStand.description || '',
      locationName: marketStand.locationName,
      locationGuide: marketStand.locationGuide,
      latitude: marketStand.latitude,
      longitude: marketStand.longitude,
      images: marketStand.images,
      tags: marketStand.tags,
      website: marketStand.website || undefined,
      socialMedia: marketStand.socialMedia || undefined,
      hours: marketStand.hours as WeeklyHours || undefined
    };

    return (
      <div>
        <div className="mb-8">
          <Link href="/dashboard/market-stand/setup">
            <Button variant="ghost" className="gap-2 pl-0 mb-4">
              <ArrowLeft className="h-4 w-4" />
              Back to Market Stands
            </Button>
          </Link>
          <h1 className="text-3xl font-bold mb-2">Edit Your Market Stand</h1>
          <p className="text-muted-foreground">
            Update your market stand information to keep your customers informed.
          </p>
        </div>

        <Card className="mb-8">
          <MarketStandForm 
            userId={user.id.toString()} 
            marketStand={transformedStand}
          />
        </Card>
      </div>
    );
  } catch (error) {
    console.error("Error in EditMarketStandPage:", error);
    
    return (
      <div>
        <div className="mb-8">
          <Link href="/dashboard/market-stand/setup">
            <Button variant="ghost" className="gap-2 pl-0 mb-4">
              <ArrowLeft className="h-4 w-4" />
              Back to Market Stands
            </Button>
          </Link>
          <h1 className="text-3xl font-bold mb-2">Error Loading Page</h1>
          <p className="text-muted-foreground">
            There was an error loading this page. Please try again later.
          </p>
        </div>
      </div>
    );
  }
}
</file>

<file path="app/dashboard/market-stand/setup/new/page.tsx">
import { Card } from "@/components/ui/card";
import { unstable_noStore as noStore } from "next/cache";
import { MarketStandForm } from "@/components/form/MarketStandForm";
import { getUser } from "@/lib/auth";
import Link from "next/link";
import { redirect } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";

export default async function NewMarketStandPage() {
  noStore();
  
  try {
    const user = await getUser();

    if (!user) {
      redirect('/');
    }

    return (
      <div>
        <div className="mb-8">
          <Link href="/dashboard/market-stand/setup">
            <Button variant="ghost" className="gap-2 pl-0 mb-4">
              <ArrowLeft className="h-4 w-4" />
              Back to Market Stands
            </Button>
          </Link>
          <h1 className="text-3xl font-bold mb-2">Create Your Market Stand</h1>
          <p className="text-muted-foreground">
            Set up your market stand to start selling your products to local customers.
          </p>
        </div>

        <Card className="mb-8">
          <MarketStandForm 
            userId={user.id.toString()} 
          />
        </Card>
      </div>
    );
  } catch (error) {
    console.error("Error in NewMarketStandPage:", error);
    
    return (
      <div>
        <div className="mb-8">
          <Link href="/dashboard/market-stand/setup">
            <Button variant="ghost" className="gap-2 pl-0 mb-4">
              <ArrowLeft className="h-4 w-4" />
              Back to Market Stands
            </Button>
          </Link>
          <h1 className="text-3xl font-bold mb-2">Error Loading Page</h1>
          <p className="text-muted-foreground">
            There was an error loading this page. Please try again later.
          </p>
        </div>
      </div>
    );
  }
}
</file>

<file path="app/dashboard/market-stand/setup/loading.tsx">
import { Card } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

export default function MarketStandSetupLoading() {
  return (
    <div>
      <Card>
        <Skeleton className="h-[800px]" />
      </Card>
    </div>
  );
}
</file>

<file path="app/dashboard/market-stand/setup/page.tsx">
import { Card } from "@/components/ui/card";
import { unstable_noStore as noStore } from "next/cache";
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";
import { WeeklyHours } from "@/types/hours";
import Link from "next/link";
import { redirect } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Plus, AlertCircle } from "lucide-react";
import { MarketStandCard } from "@/components/MarketStandCard";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

export default async function MarketStandSetupPage() {
  noStore();
  
  try {
    const user = await getUser();

    if (!user) {
      redirect('/');
    }

    // Get all market stands for the user
    const userStands = await prisma.marketStand.findMany({
      where: { 
        userId: user.id.toString(),
        isActive: true
      },
      include: {
        _count: {
          select: {
            products: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return (
      <div>
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold mb-2">Your Market Stands</h1>
            <p className="text-muted-foreground">
              Manage your market stands or create a new one
            </p>
          </div>
          <Link href="/dashboard/market-stand/setup/new">
            <Button className="gap-2">
              <Plus className="h-4 w-4" />
              Create New Market Stand
            </Button>
          </Link>
        </div>

        {userStands.length === 0 ? (
          <Alert className="mb-8">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>No market stands yet</AlertTitle>
            <AlertDescription>
              You haven't created any market stands yet. Click the "Create New Market Stand" button to get started.
            </AlertDescription>
          </Alert>
        ) : (
          <div className="space-y-6 mb-8">
            {userStands.map((stand) => (
              <MarketStandCard key={stand.id} stand={stand} />
            ))}
          </div>
        )}

        {userStands.length > 0 && (
          <div className="text-sm text-muted-foreground mt-8">
            <p>Need to make changes to your products?</p>
            <p>Visit the <Link href="/dashboard/market-stand" className="text-primary hover:underline">Market Stand Dashboard</Link> to manage your inventory.</p>
          </div>
        )}
      </div>
    );
  } catch (error) {
    console.error("Error in MarketStandSetupPage:", error);
    
    return (
      <div>
        <div className="mb-8">
          <h1 className="text-3xl font-bold mb-2">Error Loading Market Stands</h1>
          <p className="text-muted-foreground">
            There was an error loading your market stands. Please try again later.
          </p>
        </div>
        <div className="flex justify-center mt-8">
          <Link href="/dashboard">
            <Button>
              Return to Dashboard
            </Button>
          </Link>
        </div>
      </div>
    );
  }
}
</file>

<file path="app/dashboard/market-stand/market-stand-client.tsx">
"use client";

import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";
import { MarketStandCard } from "@/components/MarketStandCard";
import { MarketStandSelector } from "@/components/dashboard/MarketStandSelector";
import { ProductList } from "@/components/dashboard/ProductList";
import { useState, useEffect } from "react";

interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  locationName: string;
  locationGuide: string;
  latitude: number;
  longitude: number;
  images: string[];
  tags: string[];
  _count: {
    products: number;
  };
}

interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
  quantity: number;
  updatedAt: Date;
}

interface MarketStandDashboardClientProps {
  initialMarketStands: MarketStand[];
}

export function MarketStandDashboardClient({ initialMarketStands }: MarketStandDashboardClientProps) {
  const [marketStands] = useState<MarketStand[]>(initialMarketStands);
  const [selectedStandId, setSelectedStandId] = useState<string>(initialMarketStands[0]?.id || "");
  const [products, setProducts] = useState<Product[]>([]);

  useEffect(() => {
    const fetchProducts = async () => {
      if (!selectedStandId) return;

      try {
        const response = await fetch(`/api/market-stand/${selectedStandId}/products`);
        const data = await response.json();
        const transformedData = data.map((product: any) => ({
          id: product.id,
          name: product.name,
          price: product.price,
          image: product.images[0],
          quantity: product.inventory,
          updatedAt: new Date(product.updatedAt)
        }));
        setProducts(transformedData);
      } catch (error) {
        console.error('Error fetching products:', error);
      }
    };

    if (selectedStandId) {
      fetchProducts();
    }
  }, [selectedStandId]);

  const handleQuantityChange = async (productId: string, newQuantity: number) => {
    try {
      // Optimistic update
      setProducts(products.map(product => 
        product.id === productId 
          ? { ...product, quantity: newQuantity }
          : product
      ));

      // Update on server
      await fetch(`/api/product/${productId}/quantity`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ quantity: newQuantity }),
      });
    } catch (error) {
      console.error('Error updating quantity:', error);
      // Revert on error
      const response = await fetch(`/api/market-stand/${selectedStandId}/products`);
      const data = await response.json();
      setProducts(data);
    }
  };

  const selectedStand = marketStands.find(stand => stand.id === selectedStandId);

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold">Market Stand Management</h1>
          <p className="text-muted-foreground">
            Manage your market stands and their products
          </p>
        </div>
        <Link href="/dashboard/market-stand/setup">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            New Market Stand
          </Button>
        </Link>
      </div>

      {marketStands.length === 0 ? (
        <div className="text-center py-12">
          <h3 className="text-lg font-medium mb-2">No market stands yet</h3>
          <p className="text-muted-foreground mb-4">
            Create your first market stand to start selling products
          </p>
          <Link href="/dashboard/market-stand/setup">
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Create Market Stand
            </Button>
          </Link>
        </div>
      ) : (
        <div className="space-y-6">
          <MarketStandSelector
            marketStands={marketStands}
            selectedId={selectedStandId}
            onSelect={setSelectedStandId}
          />

          {selectedStand && (
            <div className="grid gap-6">
              <MarketStandCard 
                stand={selectedStand}
              />
              <ProductList
                products={products}
                onQuantityChange={handleQuantityChange}
              />
            </div>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/dashboard/market-stand/page.tsx">
import { getUser } from "@/lib/auth";
import prisma from "@/lib/db";
import { redirect } from "next/navigation";
import { MarketStandDashboardClient } from "./market-stand-client";
import { unstable_noStore as noStore } from "next/cache";

async function getMarketStands(userId: string) {
  try {
    const stands = await prisma.marketStand.findMany({
      where: {
        userId: userId,
      },
      select: {
        id: true,
        name: true,
        description: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        images: true,
        tags: true,
        _count: {
          select: {
            products: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    // Ensure data is serializable
    return stands.map(stand => ({
      ...stand,
      description: stand.description || null,
      tags: stand.tags || [],
      _count: {
        products: stand._count.products
      }
    }));
  } catch (err) {
    return [];
  }
}

export default async function MarketStandDashboard() {
  noStore();
  const user = await getUser();

  if (!user) {
    redirect('/auth/login');
  }

  const marketStands = await getMarketStands(user.id.toString());

  return <MarketStandDashboardClient initialMarketStands={marketStands} />;
}
</file>

<file path="app/dashboard/orders/page.tsx">
import { UnderConstruction } from "@/components/UnderConstruction";

export default function OrdersPage() {
  return <UnderConstruction />;
}
</file>

<file path="app/dashboard/sell/page.tsx">
import { unstable_noStore as noStore } from "next/cache";
import { redirect } from "next/navigation";
import prisma from "@/lib/db";
import { getUser } from "@/lib/auth";
import { ProductCatalogList } from "@/components/dashboard/ProductCatalogList";

async function getUserProducts(userId: string) {
  const products = await prisma.product.findMany({
    where: {
      userId: userId,
    },
    select: {
      id: true,
      name: true,
      price: true,
      images: true,
      isActive: true,
      marketStand: {
        select: {
          id: true,
          name: true,
        },
      },
      local: {
        select: {
          id: true,
          name: true,
        },
      },
      updatedAt: true,
    },
    orderBy: {
      updatedAt: 'desc',
    },
  });

  return products.map(product => ({
    id: product.id,
    name: product.name,
    price: product.price,
    image: product.images[0] || '',
    isOnline: product.local !== null,
    marketStands: product.marketStand ? [product.marketStand] : [],
    updatedAt: product.updatedAt,
  }));
}

export default async function SellRoute() {
  noStore();
  const user = await getUser();

  if (!user) {
    return redirect('/');
  }

  const products = await getUserProducts(user.id);

  return (
    <div className="space-y-6">
      <ProductCatalogList products={products} />
    </div>
  );
}
</file>

<file path="app/dashboard/sell/sell-client.tsx">
"use client";

import { getProducts } from "@/app/actions/products";
import { Status } from "@prisma/client";
import { useRouter } from "next/navigation";
import { InventoryManager } from "@/components/InventoryManager";
import { getSupabaseBrowser } from '@/lib/supabase-browser';
import Link from "next/link";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { useState, useEffect } from "react";

// Server response type with string dates
type ProductResponse = {
  id: string;
  name: string;
  description: string;
  price: number;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: string | null;
  status: Status;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  userId: string;
  totalReviews: number;
  locationName?: string;
  marketStand?: {
    id: string;
    name: string;
  };
  marketStandId: string;
  averageRating: number | null;
  tags: string[];
};

// Client-side type with Date objects
type Product = Omit<ProductResponse, 'createdAt' | 'updatedAt' | 'inventoryUpdatedAt'> & {
  createdAt: Date;
  updatedAt: Date;
  inventoryUpdatedAt: Date | null;
};

type User = {
  id: string;
  marketStandId: string;
};

interface DashboardProductRowProps {
  product: Product;
}

function DashboardProductRow({ product }: DashboardProductRowProps) {
  const handleInventoryUpdate = async (newInventory: number) => {
    const formData = new FormData();
    formData.append('productId', product.id);
    formData.append('inventory', newInventory.toString());

    const response = await fetch('/api/product/inventory', {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error('Failed to update inventory');
    }
  };

  return (
    <div className="flex items-center justify-between p-4 border rounded-md">
      <div className="flex items-center gap-4">
        <div className="relative w-16 h-16 rounded-md overflow-hidden bg-muted">
          {product.images[0] && (
            <Image
              src={product.images[0]}
              alt={product.name}
              className="object-cover"
              fill
              sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
            />
          )}
        </div>
        <div>
          <Link href={`/product/${product.id}`}>
            <h3 className="text-lg font-medium">{product.name}</h3>
          </Link>
          <p className="text-sm text-gray-500">{product.description}</p>
          <p className="mt-1">
            <span className="text-sm font-medium">${(product.price / 100).toFixed(2)}</span>
            {' | '}
            <span className="text-sm text-gray-500">{product.locationName}</span>
          </p>
        </div>
      </div>
      <div className="flex items-center gap-6">
        <InventoryManager
          currentInventory={product.inventory}
          onUpdate={handleInventoryUpdate}
        />
        <Link href={`/product/${product.id}/edit`} className="text-sm font-medium text-primary hover:text-primary-focus">
          Edit <span>&rarr;</span>
        </Link>
      </div>
    </div>
  );
}

export default function SellClient() {
  const [user, setUser] = useState<User | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const router = useRouter();
  const supabase = getSupabaseBrowser();

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);

        // Check auth status
        const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
        
        if (authError || !authUser) {
          router.push('/');
          return;
        }

        // Get user profile
        const res = await fetch("/api/user");
        const userData = await res.json();
  
        if (!res.ok) {
          throw new Error(userData.error || 'Failed to fetch user data');
        }
  
        setUser(userData);
  
        // Fetch products and convert dates
        const productsData = await getProducts(userData.id);
        const productsWithDates = productsData.map(product => ({
          ...product,
          createdAt: new Date(product.createdAt),
          updatedAt: new Date(product.updatedAt),
          inventoryUpdatedAt: product.inventoryUpdatedAt ? new Date(product.inventoryUpdatedAt) : null
        }));
        setProducts(productsWithDates);
      } catch (error) {
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unexpected error occurred');
        }
      } finally {
        setLoading(false);
      }
    };
  
    fetchData();
  }, [router, supabase]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-muted-foreground">Loading products...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <p className="text-destructive">{error}</p>
          <Button onClick={() => window.location.reload()}>
            Try Again
          </Button>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="space-y-4 text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-lg font-medium">Products</h3>
        <p className="text-sm text-muted-foreground">
          Manage and sell your products.
        </p>
      </div>
      <div className="flex justify-end mb-4">
        <Button asChild>
          <Link href="/sell" className="flex items-center">
            <Plus className="h-4 w-4 mr-2" />
            Add Product
          </Link>
        </Button>
      </div>
      <div className="grid gap-4">
        {products?.map((product) => (
          <DashboardProductRow key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/settings/page.tsx">
export const dynamic = 'force-dynamic';

import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { CreditCard, Store, User } from "lucide-react";

export default async function SettingsDashboard() {
  const user = await getUser();
  
  if (!user) {
    redirect('/');
  }

  const settingsCards = [
    {
      title: "Profile Settings",
      description: "Update your personal information and preferences",
      icon: User,
      href: "/settings",
    },
    {
      title: "Payment Settings",
      description: "Manage your payment methods and billing information",
      icon: CreditCard,
      href: "/billing",
    },
    {
      title: "Market Stand Settings",
      description: "Configure your market stand preferences",
      icon: Store,
      href: "/dashboard/market-stand/setup",
    },
  ];

  return (
    <div>
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Settings</h1>
        <p className="text-muted-foreground">
          Manage your account settings and preferences
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {settingsCards.map((card) => {
          const Icon = card.icon;
          return (
            <Link key={card.href} href={card.href}>
              <Card className="h-full hover:bg-muted/50 transition-colors">
                <CardHeader>
                  <Icon className="h-8 w-8 mb-2 text-primary" />
                  <CardTitle>{card.title}</CardTitle>
                  <CardDescription>{card.description}</CardDescription>
                </CardHeader>
                <CardContent>
                  <Button variant="ghost" className="w-full">
                    View Settings
                  </Button>
                </CardContent>
              </Card>
            </Link>
          );
        })}
      </div>

      <div className="mt-8">
        <Card>
          <CardHeader>
            <CardTitle>Account Information</CardTitle>
            <CardDescription>Your current account details</CardDescription>
          </CardHeader>
          <CardContent className="space-y-2">
            <div>
              <div className="text-sm font-medium">Email</div>
              <div className="text-sm text-muted-foreground">{user?.email}</div>
            </div>
            <div>
              <div className="text-sm font-medium">Name</div>
              <div className="text-sm text-muted-foreground">
                {user?.user_metadata?.given_name} {user?.user_metadata?.family_name}
              </div>
            </div>
            <div>
              <div className="text-sm font-medium">Account Created</div>
              <div className="text-sm text-muted-foreground">
                {new Date(user?.created_at!).toLocaleDateString()}
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="app/dashboard/support/page.tsx">
import { UnderConstruction } from "@/components/UnderConstruction";

export default function SupportPage() {
  return <UnderConstruction />;
}
</file>

<file path="app/dashboard/layout.tsx">
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";
import { Sidebar } from "@/components/dashboard/Sidebar";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getUser();

  if (!user) {
    redirect('/');
  }

  return (
    <div className="flex min-h-screen bg-gray-50">
      <Sidebar />
      <main className="flex-1 ml-64 p-6">
        {children}
      </main>
    </div>
  );
}
</file>

<file path="app/dashboard/page.tsx">
import { redirect } from "next/navigation";
import { getUser } from "@/lib/auth";

export default async function DashboardPage() {
  const user = await getUser();
  
  if (!user) {
    redirect('/');
  }

  // Redirect to market-stand dashboard by default
  redirect('/dashboard/market-stand');
}
</file>

<file path="app/hooks/useUserLocation.ts">
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { type LocationType } from '../actions/home-products';

interface UseUserLocationOptions {
  enableHighAccuracy?: boolean;
  timeout?: number;
  maximumAge?: number;
  watchPosition?: boolean;
  minAccuracy?: number;
  cacheKey?: string;
  retryAttempts?: number;
  retryDelay?: number;
  onSuccess?: (location: LocationType) => void;
}

interface UseUserLocationResult {
  userLocation: LocationType | null;
  locationError: string | null;
  isLoadingLocation: boolean;
  retryLocation: () => void;
  accuracy: number | null;
  lastUpdated: number | null;
  clearLocation: () => void;
  setManualLocation: (location: LocationType) => void;
}

const DEFAULT_OPTIONS: UseUserLocationOptions = {
  enableHighAccuracy: true,
  timeout: 15000, // Increased timeout
  maximumAge: 5 * 60 * 1000, // 5 minutes
  watchPosition: false,
  minAccuracy: 2000, // Increased to 2km to be more lenient
  cacheKey: 'user_location',
  retryAttempts: 5, // Increased retry attempts
  retryDelay: 2000, // Increased delay between retries
};

const isLocationValid = (location: LocationType | null, minAccuracy: number): boolean => {
  if (!location?.coords) return false;
  return location.coords.accuracy ? location.coords.accuracy <= minAccuracy : true;
};

const getCachedLocation = (cacheKey: string): LocationType | null => {
  try {
    const cached = localStorage.getItem(cacheKey);
    if (!cached) return null;

    const parsed = JSON.parse(cached);
    const now = Date.now();
    const age = now - (parsed.coords.timestamp || 0);

    // Validate cache freshness (default 5 minutes)
    if (age > DEFAULT_OPTIONS.maximumAge!) {
      localStorage.removeItem(cacheKey);
      return null;
    }

    return parsed;
  } catch {
    return null;
  }
};

const cacheLocation = (location: LocationType, cacheKey: string): void => {
  try {
    localStorage.setItem(cacheKey, JSON.stringify(location));
  } catch (error) {
    console.error('Failed to cache location:', error);
  }
};

export default function useUserLocation(options: UseUserLocationOptions = {}): UseUserLocationResult {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
  const {
    enableHighAccuracy,
    timeout,
    maximumAge,
    watchPosition,
    minAccuracy,
    cacheKey,
    retryAttempts,
    retryDelay
  } = mergedOptions;

  const [userLocation, setUserLocation] = useState<LocationType | null>(() => {
    // Initialize with cached data if available
    return getCachedLocation(cacheKey!);
  });
  const [locationError, setLocationError] = useState<string | null>(null);
  const [isLoadingLocation, setIsLoadingLocation] = useState<boolean>(false);
  const [accuracy, setAccuracy] = useState<number | null>(null);
  const [lastUpdated, setLastUpdated] = useState<number | null>(null);

  const watchIdRef = useRef<number | null>(null);
  const retryCountRef = useRef<number>(0);
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Forward declarations
  const requestLocationRef = useRef<() => void>(() => {});
  const requestLocationFnRef = useRef<() => void>(() => requestLocationRef.current());

  const handleLocationSuccess = useCallback((position: GeolocationPosition): void => {
    const newLocation: LocationType = {
      coords: {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy,
        timestamp: position.timestamp
      },
      source: 'browser'
    };

    // Always set the location, but continue trying to get better accuracy if needed
    setUserLocation(newLocation);
    setAccuracy(position.coords.accuracy);
    setLastUpdated(position.timestamp);
    cacheLocation(newLocation, cacheKey!);
    
    // Call onSuccess callback if provided
    if (mergedOptions.onSuccess) {
      mergedOptions.onSuccess(newLocation);
    }

    if (!isLocationValid(newLocation, minAccuracy!)) {
      setLocationError(`Location accuracy is ${Math.round(position.coords.accuracy)}m (trying to improve...)`);
      if (retryCountRef.current < retryAttempts!) {
        retryTimeoutRef.current = setTimeout(() => {
          retryCountRef.current++;
          requestLocationFnRef.current();
        }, retryDelay! * Math.pow(2, retryCountRef.current));
      }
    } else {
      setLocationError(null);
      retryCountRef.current = 0;
    }
    setIsLoadingLocation(false);
  }, [minAccuracy, cacheKey, retryAttempts, retryDelay]);

  const handleLocationError = useCallback((error: GeolocationPositionError): void => {
    let errorMessage: string;
    switch (error.code) {
      case error.PERMISSION_DENIED:
        // Set a null location but don't treat it as an error to allow the app to proceed
        setUserLocation(null);
        setLocationError(null);
        break;
      case error.POSITION_UNAVAILABLE:
        errorMessage = 'Location information is unavailable. Please check your device settings.';
        setLocationError(errorMessage);
        break;
      case error.TIMEOUT:
        errorMessage = 'Location request timed out. Please check your connection and try again.';
        setLocationError(errorMessage);
        break;
      default:
        errorMessage = `Failed to get location: ${error.message}`;
        setLocationError(errorMessage);
    }

    setIsLoadingLocation(false);

    // Only retry for non-denial errors
    if (error.code !== error.PERMISSION_DENIED && retryCountRef.current < retryAttempts!) {
      retryTimeoutRef.current = setTimeout(() => {
        retryCountRef.current++;
        requestLocationFnRef.current();
      }, retryDelay! * Math.pow(2, retryCountRef.current));
    }
  }, [retryAttempts, retryDelay]);

  const clearLocation = useCallback((): void => {
    setUserLocation(null);
    setLocationError(null);
    setAccuracy(null);
    setLastUpdated(null);
    localStorage.removeItem(cacheKey!);
  }, [cacheKey]);

  const retryLocation = useCallback((): void => {
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    retryCountRef.current = 0;
    requestLocationFnRef.current();
  }, []);

  // Initialize requestLocationRef implementation
  useEffect(() => {
    requestLocationRef.current = () => {
      if (!navigator.geolocation) {
        setLocationError('Geolocation is not supported by this browser.');
        return;
      }

      if (!window.isSecureContext) {
        setLocationError('Geolocation requires a secure context (HTTPS).');
        return;
      }

      setIsLoadingLocation(true);
      setLocationError(null);

      const options: PositionOptions = {
        enableHighAccuracy,
        timeout,
        maximumAge
      };

      if (watchPosition && !watchIdRef.current) {
        watchIdRef.current = navigator.geolocation.watchPosition(
          handleLocationSuccess,
          handleLocationError,
          options
        );
      } else {
        navigator.geolocation.getCurrentPosition(
          handleLocationSuccess,
          handleLocationError,
          options
        );
      }
    };
  }, [enableHighAccuracy, timeout, maximumAge, watchPosition, handleLocationSuccess, handleLocationError]);

  // Start location tracking
  useEffect(() => {
    requestLocationFnRef.current();

    return () => {
      if (watchIdRef.current !== null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
        watchIdRef.current = null;
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, []);

  const setManualLocation = useCallback((location: LocationType): void => {
    setUserLocation(location);
    setLocationError(null);
    setAccuracy(location.coords.accuracy || 0);
    setLastUpdated(location.coords.timestamp || Date.now());
    cacheLocation(location, cacheKey!);
  }, [cacheKey]);

  return {
    userLocation,
    locationError,
    isLoadingLocation,
    retryLocation,
    accuracy,
    lastUpdated,
    clearLocation,
    setManualLocation
  };
}
</file>

<file path="app/how-it-works/layout.tsx">
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "How It Works | Cornucopia",
  description: "Learn how Cornucopia connects local buyers with producers for fresh goods and artisanal products.",
};

export default function HowItWorksLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return children;
}
</file>

<file path="app/how-it-works/page.tsx">
import Image from "next/image";

export default function HowItWorks() {
  return (
    <div>
      {/* Process Section */}
      <section className="w-full bg-[#134925] py-16 mb-16">
        <div className="max-w-5xl mx-auto px-4">
          <div className="text-center mb-12">
            <div className="inline-block bg-white rounded-full px-6 py-2 mb-4">
              <span className="text-[#134925] font-medium">How It Works</span>
            </div>
            <h2 className="text-4xl font-bold text-white mb-4">The Process We Follow</h2>
            <p className="text-gray-200">Find fresh local products and connect with farmstands in your area</p>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-4 gap-8 relative">
            {/* Connecting dots */}
            <div className="hidden md:block absolute top-1/4 left-0 right-0 h-px bg-gray-400 -z-10" style={{ borderTop: '2px dashed rgba(255,255,255,0.3)' }}></div>

            {/* Step 1 */}
            <div className="relative">
              <div className="w-8 h-8 bg-white rounded-full mx-auto mb-4 flex items-center justify-center">
                <div className="w-3 h-3 bg-[#134925] rounded-full"></div>
              </div>
              <h3 className="text-xl font-semibold text-white mb-2 text-center">Explore Farms</h3>
              <p className="text-gray-200 text-center text-sm">
                Discover local farmstands via the map view or list.
              </p>
            </div>

            {/* Step 2 */}
            <div className="relative">
              <div className="w-8 h-8 bg-white rounded-full mx-auto mb-4 flex items-center justify-center">
                <div className="w-3 h-3 bg-[#134925] rounded-full"></div>
              </div>
              <h3 className="text-xl font-semibold text-white mb-2 text-center">Browse Products</h3>
              <p className="text-gray-200 text-center text-sm">
                View farmstand details, including products, photos, and descriptions.
              </p>
            </div>

            {/* Step 3 */}
            <div className="relative">
              <div className="w-8 h-8 bg-white rounded-full mx-auto mb-4 flex items-center justify-center">
                <div className="w-3 h-3 bg-[#134925] rounded-full"></div>
              </div>
              <h3 className="text-xl font-semibold text-white mb-2 text-center">Go to Farmstands</h3>
              <p className="text-gray-200 text-center text-sm">
                Use directions and contact information to visit farmstands.
              </p>
            </div>

            {/* Step 4 */}
            <div className="relative">
              <div className="w-8 h-8 bg-white rounded-full mx-auto mb-4 flex items-center justify-center">
                <div className="w-3 h-3 bg-[#134925] rounded-full"></div>
              </div>
              <h3 className="text-xl font-semibold text-white mb-2 text-center">Make a Purchase</h3>
              <p className="text-gray-200 text-center text-sm">
                Use the buy page to purchase products with QR code scanning.
              </p>
            </div>
          </div>
        </div>
      </section>
      
      {/* Buyers Section */}
      <section className="w-full bg-white py-16 mb-0">
        <div className="max-w-6xl mx-auto px-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
            <div>
              <h2 className="text-3xl font-semibold mb-6 flex items-center gap-3">
                <span className="bg-[#134925] text-white p-2 rounded-full">🛒</span>
                <span className="text-[#134925]">For Buyers</span>
              </h2>
              <div className="prose prose-lg max-w-none">
                <p className="text-gray-700 leading-relaxed mb-6">
                  Discover an incredible variety of local goods right in your neighborhood with Cornucopia. From fresh farm produce to artisanal crafts, homemade goods, and specialty items, our platform shows you what's available near you right now. Each product listing includes a real-time timer showing when it was last updated, helping you gauge availability before you visit.
                </p>
                <p className="text-gray-700 leading-relaxed mb-6">
                  See a product marked as "5 minutes ago"? It's likely still there! Notice "2 days ago"? You might want to check newer listings instead. When you find something you love, our interactive map guides you directly to the market stand.
                </p>
                <p className="text-gray-700 leading-relaxed">
                  Many stands offer instant purchasing through their QR code - just scan, pay, and pick up your items. For stands without digital payments, you'll still know exactly what's available and where to find it. It's like having your entire local market community in your pocket, making it easy to support small producers and makers in your area.
                </p>
              </div>
            </div>
            <div className="relative h-[400px] rounded-lg overflow-hidden">
              <Image
                src="https://swhinhgrtcowjmpstozh.supabase.co/storage/v1/object/public/images/pexels-wildlittlethingsphoto-841303.jpg?t=2025-01-21T16%3A44%3A16.245Z"
                alt="Customer browsing local produce"
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, 50vw"
                priority
              />
            </div>
          </div>
        </div>
      </section>

      {/* Sellers Section */}
      <section className="w-full bg-[#F0F0F0] py-16">
        <div className="max-w-6xl mx-auto px-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
            <div className="relative h-[400px] rounded-lg overflow-hidden order-2 md:order-1">
              <Image
                src="https://swhinhgrtcowjmpstozh.supabase.co/storage/v1/object/public/images/pexels-pixabay-235725.jpg"
                alt="Local farmer with fresh produce"
                fill
                className="object-cover"
                sizes="(max-width: 768px) 100vw, 50vw"
                priority
              />
            </div>
            <div className="order-1 md:order-2">
              <h2 className="text-3xl font-semibold mb-6 flex items-center gap-3">
                <span className="bg-[#854D0E] text-white p-2 rounded-full">💼</span>
                <span className="text-[#854D0E]">For Sellers</span>
              </h2>
              <div className="prose prose-lg max-w-none">
                <p className="text-gray-700 leading-relaxed mb-6">
                  List your local goods and reach more customers with Cornucopia's simple digital tools. Whether you're a farmer, artisan, craftsperson, or local producer, get started in minutes by creating your digital market stand. Help customers find you on our interactive map and show them what you have available in real-time.
                </p>
                <p className="text-gray-700 leading-relaxed mb-6">
                  Our platform makes inventory management easy - just update your quantities when they change, and customers will see how fresh and current your listings are. Accept payments your way: integrate our secure QR code system for digital transactions, or stick with traditional payment methods - whatever suits your business.
                </p>
                <p className="text-gray-700 leading-relaxed">
                  The platform is designed to be straightforward and flexible, letting you focus on what matters most: making and selling your products. With Cornucopia, you get modern tools that complement your existing business without complicating it.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>
  );
}
</file>

<file path="app/local/[id]/edit/page.tsx">
import prisma from "lib/db";
import { LocalForm } from "@/components/form/LocalForm";
import { updateLocal } from "@/app/actions/locals";
import { getUser } from "@/lib/auth";
import { notFound, redirect } from "next/navigation";

export default async function EditLocalPage({
  params
}: {
  params: { id: string };
}) {
  const user = await getUser();
  if (!user) {
    redirect("/");
  }

  const local = await prisma.local.findUnique({
    where: {
      id: params.id,
      userId: user.id
    }
  });

  if (!local) {
    notFound();
  }

  const handleSubmit = async (formData: FormData) => {
    "use server";
    await updateLocal(params.id, formData);
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Edit Your Farm/Ranch Profile</h1>
      <LocalForm
        initialData={local}
        onSubmit={handleSubmit}
        buttonText="Save Changes"
      />
    </div>
  );
}
</file>

<file path="app/local/[id]/local-profile.tsx">
'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';
import { Card } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Carousel, CarouselContent, CarouselItem } from '@/components/ui/carousel';
import MapView from '@/components/MapView';
import { ProductGrid } from '@/components/ProductGrid';
import { getLocalProducts, type SerializedProduct } from '@/app/actions/local-products';
import type { Local } from '@prisma/client';

interface LocalProfileProps {
  local: Local;
  isOwner?: boolean;
}

export default function LocalProfile({ local, isOwner = false }: LocalProfileProps) {
  const [activeTab, setActiveTab] = useState('about');
  const [products, setProducts] = useState<SerializedProduct[]>([]);

  useEffect(() => {
    if (activeTab === 'products') {
      getLocalProducts(local.id)
        .then(fetchedProducts => setProducts(fetchedProducts))
        .catch(console.error);
    }
  }, [activeTab, local.id]);

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Hero Section */}
      <div className="relative h-[400px] w-full mb-8">
        {isOwner && (
          <Link
            href={`/local/${local.id}/edit`}
            className="absolute top-4 right-4 z-10 bg-white/90 hover:bg-white text-black px-4 py-2 rounded-md shadow-md transition-colors"
          >
            Edit Profile
          </Link>
        )}
        <Carousel className="w-full h-full">
          <CarouselContent>
            {local.images.map((image, index) => (
              <CarouselItem key={index}>
                <img 
                  src={image} 
                  alt={`${local.name} image ${index + 1}`}
                  className="w-full h-full object-cover rounded-lg"
                />
              </CarouselItem>
            ))}
          </CarouselContent>
        </Carousel>
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent p-6">
          <h1 className="text-4xl font-bold text-white mb-2">{local.name}</h1>
          <p className="text-white/90">{local.description}</p>
        </div>
      </div>

      {/* Main Content */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">
        <TabsList className="grid w-full grid-cols-4 lg:grid-cols-6">
          <TabsTrigger value="about">About</TabsTrigger>
          <TabsTrigger value="products">Products</TabsTrigger>
          <TabsTrigger value="events">Events</TabsTrigger>
          <TabsTrigger value="contact">Contact</TabsTrigger>
        </TabsList>

        <TabsContent value="about" className="space-y-6">
          {/* Farm Story */}
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">About Us</h2>
            <p className="text-gray-700">{local.story || local.description}</p>
          </Card>

          {/* Farming Practices */}
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">Our Farming Practices</h2>
            <p className="text-gray-700">{local.farmingPractices}</p>
          </Card>

          {/* Team Members */}
          {local.teamMembers && (
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Meet the Team</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {Object.entries(local.teamMembers as Record<string, any>).map(([name, role]) => (
                  <div key={name} className="p-4 border rounded-lg">
                    <h3 className="font-semibold">{name}</h3>
                    <p className="text-gray-600">{role}</p>
                  </div>
                ))}
              </div>
            </Card>
          )}

          {/* Certifications */}
          {local.certifications && (
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Certifications & Awards</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {Object.entries(local.certifications as Record<string, any>).map(([cert, details]) => (
                  <div key={cert} className="p-4 border rounded-lg">
                    <h3 className="font-semibold">{cert}</h3>
                    <p className="text-gray-600">{details}</p>
                  </div>
                ))}
              </div>
            </Card>
          )}

          {/* Seasonal Updates */}
          {local.seasonalSchedule && (
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Seasonal Updates</h2>
              <div className="space-y-4">
                {Object.entries(local.seasonalSchedule as Record<string, any>).map(([season, details]) => (
                  <div key={season} className="p-4 border rounded-lg">
                    <h3 className="font-semibold">{season}</h3>
                    <p className="text-gray-600">{details}</p>
                  </div>
                ))}
              </div>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="products">
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">Our Products</h2>
            <ProductGrid 
              initialProducts={products} 
              userLocation={null}
            />
          </Card>
        </TabsContent>

        <TabsContent value="events">
          {local.events && (
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Upcoming Events</h2>
              <div className="space-y-4">
                {Object.entries(local.events as Record<string, any>).map(([event, details]) => (
                  <div key={event} className="p-4 border rounded-lg">
                    <h3 className="font-semibold">{event}</h3>
                    <p className="text-gray-600">{details}</p>
                  </div>
                ))}
              </div>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="contact">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            {/* Contact Information */}
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Contact Information</h2>
              {local.operatingHours && (
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Hours of Operation</h3>
                  <div className="space-y-2">
                    {Object.entries(local.operatingHours as Record<string, any>).map(([day, hours]) => (
                      <div key={day} className="flex justify-between">
                        <span className="font-medium">{day}</span>
                        <span>{hours}</span>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {local.wholesaleInfo && (
                <div className="mb-4">
                  <h3 className="font-semibold mb-2">Wholesale Inquiries</h3>
                  <p className="text-gray-700">{local.wholesaleInfo}</p>
                </div>
              )}

              {local.contactForm && (
                <div className="mt-6">
                  <h3 className="font-semibold mb-4">Contact Form</h3>
                  {/* Add contact form implementation here */}
                </div>
              )}
            </Card>

            {/* Map */}
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Location</h2>
              <div className="h-[400px] rounded-lg overflow-hidden">
                <MapView
                  latitude={local.latitude}
                  longitude={local.longitude}
                  locationName={local.name}
                />
              </div>
              <p className="mt-4 text-gray-700">{local.locationGuide}</p>
            </Card>
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="app/local/[id]/page.tsx">
import prisma from "lib/db";
import LocalProfile from './local-profile';
import { notFound } from "next/navigation";
import { getUser } from "@/lib/auth";

export default async function LocalPage({ params }: { params: { id: string } }) {
  const [local, user] = await Promise.all([
    prisma.local.findUnique({
      where: {
        id: params.id
      }
    }),
    getUser()
  ]);

  if (!local) {
    notFound();
  }

  const isOwner = user?.id === local.userId;

  return <LocalProfile local={local} isOwner={isOwner} />;
}
</file>

<file path="app/local/setup/page.tsx">
import { LocalForm } from "@/components/form/LocalForm";
import { createLocal } from "@/app/actions/locals";
import { getUser } from "@/lib/auth";
import { redirect } from "next/navigation";

export default async function SetupLocalPage() {
  const user = await getUser();
  if (!user) {
    redirect("/");
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Create Your Farm/Ranch Profile</h1>
      <LocalForm onSubmit={createLocal} />
    </div>
  );
}
</file>

<file path="app/market-stand/[id]/edit/page.tsx">
import { redirect } from "next/navigation";
import { unstable_noStore as noStore } from "next/cache";
import prisma from "../../../../lib/db";
import { getUser } from "@/lib/auth";
import { Card } from "../../../../components/ui/card";
import { MarketStandForm } from "../../../../components/form/MarketStandForm";

async function getData(encodedId: string) {
  try {
    const id = decodeURIComponent(encodedId);

    const marketStand = await prisma.marketStand.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        images: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        tags: true,
        userId: true
      }
    });

    if (!marketStand) {
      return null;
    }

    // Ensure data is serializable
    return {
      id: marketStand.id,
      name: marketStand.name,
      description: marketStand.description || '',
      images: marketStand.images,
      locationName: marketStand.locationName,
      locationGuide: marketStand.locationGuide,
      latitude: marketStand.latitude,
      longitude: marketStand.longitude,  
      tags: marketStand.tags || [],
      userId: marketStand.userId
    };
  } catch {
    return null;
  }
}

export default async function EditMarketStandPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();

  // Authentication check
  const user = await getUser();

  if (!user) {
    return redirect("/");
  }

  // Fetch market stand data
  const marketStand = await getData(params.id);

  if (!marketStand) {
    return (
      <div className="max-w-3xl mx-auto px-4 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
        <pre className="mt-4 p-4 bg-gray-100 rounded text-sm overflow-auto">
          Debug Info:
          {JSON.stringify({
            params,
            userId: user.id,
            timestamp: new Date().toISOString()
          }, null, 2)}
        </pre>
      </div>
    );
  }

  // Verify ownership
  if (!marketStand || marketStand.userId !== user.id) {
    return redirect(`/market-stand/${params.id}`); // Use original ID for consistency
  }

  // Format market stand data for the form
  const formattedMarketStand = {
    ...marketStand,
    description: marketStand.description
  };

  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <Card>
        <MarketStandForm 
          userId={user.id} 
          marketStand={formattedMarketStand} 
        />
      </Card>
    </div>
  );
}
</file>

<file path="app/market-stand/[id]/farm-profile.tsx">
'use client';

import { useEffect, useState } from 'react';
import { Card } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Carousel, CarouselContent, CarouselItem } from '@/components/ui/carousel';
import MapView from '@/components/MapView';
import { ProductGrid } from '@/components/ProductGrid';
import { getMarketStandProducts, type SerializedProduct } from '@/app/actions/market-stand-products';
import type { MarketStand } from '@prisma/client';

interface FarmProfileProps {
  marketStand: MarketStand;
}

export default function FarmProfile({ marketStand }: FarmProfileProps) {
  const [activeTab, setActiveTab] = useState('about');
  const [products, setProducts] = useState<SerializedProduct[]>([]);

  useEffect(() => {
    if (activeTab === 'products') {
      getMarketStandProducts(marketStand.id)
        .then(fetchedProducts => setProducts(fetchedProducts))
        .catch(console.error);
    }
  }, [activeTab, marketStand.id]);

  return (
    <div className="container mx-auto px-4 py-8">
      {/* Hero Section */}
      <div className="relative h-[400px] w-full mb-8">
        <Carousel className="w-full h-full">
          <CarouselContent>
            {marketStand.images.map((image, index) => (
              <CarouselItem key={index}>
                <img 
                  src={image} 
                  alt={`${marketStand.name} image ${index + 1}`}
                  className="w-full h-full object-cover rounded-lg"
                />
              </CarouselItem>
            ))}
          </CarouselContent>
        </Carousel>
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent p-6">
          <h1 className="text-4xl font-bold text-white mb-2">{marketStand.name}</h1>
          <p className="text-white/90">{marketStand.description}</p>
        </div>
      </div>

      {/* Main Content */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="about">About</TabsTrigger>
          <TabsTrigger value="products">Products</TabsTrigger>
          <TabsTrigger value="location">Location</TabsTrigger>
        </TabsList>

        <TabsContent value="about" className="space-y-6">
          {/* Description */}
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">About this Farm Stand</h2>
            <p className="text-gray-700">{marketStand.description}</p>
          </Card>

          {/* Tags */}
          {marketStand.tags && marketStand.tags.length > 0 && (
            <Card className="p-6">
              <h2 className="text-2xl font-semibold mb-4">Categories</h2>
              <div className="flex flex-wrap gap-2">
                {marketStand.tags.map((tag, index) => (
                  <div
                    key={index}
                    className="bg-secondary px-3 py-1 rounded-full text-sm"
                  >
                    {tag}
                  </div>
                ))}
              </div>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="products">
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">Our Products</h2>
            <ProductGrid 
              initialProducts={products} 
              userLocation={null}
            />
          </Card>
        </TabsContent>

        <TabsContent value="location">
          <Card className="p-6">
            <h2 className="text-2xl font-semibold mb-4">Location</h2>
            <div className="h-[400px] rounded-lg overflow-hidden mb-4">
              <MapView
                latitude={marketStand.latitude}
                longitude={marketStand.longitude}
                locationName={marketStand.name}
              />
            </div>
            <p className="text-gray-700">{marketStand.locationGuide}</p>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="app/market-stand/[id]/page.tsx">
import prisma from "@/lib/db";
import { unstable_noStore as noStore } from "next/cache";
import Image from "next/image";
import { MapPin, Package, Clock, Navigation, Globe, Twitter, Instagram, Facebook, Youtube, Linkedin } from "lucide-react";
import { WeeklyHours, DAYS_OF_WEEK } from "@/types/hours";
import { ProductCard } from "@/components/ProductCard";
import { Card, CardContent } from "@/components/ui/card";
import { MarketStandHours } from "@/components/MarketStandHours";
import { Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious } from "@/components/ui/carousel";
import MapView from "@/components/MapView";
import { Separator } from "@/components/ui/separator";

async function getData(encodedId: string) {
  try {
    const id = decodeURIComponent(encodedId);

    const marketStand = await prisma.marketStand.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        images: true,
        locationName: true,
        locationGuide: true,
        latitude: true,
        longitude: true,
        userId: true,
        createdAt: true,
        tags: true,
        website: true,
        socialMedia: true,
        hours: true,
        products: {
          select: {
            id: true,
            name: true,
            images: true,
            updatedAt: true,
            price: true,
            inventory: true,
            tags: true,
          }
        },
        user: {
          select: {
            id: true,
            firstName: true,
            profileImage: true,
          }
        }
      }
    });

    if (!marketStand) return null;

    // Serialize dates and validate hours format
    const hours = marketStand.hours as WeeklyHours | null;
    
    return {
      ...marketStand,
      createdAt: marketStand.createdAt.toISOString(),
      products: marketStand.products.map(product => ({
        ...product,
        updatedAt: product.updatedAt.toISOString()
      })),
      hours: hours && DAYS_OF_WEEK.every(day => 
        hours[day] && 
        typeof hours[day].isOpen === 'boolean' && 
        Array.isArray(hours[day].timeSlots)
      ) ? hours : null
    };
  } catch (err) {
    return null;
  }
}

export default async function MarketStandPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  const marketStand = await getData(params.id);

  if (!marketStand) {
    return (
      <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
      <div className="grid lg:grid-cols-3 gap-8">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-8">
          {/* Image Carousel */}
          <div className="relative">
            <Carousel className="w-full">
              <CarouselContent>
                {marketStand.images.map((image, index) => (
                  <CarouselItem key={index}>
                    <div className="aspect-video relative rounded-lg overflow-hidden">
                      <Image
                        src={image}
                        alt={`${marketStand.name} ${index + 1}`}
                        fill
                        className="object-cover"
                        priority={index === 0}
                      />
                    </div>
                  </CarouselItem>
                ))}
              </CarouselContent>
              <CarouselPrevious className="left-4" />
              <CarouselNext className="right-4" />
            </Carousel>
          </div>

          {/* Name and Tags */}
          <div className="space-y-4">
            <h1 className="text-3xl font-bold">{marketStand.name}</h1>
            {marketStand.tags && marketStand.tags.length > 0 && (
              <div className="flex flex-wrap gap-2">
                {marketStand.tags.map((tag, index) => (
                  <div
                    key={index}
                    className="bg-secondary px-2 py-1 rounded-md text-xs"
                  >
                    {tag}
                  </div>
                ))}
              </div>
            )}
          </div>

          {/* Description */}
          <Card>
            <CardContent className="p-6">
              <h2 className="text-xl font-semibold mb-4">About this Market Stand</h2>
              <p className="text-muted-foreground whitespace-pre-wrap">
                {marketStand.description}
              </p>
            </CardContent>
          </Card>

          {/* Products */}
          <div>
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-semibold">Available Products</h2>
              <div className="flex items-center gap-2 text-muted-foreground">
                <Package className="h-4 w-4" />
                <span>{marketStand.products.length} products</span>
              </div>
            </div>
            <div className="grid sm:grid-cols-2 gap-4">
              {marketStand.products.map((product) => (
                <ProductCard
                  key={product.id}
                  id={product.id}
                  name={product.name}
                  images={product.images}
                  locationName={marketStand.locationName}
                  updatedAt={product.updatedAt}
                  inventory={product.inventory}
                  isQRAccess={false}
                  price={product.price}
                  tags={product.tags}
                />
              ))}
            </div>
          </div>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Location Card */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold mb-4">Location</h3>
              <div className="space-y-4">
                <div className="flex items-start gap-3">
                  <MapPin className="h-5 w-5 text-primary mt-0.5" />
                  <div>
                    <p className="font-medium">{marketStand.locationName}</p>
                    <p className="text-sm text-muted-foreground mt-1">
                      {marketStand.locationGuide}
                    </p>
                  </div>
                </div>
                <div className="aspect-video relative rounded-lg overflow-hidden">
                  <MapView 
                    latitude={marketStand.latitude} 
                    longitude={marketStand.longitude}
                    locationName={marketStand.locationName}
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Additional Info Card */}
          <Card>
            <CardContent className="p-6">
              <h3 className="text-lg font-semibold mb-4">Additional Information</h3>
              <div className="space-y-4">
                <div className="flex items-center gap-3">
                  <Clock className="h-5 w-5 text-primary" />
                  <div>
                    <p className="text-sm text-muted-foreground">Member since</p>
                    <p className="font-medium">
                      {new Date(marketStand.createdAt).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <Separator />
                <div className="flex items-center gap-3">
                  <Navigation className="h-5 w-5 text-primary" />
                  <div>
                    <p className="text-sm text-muted-foreground">Coordinates</p>
                    <p className="font-medium">
                      {marketStand.latitude.toFixed(6)}, {marketStand.longitude.toFixed(6)}
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Hours Card */}
          {marketStand.hours && (
            <Card>
              <CardContent className="p-6">
                <MarketStandHours hours={marketStand.hours} />
              </CardContent>
            </Card>
          )}

          {/* Social Media Card */}
          {(marketStand.website || (marketStand.socialMedia && marketStand.socialMedia.length > 0)) && (
            <Card>
              <CardContent className="p-6">
                <h3 className="text-lg font-semibold mb-4">Connect With Us</h3>
                <div className="space-y-4">
                  {marketStand.website && (
                    <a 
                      href={marketStand.website} 
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="flex items-center gap-3 text-primary hover:underline"
                    >
                      <Globe className="h-5 w-5" />
                      <span>Visit our website</span>
                    </a>
                  )}
                  {marketStand.socialMedia && marketStand.socialMedia.map((link, index) => {
                    let icon = <Globe className="h-5 w-5" />;
                    let platform = "Social Media";
                    
                    if (link.includes("twitter.com")) {
                      icon = <Twitter className="h-5 w-5" />;
                      platform = "Twitter";
                    } else if (link.includes("instagram.com")) {
                      icon = <Instagram className="h-5 w-5" />;
                      platform = "Instagram";
                    } else if (link.includes("facebook.com")) {
                      icon = <Facebook className="h-5 w-5" />;
                      platform = "Facebook";
                    } else if (link.includes("youtube.com")) {
                      icon = <Youtube className="h-5 w-5" />;
                      platform = "YouTube";
                    } else if (link.includes("linkedin.com")) {
                      icon = <Linkedin className="h-5 w-5" />;
                      platform = "LinkedIn";
                    }

                    return (
                      <a 
                        key={index}
                        href={link}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="flex items-center gap-3 text-primary hover:underline"
                      >
                        {icon}
                        <span>{platform}</span>
                      </a>
                    );
                  })}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/market-stand/grid/MarketStandsGrid.tsx">
'use client';

import { useState } from 'react';
import { MarketStandViewNav } from "@components/MarketStandViewNav";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@components/ui/select";
import { MarketStandCard } from "@/components/MarketStandCard";
import useUserLocation from "@/app/hooks/useUserLocation";
import { Button } from "@/components/ui/button";
import { type MarketStand } from "@/app/actions/market-stands";

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // Distance in km
}

interface MarketStandsGridProps {
  initialStands: MarketStand[];
}

export function MarketStandsGrid({ initialStands }: MarketStandsGridProps) {
  const [marketStands] = useState<MarketStand[]>(initialStands);
  const [sortOrder, setSortOrder] = useState<'newest' | 'distance'>('newest');
  const { userLocation, locationError, isLoadingLocation, retryLocation } = useUserLocation();

  const sortedStands = [...marketStands].sort((a, b) => {
    switch (sortOrder) {
      case 'newest':
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      case 'distance':
        if (!userLocation) return 0;
        const distA = calculateDistance(userLocation.coords.lat, userLocation.coords.lng, a.latitude, a.longitude);
        const distB = calculateDistance(userLocation.coords.lat, userLocation.coords.lng, b.latitude, b.longitude);
        return distA - distB;
      default:
        return 0;
    }
  });

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Market Stands</h1>
        <p className="text-muted-foreground mt-2">
          Discover local market stands near you
        </p>
      </div>

      {locationError && (
        <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3 flex-grow">
              <p className="text-sm leading-5 text-yellow-700">
                {locationError}
              </p>
            </div>
            <div className="ml-3">
              <Button
                variant="outline"
                size="sm"
                onClick={retryLocation}
                disabled={isLoadingLocation}
              >
                {isLoadingLocation ? 'Retrying...' : 'Retry'}
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
          <MarketStandViewNav currentView="grid" />
          <Select
            value={sortOrder}
            onValueChange={(value: 'newest' | 'distance') => setSortOrder(value)}
            disabled={!userLocation}
          >
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder={userLocation ? "Sort by..." : "Location unavailable"} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="newest">Newest</SelectItem>
              <SelectItem value="distance">Nearest</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-6">
          {sortedStands.map((stand) => (
            <MarketStandCard
              key={stand.id}
              stand={{
                id: stand.id,
                name: stand.name,
                description: stand.description,
                locationName: stand.locationName,
                locationGuide: stand.locationGuide,
                latitude: stand.latitude,
                longitude: stand.longitude,
                images: stand.images,
                tags: stand.tags,
                _count: {
                  products: stand.products.length
                }
              }}
            />
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="app/market-stand/grid/page.tsx">
import { getMarketStands } from "@/app/actions/market-stands";
import { MarketStandsGrid } from "./MarketStandsGrid";
import { Suspense } from "react";

function LoadingGrid() {
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Market Stands</h1>
        <p className="text-muted-foreground mt-2">Loading market stands...</p>
      </div>
      <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-6">
        {[...Array(6)].map((_, i) => (
          <div key={i} className="animate-pulse">
            <div className="bg-gray-200 h-48 rounded-lg mb-4"></div>
            <div className="space-y-3">
              <div className="h-4 bg-gray-200 rounded w-3/4"></div>
              <div className="h-4 bg-gray-200 rounded w-1/2"></div>
            </div>
          </div>
        ))}
      </div>
    </section>
  );
}

export default async function MarketStandsGridPage() {
  const initialStands = await getMarketStands();
  
  return (
    <Suspense fallback={<LoadingGrid />}>
      <MarketStandsGrid initialStands={initialStands} />
    </Suspense>
  );
}
</file>

<file path="app/market-stand/map/loading.tsx">
import { Skeleton } from "../../../components/ui/skeleton";
import { Button } from "../../../components/ui/button";
import { MapIcon, List } from "lucide-react";
import Link from "next/link";

export default function MarketStandsMapLoading() {
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="flex justify-between items-center mb-8">
        <div>
          <h1 className="text-3xl font-bold">Market Stands</h1>
          <p className="text-muted-foreground mt-2">
            Discover local market stands near you
          </p>
        </div>

        <div className="flex items-center gap-4">
          <Link href="/market-stand">
            <Button variant="outline" size="sm">
              <List className="h-4 w-4 mr-2" />
              List View
            </Button>
          </Link>
          <Button variant="default" size="sm" disabled>
            <MapIcon className="h-4 w-4 mr-2" />
            Map View
          </Button>
        </div>
      </div>

      <Skeleton className="w-full h-[600px] rounded-lg" />
    </section>
  );
}
</file>

<file path="app/market-stand/map/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import MarketStandsMap from "@components/MarketStandsMap";
import { MarketStandViewNav } from "@components/MarketStandViewNav";
import useUserLocation from "@/app/hooks/useUserLocation";
import { Button } from "@/components/ui/button";
import { getMarketStands, type MarketStand } from "@/app/actions/market-stands";

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number) {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

export default function MarketStandsMapPage() {
  const [marketStands, setMarketStands] = useState<MarketStand[]>([]);
  const { userLocation, locationError, isLoadingLocation, retryLocation } = useUserLocation();
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    getMarketStands()
      .then(data => {
        setMarketStands(data);
        setIsLoading(false);
      })
      .catch(error => {
        setIsLoading(false);
      });
  }, []);

  const standsWithDistance = marketStands.map(stand => {
    // Ensure dates are serialized as strings
    const serializedStand = {
      ...stand,
      createdAt: new Date(stand.createdAt).toISOString(),
      products: stand.products.map(product => ({
        ...product,
        createdAt: new Date(product.createdAt).toISOString(),
        updatedAt: new Date(product.updatedAt).toISOString(),
      }))
    };

    return {
      ...serializedStand,
      distance: userLocation
        ? calculateDistance(
            userLocation.coords.lat,
            userLocation.coords.lng,
            stand.latitude,
            stand.longitude
          )
        : undefined
    };
  });

  if (isLoading) {
    return (
      <section className="max-w-7xl mx-auto px-4 md:px-8">
        <div className="mb-8">
          <h1 className="text-3xl font-bold">Market Stands Map</h1>
          <p className="text-muted-foreground mt-2">Loading...</p>
        </div>
      </section>
    );
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Market Stands Map</h1>
        <p className="text-muted-foreground mt-2">
          Discover local market stands near you
        </p>
      </div>

      <div className="mb-6">
        <MarketStandViewNav currentView="map" />
      </div>

      {locationError && (
        <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3 flex-grow">
              <p className="text-sm leading-5 text-yellow-700">
                {locationError}
              </p>
            </div>
            <div className="ml-3">
              <Button
                variant="outline"
                size="sm"
                onClick={retryLocation}
                disabled={isLoadingLocation}
              >
                {isLoadingLocation ? 'Retrying...' : 'Retry'}
              </Button>
            </div>
          </div>
        </div>
      )}

      <MarketStandsMap
        marketStands={standsWithDistance}
        userLocation={userLocation ? { lat: userLocation.coords.lat, lng: userLocation.coords.lng } : null}
      />
    </section>
  );
}
</file>

<file path="app/market-stand/page.tsx">
import { redirect } from "next/navigation";

export default function MarketStandsPage() {
  redirect("/market-stand/grid");
}
</file>

<file path="app/navigate/[id]/page.tsx">
import prisma from "../../../lib/db";
import { unstable_noStore as noStore } from "next/cache";
import { MapPin } from "lucide-react";
import MapViewClient from '../../../components/MapViewClient';
import Image from "next/image";

async function getData(id: string) {
  const marketStand = await prisma.marketStand.findUnique({
    where: {
      id: id,
    },
    select: {
      id: true,
      name: true,
      description: true,
      locationName: true,
      locationGuide: true,
      latitude: true,
      longitude: true,
      createdAt: true,
      products: {
        select: {
          id: true,
          name: true,
          price: true,
          inventory: true,
        },
        where: {
          inventory: {
            gt: 0
          }
        },
        take: 3
      },
      user: {
        select: {
          firstName: true,
          lastName: true,
          profileImage: true,
        }
      }
    }
  });

  return marketStand;
}

export default async function NavigatePage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  const marketStand = await getData(decodeURIComponent(params.id));

  if (!marketStand) {
    return (
      <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
        <h1 className="text-2xl font-bold text-center">Market Stand not found</h1>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
      <div className="grid lg:grid-cols-2 gap-8">
        {/* Left Column - Market Stand Details */}
        <div className="space-y-6">
          {/* Header Section */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <div className="flex items-center gap-4 mb-6">
              <div className="relative w-16 h-16">
                <Image
                  src={marketStand.user.profileImage}
                  alt={marketStand.user.firstName}
                  fill
                  className="rounded-full border-2 border-primary object-cover"
                />
              </div>
              <div>
                <h2 className="text-2xl font-bold">{marketStand.name}</h2>
                <p className="text-muted-foreground">
                  Managed by {marketStand.user.firstName} {marketStand.user.lastName}
                </p>
              </div>
            </div>

            {/* Description */}
            {marketStand.description && (
              <div className="mb-6">
                <p className="text-muted-foreground">
                  {marketStand.description}
                </p>
              </div>
            )}

            {/* Location Details */}
            <div className="border-t pt-6">
              <div className="flex items-start gap-3 mb-4">
                <MapPin className="h-5 w-5 text-primary mt-1" />
                <div>
                  <h3 className="font-semibold text-lg mb-1">{marketStand.locationName}</h3>
                  <p className="text-muted-foreground whitespace-pre-line">
                    {marketStand.locationGuide}
                  </p>
                </div>
              </div>
            </div>
          </div>

          {/* Available Products */}
          {marketStand.products.length > 0 && (
            <div className="bg-white rounded-lg shadow-md p-6">
              <h3 className="font-semibold text-lg mb-4">Available Products</h3>
              <div className="space-y-4">
                {marketStand.products.map((product) => (
                  <div key={product.id} className="flex justify-between items-center">
                    <div>
                      <p className="font-medium">{product.name}</p>
                      <p className="text-sm text-muted-foreground">
                        {product.inventory} available
                      </p>
                    </div>
                    <p className="font-medium">
                      ${(product.price / 100).toFixed(2)}
                    </p>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Coordinates Card */}
          <div className="bg-white rounded-lg shadow-md p-6">
            <h3 className="font-semibold text-lg mb-4">GPS Coordinates</h3>
            <div className="grid grid-cols-2 gap-4 mb-6">
              <div>
                <p className="text-sm text-muted-foreground mb-1">Latitude</p>
                <p className="font-mono">{marketStand.latitude.toFixed(6)}</p>
              </div>
              <div>
                <p className="text-sm text-muted-foreground mb-1">Longitude</p>
                <p className="font-mono">{marketStand.longitude.toFixed(6)}</p>
              </div>
            </div>

            {/* Navigation Links */}
            <div className="grid grid-cols-2 gap-4">
              <a
                href={`https://www.google.com/maps/dir/?api=1&destination=${marketStand.latitude},${marketStand.longitude}`}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-3 rounded-md hover:bg-primary/90 transition-colors"
              >
                <MapPin className="h-4 w-4" />
                Google Maps
              </a>
              <a
                href={`https://maps.apple.com/?daddr=${marketStand.latitude},${marketStand.longitude}`}
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-3 rounded-md hover:bg-primary/90 transition-colors"
              >
                <MapPin className="h-4 w-4" />
                Apple Maps
              </a>
            </div>
          </div>
        </div>

        {/* Right Column - Map */}
        <div className="lg:h-[calc(100vh-12rem)] h-[400px] bg-white rounded-lg shadow-md overflow-hidden">
<MapViewClient
  latitude={marketStand.latitude}
  longitude={marketStand.longitude} 
  locationName={marketStand.locationName}
/>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/offline/page.tsx">
import { Button } from "@/components/ui/button";

export const metadata = {
  title: 'Offline - Cornucopia',
  description: 'You are currently offline',
};

export default function OfflinePage() {
  return (
    <main className="flex min-h-screen items-center justify-center px-4">
      <div className="text-center max-w-md">
        <div className="mb-8">
          <svg
            className="mx-auto h-24 w-24 text-gray-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414"
            />
          </svg>
        </div>
        
        <h1 className="text-3xl font-bold text-gray-900 mb-4">
          You're Offline
        </h1>
        
        <p className="text-lg text-gray-600 mb-8">
          It looks like you've lost your internet connection. Some features may not be available until you're back online.
        </p>
        
        <div className="space-y-4">
          <Button
            onClick={() => window.location.reload()}
            size="lg"
            className="w-full"
          >
            Try Again
          </Button>
          
          <p className="text-sm text-gray-500">
            Cached pages and images will still be available while you're offline.
          </p>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="app/our-mission/page.tsx">
import Image from "next/image";
import { Card, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Heart, Sprout, Users, DollarSign } from "lucide-react";

export default function OurMissionPage() {
  const missionPoints = [
    {
      icon: <Sprout className="h-8 w-8 text-primary" />,
      title: "Supporting Local Agriculture",
      description: "We believe in strengthening local food systems by connecting farmers and ranchers directly with their communities."
    },
    {
      icon: <DollarSign className="h-8 w-8 text-primary" />,
      title: "Fair Pricing",
      description: "Our platform ensures producers receive fair compensation for their hard work while keeping local food accessible to consumers."
    },
    {
      icon: <Users className="h-8 w-8 text-primary" />,
      title: "Building Community",
      description: "We foster connections between producers and consumers, creating a stronger, more resilient local food network."
    },
    {
      icon: <Heart className="h-8 w-8 text-primary" />,
      title: "Fresh & Local",
      description: "We make it easier for community members to access fresh, locally-grown food from producers they know and trust."
    }
  ];

  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8 py-12">
      {/* Hero Section */}
      <div className="relative h-[400px] rounded-xl overflow-hidden mb-16">
        <Image
          src="/images/how-it-works/seller.jpg"
          alt="Local farmer in their field"
          fill
          className="object-cover"
          priority
        />
        <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
          <div className="max-w-3xl text-center px-4">
            <h1 className="text-4xl md:text-5xl font-bold text-white mb-6">Our Mission</h1>
            <p className="text-lg md:text-xl text-white/90 leading-relaxed">
              Our mission is to empower small-scale ranchers and farmers to thrive through direct-to-consumer sales. By providing real-time inventory visibility and simplified local food commerce, we help producers capture fair prices for their products while connecting community members to fresh, local food grown by their neighbors.
            </p>
          </div>
        </div>
      </div>

      {/* Mission Points */}
      <div className="grid md:grid-cols-2 gap-8 mb-16">
        {missionPoints.map((point, index) => (
          <Card key={index}>
            <CardContent className="p-6">
              <div className="flex items-start gap-4">
                <div className="flex-shrink-0 p-2 bg-secondary rounded-lg">
                  {point.icon}
                </div>
                <div>
                  <h3 className="text-xl font-semibold mb-2">{point.title}</h3>
                  <p className="text-muted-foreground">{point.description}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Values Section */}
      <div>
        <div className="text-center mb-12">
          <h2 className="text-3xl font-bold mb-4">Our Values</h2>
          <p className="text-muted-foreground max-w-2xl mx-auto">
            These core values guide everything we do in pursuit of our mission.
          </p>
        </div>

        <div className="grid md:grid-cols-3 gap-8">
          <div className="space-y-4">
            <h3 className="text-xl font-semibold">Transparency</h3>
            <Separator className="bg-primary" />
            <p className="text-muted-foreground">
              We believe in clear, honest communication between producers and consumers, fostering trust and understanding in local food systems.
            </p>
          </div>
          <div className="space-y-4">
            <h3 className="text-xl font-semibold">Sustainability</h3>
            <Separator className="bg-primary" />
            <p className="text-muted-foreground">
              We support environmentally conscious farming practices and work to reduce the carbon footprint of food distribution.
            </p>
          </div>
          <div className="space-y-4">
            <h3 className="text-xl font-semibold">Community</h3>
            <Separator className="bg-primary" />
            <p className="text-muted-foreground">
              We prioritize building strong relationships between producers and consumers, creating resilient local food networks.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/payment/cancel/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { XCircle } from "lucide-react";
import Link from "next/link";

export default function CacncelRoute() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <XCircle className="w-12 h-12 rounded-full bg-red-500/30 text-red-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">Payment Canceled</h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Something went wrong with your payment. You havent been charged.
              Please try again.
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/payment/success/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Check } from "lucide-react";
import Link from "next/link";

export default function SuccessRoute() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <Check className="w-12 h-12 rounded-full bg-green-500/30 text-green-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">
              Payment Successful
            </h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Congrats to your purchase! Please check your email for futher
              instructions.
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/product/[id]/edit/loading.tsx">
import { Card } from "@components/ui/card";
import { Skeleton } from "@components/ui/skeleton";

export default function EditProductLoading() {
  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <Card>
        <div className="p-6 space-y-8">
          <div className="space-y-4">
            <Skeleton className="h-8 w-48" />
            <Skeleton className="h-4 w-full max-w-md" />
          </div>

          <div className="space-y-4">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-10 w-full" />
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Skeleton className="h-4 w-16" />
              <Skeleton className="h-10 w-full" />
            </div>
            <div className="space-y-2">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-10 w-full" />
            </div>
          </div>

          <div className="space-y-2">
            <Skeleton className="h-4 w-24" />
            <Skeleton className="h-32 w-full" />
          </div>

          <div className="space-y-4">
            <Skeleton className="h-4 w-32" />
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              <Skeleton className="aspect-square rounded-lg" />
              <Skeleton className="aspect-square rounded-lg" />
              <Skeleton className="aspect-square rounded-lg" />
            </div>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="app/product/[id]/edit/page.tsx">
import { redirect } from "next/navigation";
import { unstable_noStore as noStore } from "next/cache";
import prisma from "@/lib/db";
import { Card } from "@/components/ui/card";
import { SellForm } from "@/components/form/Sellform";
import { getUser } from "@/lib/auth";

async function getProduct(id: string, userId: string) {
  const product = await prisma.product.findUnique({
    where: {
      id: id,
      userId: userId // Ensure user owns the product
    },
    select: {
      id: true,
      name: true,
      description: true,
      price: true,
      images: true,
      marketStandId: true,
      inventory: true,
      inventoryUpdatedAt: true,
      tags: true,
      marketStand: {
        select: {
          id: true,
          name: true,
          description: true,
          images: true,
          latitude: true,
          longitude: true,
          createdAt: true,
          userId: true
        }
      }
    }
  });
  return product;
}

export default async function EditProductPage({
  params,
}: {
  params: { id: string };
}) {
  noStore();
  const user = await getUser();

  if (!user) {
    throw new Error("Authentication required");
  }

  const product = await getProduct(params.id, user.id);

  if (!product) {
    return redirect("/dashboard");
  }

  // Format product data for the form
  const initialData = {
    name: product.name,
    price: product.price / 100, // Convert back to dollars from cents
    description: product.description,
    images: product.images,
    marketStandId: product.marketStandId,
    inventory: product.inventory,
    inventoryUpdatedAt: product.inventoryUpdatedAt,
    tags: product.tags || []
  };

  return (
    <div className="max-w-3xl mx-auto px-4 py-12">
      <Card>
        <SellForm 
          marketStand={product.marketStand}
          initialData={initialData}
          productId={product.id}
        />
      </Card>
    </div>
  );
}
</file>

<file path="app/product/[id]/loading.tsx">
import { Skeleton } from "@components/ui/skeleton";

export default function Loadingfile() {
  return (
    <section className="max-w-7xl mx-auto px-4 sm:px-8 mt-10">
      <div className="w-full grid grid-cols-1 md:grid-cols-2 gap-x-10">
        <div className="col-span-1">
          <Skeleton className="h-[250px] lg:h-[400px] w-full" />
          <Skeleton className="h-[500px] w-full mt-10" />
        </div>

        <div className="col-span-1">
          <Skeleton className="w-full h-[400px]" />
        </div>
      </div>
    </section>
  );
}
</file>

<file path="app/product/[id]/page.tsx">
import { SellProduct } from "@/app/actions";
import { ProductDescription } from "@/components/ProductDescription";
import { BuyButton } from "@/components/SubmitButtons";
import prisma from "@/lib/db";
import { unstable_noStore as noStore } from "next/cache";
import { MapPin, Package, AlertCircle } from "lucide-react";
import Link from "next/link";
import { ProductCard } from "@/components/ProductCard";

import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@/components/ui/carousel";
import { JSONContent } from "@tiptap/react";
import Image from "next/image";

async function getData(id: string, isQRAccess: boolean) {
  const data = await prisma.product.findUnique({
    where: {
      id: id,
    },
    select: {
      description: true,
      name: true,
      images: true,
      price: true,
      updatedAt: true,
      id: true,
      userId: true,
      inventory: true,
      inventoryUpdatedAt: true,
      tags: true,
      user: {
        select: {
          id: true,
          profileImage: true,
          firstName: true,
          connectedAccountId: true,
          stripeConnectedLinked: true,
        },
      },
      marketStand: {
        select: {
          id: true,
          name: true,
          latitude: true,
          longitude: true,
          locationName: true,
          createdAt: true,
          products: {
            where: {
              NOT: {
                id: id
              }
            },
            select: {
              id: true,
              name: true,
              images: true,
              updatedAt: true,
              price: true,
              tags: true,
            },
            take: isQRAccess ? 4 : 0
          }
        }
      }
    },
  });

  if (!data) return null;

  // Serialize dates
  return {
    ...data,
    updatedAt: data.updatedAt.toISOString(),
    inventoryUpdatedAt: data.inventoryUpdatedAt?.toISOString() ?? null,
    marketStand: data.marketStand ? {
      ...data.marketStand,
      createdAt: data.marketStand.createdAt.toISOString(),
      products: data.marketStand.products.map(product => ({
        ...product,
        updatedAt: product.updatedAt.toISOString()
      }))
    } : null
  };
}

export default async function ProductPage({
  params,
  searchParams,
}: {
  params: { id: string };
  searchParams: { [key: string]: string | string[] | undefined };
}) {
  noStore();
  const isQRAccess = searchParams.qr === 'true';
  const data = await getData(decodeURIComponent(params.id), isQRAccess);

  // Convert string description to JSONContent format
  const descriptionContent: JSONContent = {
    type: 'doc',
    content: [
      {
        type: 'paragraph',
        content: [
          {
            type: 'text',
            text: data?.description || ''
          }
        ]
      }
    ]
  };

  return (
    <section className="mx-auto px-4 lg:mt-10 max-w-7xl lg:px-8 lg:grid lg:grid-rows-1 lg:grid-cols-7 lg:gap-x-8 lg:gap-y-10 xl:gap-x-16">
      <Carousel className="lg:row-end-1 lg:col-span-4 relative group rounded-lg">
        <CarouselContent>
          {data?.images.map((item, index) => (
            <CarouselItem key={index}>
              <div className="relative aspect-[4/3] w-full rounded-lg bg-gray-100 overflow-hidden group-hover:shadow-lg transition-all">
                <Image
                  src={item as string}
                  alt={data?.name || "Product image"}
                  fill
                  className="object-cover rounded-lg transition-transform group-hover:scale-105"
                  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  priority={index === 0}
                />
              </div>
            </CarouselItem>
          ))}
        </CarouselContent>
        <CarouselPrevious className="absolute left-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white opacity-0 group-hover:opacity-100 transition-all shadow-md hover:scale-110 hover:shadow-lg" />
        <CarouselNext className="absolute right-4 top-1/2 -translate-y-1/2 bg-white/80 hover:bg-white opacity-0 group-hover:opacity-100 transition-all shadow-md hover:scale-110 hover:shadow-lg" />
      </Carousel>

      <div className="max-w-2xl mx-auto mt-5 lg:max-w-none lg:mt-0 lg:row-end-2 lg:row-span-2 lg:col-span-3">
        <h1 className="text-2xl font-extrabold tracking-tight text-gray-900 sm:text-3xl">
          {data?.name}
        </h1>

        <div className="mt-2 mb-6 space-y-4">
          <p className="text-xl font-bold">
            ${((data?.price || 0) / 100).toFixed(2)}
          </p>
          {data?.tags && data.tags.length > 0 && (
            <div className="flex flex-wrap gap-2">
              {data.tags.map((tag, index) => (
                <div
                  key={index}
                  className="bg-secondary px-2 py-1 rounded-md text-xs"
                >
                  {tag}
                </div>
              ))}
            </div>
          )}
        </div>

        <div className="flex flex-col gap-4">
          {isQRAccess ? (
            <>
              {!data?.user?.stripeConnectedLinked && (
                <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg flex items-start gap-3">
                  <AlertCircle className="h-5 w-5 flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="font-medium">Payment Not Available</p>
                    <p className="text-sm mt-1">
                      This seller hasn&apos;t set up their payment account yet. You can view the product details, but purchases are temporarily unavailable.
                    </p>
                  </div>
                </div>
              )}
              {data?.user?.stripeConnectedLinked && (
                <form action={async (formData: FormData) => {
                  await SellProduct({
                    status: undefined,
                    message: null
                  }, formData);
                }}>
                  <input type="hidden" name="id" value={data?.id} />
                  <BuyButton price={Number(data?.price)} />
                </form>
              )}
            </>
          ) : data?.marketStand ? (
            <>
              <div className="bg-muted p-4 rounded-lg text-sm">
                <h4 className="font-medium mb-2 flex items-center gap-2">
                  <Package className="h-4 w-4" />
                  Visit Market Stand to Purchase
                </h4>
                <p className="text-muted-foreground">
                  To buy this product, visit the market stand and scan the QR code. This helps ensure the product is still available.
                </p>
              </div>
              <Link 
                href={`/navigate/${encodeURIComponent(data.marketStand.id)}`}
                className="inline-flex items-center justify-center gap-2 bg-primary text-primary-foreground px-4 py-2 rounded-md hover:bg-primary/90 transition-colors text-center"
              >
                <MapPin className="h-4 w-4" />
                Get Directions to Market Stand
              </Link>
            </>
          ) : (
            <div className="bg-destructive/10 p-4 rounded-lg text-sm">
              <h4 className="font-medium mb-2 text-destructive">Product Unavailable</h4>
              <p className="text-muted-foreground">
                This product is not currently available at any market stand.
              </p>
            </div>
          )}
        </div>

        <div className="border-t border-gray-200 mt-10 pt-10">
          <div className="grid grid-cols-2 w-full gap-y-3">
            <h3 className="text-sm font-medium text-muted-foreground col-span-1">
              Member since:
            </h3>
            <h3 className="text-sm font-medium col-span-1">
              {data?.marketStand?.createdAt && new Intl.DateTimeFormat("en-US", {
                dateStyle: "long",
              }).format(new Date(data.marketStand.createdAt))}
            </h3>

            <h3 className="text-sm font-medium text-muted-foreground col-span-1">
              Available at:
            </h3>
            <div className="text-sm font-medium col-span-1 space-y-2">
              {!data?.marketStand ? (
                <p className="text-muted-foreground italic">No market stand available</p>
              ) : (
                <div key={data.marketStand.id} className="flex items-start gap-2">
                  <MapPin className="h-4 w-4 mt-0.5 flex-shrink-0" />
                  <div>
                    <p>{data.marketStand.locationName}</p>
                    <p className="text-xs text-muted-foreground">
                      {data.marketStand.name}
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

      </div>

      <div className="w-full max-w-2xl mx-auto mt-16 lg:max-w-none lg:mt-0 lg:col-span-4">
        <ProductDescription content={descriptionContent} />
      </div>

      {isQRAccess && data?.marketStand?.products && data.marketStand?.products.length > 0 && (
        <div className="col-span-7 mt-16">
          <h3 className="text-xl font-semibold mb-6">More from this Market Stand</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            {data.marketStand?.products.map((product) => (
              <ProductCard
                key={product.id}
                id={product.id}
                name={product.name}
                images={product.images}
                locationName={data.marketStand?.locationName ?? ''}
                updatedAt={product.updatedAt}
                isQRAccess={true}
                price={product.price}
                tags={product.tags}
              />
            ))}
          </div>
        </div>
      )}
    </section>
  );
}
</file>

<file path="app/return/[id]/page.tsx">
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Check } from "lucide-react";
import Link from "next/link";

export default function ReturnUrlStripe() {
  return (
    <section className="w-full min-h-[80vh] flex items-center justify-center">
      <Card className="w-[350px]">
        <div className="p-6">
          <div className="w-full flex justify-center">
            <Check className="w-12 h-12 rounded-full bg-green-500/30 text-green-500 p-2" />
          </div>
          <div className="mt-3 text-center sm:mt-5 w-full">
            <h3 className="text-lg leading-6 font-medium">
              Linking was Successful
            </h3>
            <p className="mt-2 text-sm text-muted-foreground">
              Congrats on linking your account to marshal UI. You can now start
              selling your products!
            </p>

            <Button className="mt-5 sm:mt-6 w-full" asChild>
              <Link href="/">Back to Homepage</Link>
            </Button>
          </div>
        </div>
      </Card>
    </section>
  );
}
</file>

<file path="app/sell/loading.tsx">
import { Card, CardHeader } from "@components/ui/card";
import { Skeleton } from "@components/ui/skeleton";

export default function SellRouteLoading() {
  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader className="h-[1000px]">
          <Skeleton className="w-full h-full" />
        </CardHeader>
      </Card>
    </div>
  );
}
</file>

<file path="app/sell/page.tsx">
import { redirect } from "next/navigation";
import { getUser } from "@/lib/auth";

export default async function SellRoute() {
  const user = await getUser();

  if (!user) {
    return redirect('/');
  }

  return redirect('/dashboard/sell');
}
</file>

<file path="app/sell/sell-client.tsx">
"use client";

import { MarketStand } from "@prisma/client";
import { useState } from "react";
import { MarketStandSelect } from "../../components/MarketStandSelect";
import { SellForm } from "../../components/form/Sellform";

export function SellPageClient({ marketStands }: { marketStands: MarketStand[] }) {
  const [selectedStandId, setSelectedStandId] = useState(marketStands[0]?.id);
  const selectedStand = marketStands.find(stand => stand.id === selectedStandId);

  return (
    <>
      <MarketStandSelect 
        stands={marketStands}
        selectedId={selectedStandId}
        onSelect={setSelectedStandId}
      />
      {selectedStand && <SellForm marketStand={selectedStand} />}
    </>
  );
}
</file>

<file path="app/settings/loading.tsx">
import { Card, CardHeader } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

export default function LoadingFile() {
  return (
    <div className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <CardHeader className="h-[500px]">
          <Skeleton className="w-full h-full" />
        </CardHeader>
      </Card>
    </div>
  );
}
</file>

<file path="app/settings/page.tsx">
import { Card } from "@/components/ui/card";
import prisma from "@/lib/db";
import { getUser } from "@/lib/auth";
import { SettingsForm } from "@/components/form/SettingsForm";
import { unstable_noStore as noStore } from "next/cache";

async function getData(userId: string) {
  const data = await prisma.user.findUnique({
    where: {
      id: userId,
    },
    select: {
      firstName: true,
      lastName: true,
      email: true,
    },
  });

  return data;
}

export default async function SetttingsPage() {
  noStore();
  const user = await getUser();
  if (!user) {
    throw new Error("Authentication required");
  }

  const data = await getData(user.id);
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <Card>
        <SettingsForm
          firstName={data?.firstName as string}
          lastName={data?.lastName as string}
          email={data?.email as string}
        />
      </Card>
    </section>
  );
}
</file>

<file path="app/actions.ts">
"use server";
import { z } from "zod";
import prisma from "@/lib/db";
import { getUser } from "@/lib/auth";

// Type for market stand data
interface MarketStandData {
  name: string;
  description?: string;
  images: string[];
  tags: string[];
  locationName: string;
  locationGuide: string;
  latitude: number;
  longitude: number;
  userId: string;
}

// Define the market stand schema with coordinate validation
const marketStandSchema = z.object({
  name: z.string().min(3, { message: "The name has to be a min character length of 3" }),
  description: z.string().min(10, { message: "Please describe your market stand in detail" }).optional(),
  images: z.array(z.string(), { message: "Images are required" }),
  tags: z.array(z.string()).default([]),
  locationName: z.string().min(3, { message: "Location name is required" }),
  locationGuide: z.string().min(10, { message: "Please provide detailed directions to find your stand" })
});

// Function to validate and parse market stand data
function validateMarketStandData(data: Record<string, unknown>): MarketStandData {
  const baseValidation = marketStandSchema.parse(data);
  
  const latStr = String(data.latitude ?? "0");
  const lat = parseFloat(latStr);
  if (isNaN(lat) || lat < -90 || lat > 90) {
    throw new Error("Latitude must be a valid number between -90 and 90 degrees");
  }

  const lngStr = String(data.longitude ?? "0");
  const lng = parseFloat(lngStr);
  if (isNaN(lng) || lng < -180 || lng > 180) {
    throw new Error("Longitude must be a valid number between -180 and 180 degrees");
  }

  if (typeof data.userId !== "string") {
    throw new Error("User ID must be a string");
  }

  return {
    ...baseValidation,
    latitude: lat,
    longitude: lng,
    userId: data.userId
  };
}

const productSchema = z.object({
  name: z
    .string()
    .min(3, { message: "The name has to be a min character length of 3" }),
  price: z.string()
    .transform((val) => {
      const price = parseFloat(val);
      if (isNaN(price)) throw new Error("Price must be a valid number");
      if (price <= 0) throw new Error("Price must be greater than 0");
      return Math.round(price * 100); // Convert dollars to cents for storage
    }),
  description: z
    .string()
    .min(10, { message: "Please describe your product in detail" }),
  images: z.array(z.string(), { message: "Images are required" }),
  tags: z.array(z.string()).default([]),
  marketStandId: z.string({ required_error: "Market stand is required" }),
  inventory: z.string()
    .transform((val) => {
      const num = parseInt(val || "0", 10);
      if (isNaN(num)) throw new Error("Inventory must be a valid number");
      if (num < 0) throw new Error("Inventory cannot be negative");
      return num;
    })
});

export type State = {
  status: "error" | "success" | undefined;
  errors?: {
    name?: string[];
    price?: string[];
    description?: string[];
    images?: string[];
    marketStandId?: string[];
  };
  message: string | null;
};

// Move SellProduct to its own file
export async function SellProduct(
  prevState: State, 
  formData: FormData
): Promise<State | Response> {
  try {
    const productId = formData.get("productId")?.toString() || undefined;
    const user = await getUser();

    if (!user || !user.id) {
      return {
        status: "error",
        message: "Not authenticated or invalid user data"
      };
    }

    // Check if user exists in database
    let dbUser = await prisma.user.findUnique({
      where: { id: user.id }
    });

    // Create user if doesn't exist
    if (!dbUser) {
      dbUser = await prisma.user.create({
        data: {
          id: user.id,
          email: user.email ?? '',
          firstName: user.user_metadata?.name?.split(' ')[0] ?? '',
          lastName: user.user_metadata?.name?.split(' ')[1] ?? '',
          profileImage: user.user_metadata?.avatar_url ?? '',
          connectedAccountId: null,
          stripeConnectedLinked: false
        }
      });
    }

    const rawMarketStandId = formData.get("marketStandId");
    const marketStandId = rawMarketStandId ? rawMarketStandId.toString() : undefined;
    if (!marketStandId) {
      return {
        status: "error",
        errors: { marketStandId: ["Market stand is required"] },
        message: "Market stand is required"
      };
    }

    const validateFields = productSchema.safeParse({
      name: formData.get("name")?.toString() ?? "",
      price: formData.get("price")?.toString() ?? "0",
      description: formData.get("description")?.toString() ?? "",
      images: JSON.parse(formData.get("images") as string),
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      marketStandId: marketStandId,
      inventory: formData.get("inventory")?.toString() ?? "0"
    });

    if (!validateFields.success) {
      return {
        status: "error",
        errors: validateFields.error.flatten().fieldErrors,
        message: "Oops, I think there is a mistake with your inputs."
      };
    }

    // If productId exists, update the product instead of creating a new one
    if (productId) {
      const product = await prisma.product.update({
        where: {
          id: productId,
          userId: user.id, // Ensure user owns the product
        },
        data: {
          name: validateFields.data.name,
          description: validateFields.data.description,
          price: validateFields.data.price,
          images: validateFields.data.images,
          tags: validateFields.data.tags,
          marketStandId: validateFields.data.marketStandId,
          inventory: validateFields.data.inventory,
          inventoryUpdatedAt: new Date()
        }
      });

      if (!product) {
        return {
          status: "error",
          message: "Failed to update product"
        };
      }
    } else {
      // Create new product
      const product = await prisma.product.create({
        data: {
          name: validateFields.data.name,
          description: validateFields.data.description,
          price: validateFields.data.price,
          images: validateFields.data.images,
          tags: validateFields.data.tags,
          userId: user.id,
          marketStandId: validateFields.data.marketStandId,
          inventory: validateFields.data.inventory,
          inventoryUpdatedAt: new Date()
        }
      });

      if (!product) {
        return {
          status: "error",
          message: "Failed to create product"
        };
      }
    }

    // Return success response
    return {
      status: "success",
      message: "Product saved successfully"
    };
  } catch (error) {
    return {
      status: "error",
      message: error instanceof Error ? error.message : "Failed to save product"
    };
  }
}

// Move UpdateMarketStand to its own file
export async function UpdateMarketStand(
  prevState: State, 
  formData: FormData
): Promise<Response> {
  const user = await getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Not authenticated" }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const marketStandId = formData.get("id")?.toString();
  
  if (!marketStandId) {
    return new Response(JSON.stringify({ error: "Market stand ID is required" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const existingStand = await prisma.marketStand.findUnique({
      where: {
        id: marketStandId,
        userId: user.id
      }
    });

    if (!existingStand) {
      return new Response(JSON.stringify({ error: "Market stand not found or you don't have permission to edit it" }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Parse and validate form data
    const rawImages = formData.get("images");
    const rawFormData = {
      name: formData.get("name")?.toString() ?? "",
      description: formData.get("description")?.toString() ?? "",
      images: rawImages ? JSON.parse(rawImages.toString()) : [],
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      locationName: formData.get("locationName")?.toString() ?? "",
      locationGuide: formData.get("locationGuide")?.toString() ?? "",
      latitude: formData.get("latitude")?.toString() ?? "0",
      longitude: formData.get("longitude")?.toString() ?? "0",
      userId: user.id
    };

    // Validate data
    const marketStandData = validateMarketStandData(rawFormData);

    // Perform update
    const marketStand = await prisma.marketStand.update({
      where: {
        id: marketStandId,
        userId: user.id
      },
      data: {
        name: marketStandData.name,
        description: marketStandData.description,
        images: { set: marketStandData.images },
        tags: { set: marketStandData.tags || [] },
        latitude: marketStandData.latitude,
        longitude: marketStandData.longitude,
        locationName: marketStandData.locationName,
        locationGuide: marketStandData.locationGuide,
        userId: marketStandData.userId
      }
    });

    if (!marketStand) {
      return new Response(JSON.stringify({ error: "Failed to update market stand" }), {
        status: 400
      });
    }

    // Return success response
    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    if (error instanceof Error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    return new Response(JSON.stringify({ error: "Failed to update market stand. Please try again." }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

export async function UpdateInventory(
  prevState: State,
  formData: FormData
): Promise<Response> {
  const user = await getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Not authenticated" }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const productId = formData.get("productId")?.toString();
  const inventory = parseInt(formData.get("inventory")?.toString() ?? "0", 10);

  if (!productId) {
    return new Response(JSON.stringify({ error: "Product ID is required" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  if (isNaN(inventory) || inventory < 0) {
    return new Response(JSON.stringify({ error: "Invalid inventory value" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    const product = await prisma.product.update({
      where: {
        id: productId,
        userId: user.id // Ensure user owns the product
      },
      data: {
        inventory,
        inventoryUpdatedAt: new Date()
      }
    });

    if (!product) {
      return new Response(JSON.stringify({ error: "Failed to update inventory" }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch {
    return new Response(JSON.stringify({ error: "Failed to update inventory" }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Move CreateMarketStand to its own file  
export async function CreateMarketStand(
  prevState: State,
  formData: FormData  
): Promise<Response> {
  const user = await getUser();

  if (!user) {
    return new Response(JSON.stringify({ error: "Not authenticated" }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  try {
    // Parse and validate form data
    const rawImages = formData.get("images");
    const rawFormData = {
      name: formData.get("name")?.toString() ?? "",
      description: formData.get("description")?.toString() ?? "",
      images: rawImages ? JSON.parse(rawImages.toString()) : [],
      tags: formData.get("tags") ? JSON.parse(formData.get("tags")?.toString() ?? "[]").map((tag: string) => tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase()) : [],
      locationName: formData.get("locationName")?.toString() ?? "",
      locationGuide: formData.get("locationGuide")?.toString() ?? "",
      latitude: formData.get("latitude")?.toString() ?? "0",
      longitude: formData.get("longitude")?.toString() ?? "0",
      userId: user.id
    };

    const marketStandData = validateMarketStandData(rawFormData);

    // Check if user exists in database
    let dbUser = await prisma.user.findUnique({
      where: { id: user.id }
    });

    // Create user if doesn't exist
    if (!dbUser) {
      dbUser = await prisma.user.create({
        data: {
          id: user.id,
          email: user.email ?? '',
          firstName: user.user_metadata?.name?.split(' ')[0] ?? '',
          lastName: user.user_metadata?.name?.split(' ')[1] ?? '',
          profileImage: user.user_metadata?.avatar_url ?? '',
          connectedAccountId: null,
          stripeConnectedLinked: false
        }
      });
    }

    // Create the market stand
    const result = await prisma.marketStand.create({
      data: {
        name: marketStandData.name,
        description: marketStandData.description,
        images: { set: marketStandData.images },
        tags: { set: marketStandData.tags || [] },
        latitude: marketStandData.latitude,
        longitude: marketStandData.longitude,
        locationName: marketStandData.locationName,
        locationGuide: marketStandData.locationGuide,
        userId: marketStandData.userId
      }
    });

    if (!result) {
      return new Response(JSON.stringify({ error: "Failed to create market stand" }), {
        status: 400
      });
    }

    // Return success response
    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    if (error instanceof Error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    return new Response(JSON.stringify({ error: "Failed to create market stand. Please try again." }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="app/error.tsx">
'use client';

import { Button } from "@/components/ui/button";
import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log the error to an error reporting service
  }, [error]);

  return (
    <div className="min-h-[60vh] flex items-center justify-center">
      <div className="text-center space-y-6">
        <h2 className="text-2xl font-semibold">Something went wrong!</h2>
        <p className="text-muted-foreground max-w-md mx-auto">
          We apologize for the inconvenience. Please try refreshing the page.
        </p>
        <div className="flex gap-4 justify-center">
          <Button 
            onClick={() => window.location.reload()}
            variant="outline"
          >
            Refresh Page
          </Button>
          <Button onClick={reset}>
            Try Again
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 82 23% 32%;
    --primary-foreground: 82 23% 98%;
    --secondary: 82 15% 96.1%;
    --secondary-foreground: 82 47.4% 11.2%;
    --muted: 82 15% 96.1%;
    --muted-foreground: 82 16.3% 46.9%;
    --accent: 82 15% 96.1%;
    --accent-foreground: 82 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 82 31.8% 91.4%;
    --input: 82 31.8% 91.4%;
    --ring: 82 23% 32%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="app/home-client.tsx">
'use client';

import { useState, useCallback, useEffect } from "react";
import { ProductGridClient } from "@/components/ProductGrid/ProductGridClient";
import LoadingStateGrid from "@/components/LoadingStateGrid";
import { ErrorBoundary } from "react-error-boundary";
import ProductError from "@/components/ProductGrid/error";
import { type SerializedProduct, type LocationType, getHomeProducts } from "./actions/home-products";
import { ZipSearchBanner } from "@/components/ZipSearchBanner";

interface HomeClientProps {
  initialProducts: SerializedProduct[];
}

export default function HomeClient({ initialProducts }: HomeClientProps) {
  const [userLocation, setUserLocation] = useState<LocationType | null>(null);
  const [products, setProducts] = useState<SerializedProduct[]>(initialProducts);
  const [isLoading, setIsLoading] = useState(false);
  const [isHydrated, setIsHydrated] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Handle hydration
  useEffect(() => {
    setIsHydrated(true);
  }, []);

  const handleLocationUpdate = useCallback(async (location: LocationType | null) => {
    try {
      setIsLoading(true);
      setError(null);
      console.log('Updating location:', location);
      
      // Set location first to trigger proper loading state
      setUserLocation(location);
      
      // Fetch new products sorted by the new location
      const newProducts = await getHomeProducts(location);
      console.log('New products fetched:', {
        count: newProducts.length,
        hasLocation: !!location
      });
      
      // Only update products if we got a valid response
      if (Array.isArray(newProducts)) {
        setProducts(newProducts);
      } else {
        console.error('Invalid products response:', newProducts);
        setError('Failed to load products. Please try again.');
      }
    } catch (error) {
      console.error('Error updating products:', error);
      setError('Failed to update products. Please try again.');
      
      // Reset location and products on error
      setUserLocation(null);
      setProducts(initialProducts);
    } finally {
      setIsLoading(false);
    }
  }, [initialProducts]);

  if (!isHydrated) {
    return <LoadingStateGrid />;
  }

  return (
    <main>
      <ZipSearchBanner onLocationUpdate={handleLocationUpdate} />
      {error && (
        <div className="max-w-7xl mx-auto px-4 md:px-8 mb-6">
          <div className="bg-red-50 border-l-4 border-red-400 p-4">
            <div className="flex">
              <div className="flex-shrink-0">
                <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                </svg>
              </div>
              <div className="ml-3">
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
          </div>
        </div>
      )}
      <ErrorBoundary FallbackComponent={ProductError}>
        {isLoading ? (
          <LoadingStateGrid />
        ) : (
          <ProductGridClient 
            key={userLocation?.coords.lat || 'no-location'}
            initialProducts={products} 
            userLocation={userLocation}
          />
        )}
      </ErrorBoundary>
    </main>
  );
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Navbar } from "@/components/Navbar";
import { Toaster } from "@/components/ui/sonner";
import { ThemeProvider } from "@/components/providers/ThemeProvider";
import { SupabaseProvider } from "@/components/providers/SupabaseProvider";
import { ProductCacheProvider } from "@/components/providers/ProductCacheProvider";
import { EnvProvider } from "@/components/providers/EnvProvider";
import { PHProvider } from "@/components/providers/PostHogProvider";
import { ServiceWorkerRegistration } from "@/components/ServiceWorkerRegistration";

const inter = Inter({
  subsets: ["latin"],
  display: 'swap',
  preload: true,
  adjustFontFallback: true,
});

export const metadata: Metadata = {
  title: "Cornucopia",
  description: "Your local marketplace for fresh produce and homemade goods",
  icons: {
    icon: [
      {
        url: "/logos/cornucopia-mountain-tree.svg",
        type: "image/svg+xml",
      }
    ]
  }
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <PHProvider>
            <EnvProvider>
              <SupabaseProvider>
                <ProductCacheProvider>
                  <Navbar />
                  {children}
                  <Toaster />
                  <ServiceWorkerRegistration />
                </ProductCacheProvider>
              </SupabaseProvider>
            </EnvProvider>
          </PHProvider>
        </ThemeProvider>
      </body>
    </html>
  );
}
</file>

<file path="app/loading.tsx">
import { ProductGridSkeleton } from "@/components/skeletons/ProductCardSkeleton";

export default function Loading() {
  return (
    <main className="max-w-7xl mx-auto px-4 md:px-8 py-8">
      <div className="mb-8">
        <div className="h-16 bg-gray-200 rounded-lg animate-pulse" />
      </div>
      <ProductGridSkeleton count={12} />
    </main>
  );
}
</file>

<file path="app/page.tsx">
import { Suspense } from "react";
import { redirect } from "next/navigation";
import { getSupabaseServer } from "@/lib/supabase-server";
import HomeClient from "./home-client";
import { getHomeProducts } from "./actions/home-products";
import { ProductGridSkeleton } from "@/components/skeletons/ProductCardSkeleton";

// Enable ISR with 60 second revalidation
export const revalidate = 60;

async function ProductsLoader() {
  try {
    const initialProducts = await getHomeProducts(null);
    return <HomeClient initialProducts={initialProducts} />;
  } catch (error: unknown) {
    console.error('Failed to load products:', error);
    return <HomeClient initialProducts={[]} />;
  }
}

export default async function Home({
  searchParams,
}: {
  searchParams: { returnUrl?: string };
}) {
  const supabase = getSupabaseServer();
  
  // Get session (this is fast, no need to defer)
  const { data: { session } } = await supabase.auth.getSession();

  // Handle authenticated users with returnUrl
  if (session && searchParams.returnUrl) {
    const decodedUrl = decodeURIComponent(searchParams.returnUrl);
    const protectedRoutes = [
      '/sell',
      '/settings',
      '/dashboard/market-stand/setup',
      '/billing',
      '/dashboard/market-stand',
      '/dashboard/sell',
      '/dashboard/settings'
    ];

    // Only redirect to protected routes
    if (protectedRoutes.some(route => decodedUrl.startsWith(route))) {
      redirect(decodedUrl);
    }
  }

  // Stream products with Suspense
  return (
    <Suspense
      fallback={
        <main className="max-w-7xl mx-auto px-4 md:px-8 py-8">
          <div className="mb-8">
            <div className="h-16 bg-gray-200 rounded-lg animate-pulse" />
          </div>
          <ProductGridSkeleton count={12} />
        </main>
      }
    >
      <ProductsLoader key={session?.user?.id || 'anonymous'} />
    </Suspense>
  );
}
</file>

<file path="components/admin/AdminNav.tsx">
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/lib/utils'

interface AdminNavProps {
  isSuperAdmin: boolean
}

export function AdminNav({ isSuperAdmin }: AdminNavProps) {
  const pathname = usePathname()

  return (
    <nav className="hidden sm:ml-6 sm:flex sm:space-x-8" aria-label="Global">
      <NavLink href="/admin">Dashboard</NavLink>
      <NavLink href="/admin/analytics">Analytics</NavLink>
      <NavLink href="/admin/users">Users</NavLink>
      {isSuperAdmin && (
        <NavLink href="/admin/settings">Settings</NavLink>
      )}
    </nav>
  )
}

function NavLink({ href, children }: { href: string, children: React.ReactNode }) {
  const pathname = usePathname()
  const isActive = pathname === href || pathname?.startsWith(`${href}/`)
  
  return (
    <Link
      href={href}
      className={cn(
        "inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium",
        isActive
          ? "border-green-500 text-green-600"
          : "border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700"
      )}
    >
      {children}
    </Link>
  )
}
</file>

<file path="components/dashboard/MarketStandSelector.tsx">
"use client";

import { useState } from "react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface MarketStand {
  id: string;
  name: string;
}

interface MarketStandSelectorProps {
  marketStands: MarketStand[];
  selectedId: string;
  onSelect: (id: string) => void;
}

export function MarketStandSelector({
  marketStands,
  selectedId,
  onSelect,
}: MarketStandSelectorProps) {
  return (
    <div className="w-full max-w-xs">
      <Select value={selectedId} onValueChange={onSelect}>
        <SelectTrigger>
          <SelectValue placeholder="Select a market stand" />
        </SelectTrigger>
        <SelectContent>
          {marketStands.map((stand) => (
            <SelectItem key={stand.id} value={stand.id}>
              {stand.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="components/dashboard/ProductCatalogList.tsx">
"use client";

import Image from "next/image";
import Link from "next/link";
import { Plus, Pencil, Store, Globe } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";

interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
  isOnline: boolean;
  marketStands: Array<{
    id: string;
    name: string;
  }>;
  updatedAt: Date;
}

interface ProductCatalogListProps {
  products: Product[];
}

export function ProductCatalogList({ products }: ProductCatalogListProps) {
  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(price);
  };

  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold">Product Catalog</h1>
        <Link href="/product/new">
          <Button>
            <Plus className="h-4 w-4 mr-2" />
            Add Product
          </Button>
        </Link>
      </div>

      <div className="border rounded-lg">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[300px]">Product</TableHead>
              <TableHead>Price</TableHead>
              <TableHead>Listed At</TableHead>
              <TableHead className="w-[70px]"></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {products.map((product) => (
              <TableRow key={product.id}>
                <TableCell>
                  <div className="flex items-center space-x-4">
                    <div className="relative w-12 h-12 rounded-md overflow-hidden">
                      <Image
                        src={product.image}
                        alt={product.name}
                        fill
                        className="object-cover"
                      />
                    </div>
                    <span className="font-medium">{product.name}</span>
                  </div>
                </TableCell>
                <TableCell>{formatPrice(product.price)}</TableCell>
                <TableCell>
                  <div className="flex flex-wrap gap-2">
                    {product.isOnline && (
                      <Badge variant="secondary" className="flex items-center gap-1">
                        <Globe className="h-3 w-3" />
                        Online
                      </Badge>
                    )}
                    {product.marketStands.map((stand) => (
                      <Badge key={stand.id} variant="outline" className="flex items-center gap-1">
                        <Store className="h-3 w-3" />
                        {stand.name}
                      </Badge>
                    ))}
                  </div>
                </TableCell>
                <TableCell>
                  <Link href={`/product/${product.id}/edit`}>
                    <Button variant="ghost" size="icon" className="h-8 w-8">
                      <Pencil className="h-4 w-4" />
                      <span className="sr-only">Edit product</span>
                    </Button>
                  </Link>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
</file>

<file path="components/dashboard/ProductList.tsx">
"use client";

import Image from "next/image";
import Link from "next/link";
import { ProductQuantityControl } from "./ProductQuantityControl";
import { Pencil, Clock } from "lucide-react";
import { Button } from "@/components/ui/button";
import { formatDistanceToNow } from "date-fns";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

interface Product {
  id: string;
  name: string;
  price: number;
  image: string;
  quantity: number;
  updatedAt: Date;
}

interface ProductListProps {
  products: Product[];
  onQuantityChange: (productId: string, quantity: number) => void;
}

export function ProductList({ products, onQuantityChange }: ProductListProps) {
  const formatPrice = (price: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
    }).format(price);
  };

  return (
    <div className="border rounded-lg">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-[300px]">Product</TableHead>
            <TableHead>Price</TableHead>
            <TableHead>Updated At</TableHead>
            <TableHead className="text-center">Quantity</TableHead>
            <TableHead className="w-[70px]"></TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {products.map((product) => (
            <TableRow key={product.id}>
              <TableCell>
                <div className="flex items-center space-x-4">
                  <div className="relative w-12 h-12 rounded-md overflow-hidden">
                    <Image
                      src={product.image}
                      alt={product.name}
                      fill
                      className="object-cover"
                    />
                  </div>
                  <span className="font-medium">{product.name}</span>
                </div>
              </TableCell>
              <TableCell>{formatPrice(product.price)}</TableCell>
              <TableCell>
                <div className="flex items-center text-muted-foreground">
                  <Clock className="h-4 w-4 mr-2" />
                  {formatDistanceToNow(new Date(product.updatedAt), { addSuffix: true })}
                </div>
              </TableCell>
              <TableCell>
                <div className="flex justify-center">
                  <ProductQuantityControl
                    quantity={product.quantity}
                    onChange={(newQuantity) => onQuantityChange(product.id, newQuantity)}
                  />
                </div>
              </TableCell>
              <TableCell>
                <Link href={`/product/${product.id}/edit`}>
                  <Button variant="ghost" size="icon" className="h-8 w-8">
                    <Pencil className="h-4 w-4" />
                    <span className="sr-only">Edit product</span>
                  </Button>
                </Link>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="components/dashboard/ProductQuantityControl.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Minus, Plus } from "lucide-react";

interface ProductQuantityControlProps {
  quantity: number;
  onChange: (newQuantity: number) => void;
  min?: number;
  max?: number;
}

export function ProductQuantityControl({
  quantity,
  onChange,
  min = 0,
  max = Infinity,
}: ProductQuantityControlProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [inputValue, setInputValue] = useState(quantity.toString());

  useEffect(() => {
    setInputValue(quantity.toString());
  }, [quantity]);

  const handleIncrement = () => {
    const newValue = Math.min(quantity + 1, max);
    onChange(newValue);
  };

  const handleDecrement = () => {
    const newValue = Math.max(quantity - 1, min);
    onChange(newValue);
  };

  const handleInputChange = (value: string) => {
    setInputValue(value);
  };

  const handleInputBlur = () => {
    const newValue = parseInt(inputValue, 10);
    if (!isNaN(newValue)) {
      const clampedValue = Math.min(Math.max(newValue, min), max);
      onChange(clampedValue);
    } else {
      setInputValue(quantity.toString());
    }
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      handleInputBlur();
    }
  };

  return (
    <div className="flex items-center space-x-2">
      <Button
        variant="outline"
        size="icon"
        onClick={handleDecrement}
        disabled={quantity <= min}
        className="h-8 w-8"
      >
        <Minus className="h-4 w-4" />
      </Button>

      {isEditing ? (
        <Input
          type="number"
          value={inputValue}
          onChange={(e) => handleInputChange(e.target.value)}
          onBlur={handleInputBlur}
          onKeyDown={handleKeyDown}
          className="w-16 h-8 text-center"
          autoFocus
        />
      ) : (
        <Button
          variant="ghost"
          onClick={() => setIsEditing(true)}
          className="w-16 h-8 px-2"
        >
          {quantity}
        </Button>
      )}

      <Button
        variant="outline"
        size="icon"
        onClick={handleIncrement}
        disabled={quantity >= max}
        className="h-8 w-8"
      >
        <Plus className="h-4 w-4" />
      </Button>
    </div>
  );
}
</file>

<file path="components/dashboard/Sidebar.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import Image from "next/image";
import {
  LayoutDashboard,
  Store,
  Package,
  ShoppingCart,
  Calendar,
  BarChart2,
  Settings,
  HelpCircle,
  LogOut,
} from "lucide-react";

const menuItems = [
  { name: "Dashboard", icon: LayoutDashboard, href: "/dashboard" },
  { name: "Farm Page Management", icon: Store, href: "/dashboard/farm-page" },
  { name: "Product Catalog", icon: Package, href: "/dashboard/sell" },
  { name: "Market Stand", icon: Store, href: "/dashboard/market-stand" },
  { name: "Orders & Sales", icon: ShoppingCart, href: "/dashboard/orders" },
  { name: "Events & Activities", icon: Calendar, href: "/dashboard/events" },
  { name: "Analytics & Reports", icon: BarChart2, href: "/dashboard/analytics" },
  { name: "Settings", icon: Settings, href: "/dashboard/settings" },
];

const bottomMenuItems = [
  { name: "Support & Help", icon: HelpCircle, href: "/dashboard/support" },
  { name: "Log Out", icon: LogOut, href: "/auth/logout" },
];

export function Sidebar() {
  const pathname = usePathname();

  const isActive = (href: string) => pathname === href || pathname?.startsWith(href + "/");

  return (
    <aside className="fixed left-0 top-0 h-screen w-64 bg-white border-r border-gray-200 flex flex-col">
      <div className="p-4 border-b border-gray-200">
        <Image 
          src="/logos/cornucopia-dark.svg" 
          alt="Cornucopia"
          width={120}
          height={32}
          priority
        />
      </div>
      
      <nav className="flex-1 overflow-y-auto px-3 py-4">
        <div className="space-y-1">
          {menuItems.map((item) => (
            <Link
              key={item.name}
              href={item.href}
              className={`flex items-center space-x-3 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                isActive(item.href)
                  ? "bg-[#8B4513] text-white"
                  : "text-gray-700 hover:bg-gray-100"
              }`}
            >
              <item.icon className="h-5 w-5" />
              <span>{item.name}</span>
            </Link>
          ))}
        </div>
      </nav>

      <div className="border-t border-gray-200 px-3 py-4">
        {bottomMenuItems.map((item) => (
          <Link
            key={item.name}
            href={item.href}
            className="flex items-center space-x-3 px-3 py-2 rounded-lg text-sm font-medium text-gray-700 hover:bg-gray-100"
          >
            <item.icon className="h-5 w-5" />
            <span>{item.name}</span>
          </Link>
        ))}
      </div>
    </aside>
  );
}
</file>

<file path="components/form/AuthForm.tsx">
"use client";

import { useState } from "react";
import { signInWithEmail, signUpWithEmail } from "@/app/actions/auth";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useRouter } from "next/navigation";

export function AuthForm() {
  const [isLoading, setIsLoading] = useState(false);
  const [isSignUp, setIsSignUp] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      if (isSignUp) {
        await signUpWithEmail(email, password);
        // Show confirmation message for sign up
        setError("Please check your email to confirm your account");
      } else {
        await signInWithEmail(email, password);
        router.refresh();
      }
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="w-full max-w-md space-y-8">
      <div className="text-center">
        <h2 className="text-2xl font-bold">
          {isSignUp ? "Create an account" : "Sign in to your account"}
        </h2>
      </div>

      <form onSubmit={handleSubmit} className="mt-8 space-y-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="email">Email address</Label>
            <Input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              className="mt-1"
              disabled={isLoading}
            />
          </div>

          <div>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              name="password"
              type="password"
              autoComplete={isSignUp ? "new-password" : "current-password"}
              required
              className="mt-1"
              disabled={isLoading}
            />
          </div>
        </div>

        {error && (
          <div className="text-sm text-red-500 text-center">{error}</div>
        )}

        <div>
          <Button
            type="submit"
            className="w-full"
            disabled={isLoading}
          >
            {isLoading
              ? "Loading..."
              : isSignUp
              ? "Sign up"
              : "Sign in"}
          </Button>
        </div>

        <div className="text-center">
          <button
            type="button"
            onClick={() => setIsSignUp(!isSignUp)}
            className="text-sm text-blue-600 hover:text-blue-500"
            disabled={isLoading}
          >
            {isSignUp
              ? "Already have an account? Sign in"
              : "Don't have an account? Sign up"}
          </button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="components/form/HoursInput.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import { Plus, Minus } from "lucide-react";
import {
  WeeklyHours,
  DayOfWeek,
  DAYS_OF_WEEK,
  TimeSlot,
  DaySchedule,
  formatTimeSlot
} from "@/types/hours";

interface HoursInputProps {
  value: WeeklyHours;
  onChange: (hours: WeeklyHours) => void;
}

export function HoursInput({ value, onChange }: HoursInputProps) {
  const [error, setError] = useState<string | null>(null);

  const handleDayToggle = (day: DayOfWeek) => {
    onChange({
      ...value,
      [day]: {
        ...value[day],
        isOpen: !value[day].isOpen,
        timeSlots: !value[day].isOpen ? [] : value[day].timeSlots
      }
    });
  };

  const addTimeSlot = (day: DayOfWeek) => {
    onChange({
      ...value,
      [day]: {
        ...value[day],
        timeSlots: [...value[day].timeSlots, { open: "09:00", close: "17:00" }]
      }
    });
  };

  const removeTimeSlot = (day: DayOfWeek, index: number) => {
    const newTimeSlots = [...value[day].timeSlots];
    newTimeSlots.splice(index, 1);
    onChange({
      ...value,
      [day]: {
        ...value[day],
        timeSlots: newTimeSlots
      }
    });
  };

  const updateTimeSlot = (day: DayOfWeek, index: number, field: keyof TimeSlot, newTime: string) => {
    const newTimeSlots = [...value[day].timeSlots];
    newTimeSlots[index] = {
      ...newTimeSlots[index],
      [field]: newTime
    };

    // Validate time slot
    const currentSlot = newTimeSlots[index];
    if (currentSlot.open && currentSlot.close) {
      const openTime = new Date(`1970-01-01T${currentSlot.open}`);
      const closeTime = new Date(`1970-01-01T${currentSlot.close}`);
      
      if (closeTime <= openTime) {
        setError("Closing time must be after opening time");
        return;
      }

      // Check for overlapping time slots
      for (let i = 0; i < newTimeSlots.length; i++) {
        if (i !== index) {
          const otherSlot = newTimeSlots[i];
          const otherOpen = new Date(`1970-01-01T${otherSlot.open}`);
          const otherClose = new Date(`1970-01-01T${otherSlot.close}`);

          if (
            (openTime >= otherOpen && openTime < otherClose) ||
            (closeTime > otherOpen && closeTime <= otherClose) ||
            (openTime <= otherOpen && closeTime >= otherClose)
          ) {
            setError("Time slots cannot overlap");
            return;
          }
        }
      }
    }

    setError(null);
    onChange({
      ...value,
      [day]: {
        ...value[day],
        timeSlots: newTimeSlots
      }
    });
  };

  const formatDayName = (day: string) => {
    return day.charAt(0).toUpperCase() + day.slice(1);
  };

  return (
    <div className="space-y-6">
      {error && (
        <p className="text-sm font-medium text-destructive">{error}</p>
      )}
      
      {DAYS_OF_WEEK.map((day) => (
        <div key={day} className="space-y-4">
          <div className="flex items-center justify-between">
            <Label className="text-base">{formatDayName(day)}</Label>
            <Switch
              checked={value[day].isOpen}
              onCheckedChange={() => handleDayToggle(day)}
            />
          </div>

          {value[day].isOpen && (
            <div className="pl-4 space-y-4">
              {value[day].timeSlots.map((timeSlot, index) => (
                <div key={index} className="flex items-center gap-4">
                  <Input
                    type="time"
                    value={timeSlot.open}
                    onChange={(e) => updateTimeSlot(day, index, 'open', e.target.value)}
                    className="w-32"
                  />
                  <span>to</span>
                  <Input
                    type="time"
                    value={timeSlot.close}
                    onChange={(e) => updateTimeSlot(day, index, 'close', e.target.value)}
                    className="w-32"
                  />
                  <Button
                    type="button"
                    variant="ghost"
                    size="icon"
                    onClick={() => removeTimeSlot(day, index)}
                  >
                    <Minus className="h-4 w-4" />
                  </Button>
                </div>
              ))}
              
              <Button
                type="button"
                variant="outline"
                size="sm"
                onClick={() => addTimeSlot(day)}
                className="mt-2"
              >
                <Plus className="h-4 w-4 mr-2" />
                Add Time Slot
              </Button>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="components/form/LocalForm.tsx">
"use client";

import { useState } from "react";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { ImageUpload } from "@/components/ImageUpload";
import MapViewEditable from "@/components/MapViewEditable";
import { Local } from "@prisma/client";

interface LocalFormProps {
  initialData?: Partial<Local>;
  onSubmit: (data: FormData) => Promise<void>;
  buttonText?: string;
}

export function LocalForm({
  initialData,
  onSubmit,
  buttonText = "Create Profile"
}: LocalFormProps) {
  const [images, setImages] = useState<string[]>(initialData?.images || []);
  const [latitude, setLatitude] = useState(initialData?.latitude || 0);
  const [longitude, setLongitude] = useState(initialData?.longitude || 0);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    formData.append("images", JSON.stringify(images));
    formData.append("latitude", latitude.toString());
    formData.append("longitude", longitude.toString());
    formData.append("teamMembers", JSON.stringify({}));
    formData.append("certifications", JSON.stringify({}));
    formData.append("seasonalSchedule", JSON.stringify({}));
    formData.append("events", JSON.stringify({}));
    formData.append("operatingHours", JSON.stringify({}));
    await onSubmit(formData);
  };

  const handleImageUpload = (urls: string[]) => {
    setImages([...images, ...urls]);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-8">
      <Card className="p-6">
        <div className="space-y-4">
          <div>
            <Label htmlFor="name">Farm/Ranch Name</Label>
            <Input
              id="name"
              name="name"
              defaultValue={initialData?.name || ""}
              required
            />
          </div>

          <div>
            <Label htmlFor="description">Short Description</Label>
            <Textarea
              id="description"
              name="description"
              defaultValue={initialData?.description || ""}
              required
            />
          </div>

          <div>
            <Label htmlFor="story">Our Story</Label>
            <Textarea
              id="story"
              name="story"
              defaultValue={initialData?.story || ""}
              required
            />
          </div>

          <div>
            <Label htmlFor="farmingPractices">Farming Practices</Label>
            <Textarea
              id="farmingPractices"
              name="farmingPractices"
              defaultValue={initialData?.farmingPractices || ""}
              required
            />
          </div>

          <div>
            <Label htmlFor="wholesaleInfo">Wholesale Information</Label>
            <Textarea
              id="wholesaleInfo"
              name="wholesaleInfo"
              defaultValue={initialData?.wholesaleInfo || ""}
            />
          </div>

          <div>
            <Label htmlFor="website">Website</Label>
            <Input
              id="website"
              name="website"
              type="url"
              defaultValue={initialData?.website || ""}
            />
          </div>

          <div>
            <Label htmlFor="socialMedia">Social Media Links (one per line)</Label>
            <Textarea
              id="socialMedia"
              name="socialMedia"
              defaultValue={initialData?.socialMedia?.join("\n") || ""}
              onChange={(e) => {
                const links = e.target.value.split("\n").filter(Boolean);
                e.currentTarget.value = links.join("\n");
              }}
            />
          </div>

          <div>
            <Label>Location</Label>
            <div className="mt-2 space-y-4">
              <Input
                name="locationName"
                placeholder="Location Name"
                defaultValue={initialData?.locationName || ""}
                required
              />
              <Textarea
                name="locationGuide"
                placeholder="Location Guide/Instructions"
                defaultValue={initialData?.locationGuide || ""}
                required
              />
              <div className="h-[400px] rounded-lg overflow-hidden">
                <MapViewEditable
                  latitude={latitude}
                  longitude={longitude}
                  locationName={initialData?.locationName || ""}
                  onLocationChange={(lat: number, lng: number) => {
                    setLatitude(lat);
                    setLongitude(lng);
                  }}
                />
              </div>
            </div>
          </div>

          <div>
            <Label>Images</Label>
            <div className="mt-2">
              <ImageUpload
                onUploadComplete={handleImageUpload}
                maxFiles={5}
                bucket="local-images"
              />
              {images.length > 0 && (
                <div className="mt-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                  {images.map((url, index) => (
                    <div key={index} className="relative group">
                      <img
                        src={url}
                        alt={`Upload ${index + 1}`}
                        className="w-full h-32 object-cover rounded-lg"
                      />
                      <button
                        type="button"
                        onClick={() => setImages(images.filter((_, i) => i !== index))}
                        className="absolute top-2 right-2 bg-red-500 text-white p-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                      >
                        ✕
                      </button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      </Card>

      <Button type="submit" className="ml-auto">
        {buttonText}
      </Button>
    </form>
  );
}
</file>

<file path="components/form/MarketStandForm.tsx">
"use client";

import { CreateMarketStand, UpdateMarketStand } from "@/app/actions/market-stand";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { WeeklyHours, DayHours } from "@/lib/dto/marketStand.dto";

// Default hours that match the DTO/validator structure
const DEFAULT_WEEKLY_HOURS: WeeklyHours = {
  monday: { open: null, close: null, closed: true },
  tuesday: { open: null, close: null, closed: true },
  wednesday: { open: null, close: null, closed: true },
  thursday: { open: null, close: null, closed: true },
  friday: { open: null, close: null, closed: true },
  saturday: { open: null, close: null, closed: true },
  sunday: { open: null, close: null, closed: true },
};
import { HoursInput } from "./HoursInput";

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useEffect, useState } from "react";
import { X } from "lucide-react";
import { toast } from "sonner";
import { Textarea } from "@/components/ui/textarea";
import { ImageUpload } from "@/components/ImageUpload";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";
import Image from "next/image";
import { SubmitStandButton } from "./SubmitStandButton";

interface MarketStandFormProps {
  userId: string;
  marketStand?: {
    id: string;
    name: string;
    description: string;
    images: string[];
    tags: string[];
    latitude: number;
    longitude: number;
    locationName: string;
    locationGuide: string;
    website?: string;
    socialMedia?: string[];
    hours?: WeeklyHours;
  };
  onSuccess?: () => void;
}

interface FormState {
  values: {
    name: string;
    description: string;
    locationName: string;
    locationGuide: string;
    latitude: string;
    longitude: string;
    tags: string[];
    currentTag: string;
    website: string;
    socialMedia: string[];
    currentSocialMedia: string;
    hours: WeeklyHours;
  };
  errors: {
    name?: string;
    description?: string;
    locationName?: string;
    locationGuide?: string;
    latitude?: string;
    longitude?: string;
    images?: string;
    website?: string;
    socialMedia?: string;
    hours?: string;
  };
}

const validateField = (name: string, value: string | string[] | WeeklyHours): string | undefined => {
  // Skip validation for array values and WeeklyHours
  if (Array.isArray(value) || typeof value === 'object') return undefined;
  
  if (!value || value.trim() === '') {
    // Website is optional, so don't require it
    if (name === 'website') return undefined;
    return "This field is required";
  }
  
  switch (name) {
    case "name":
      return value.length < 3 ? "Name must be at least 3 characters long" : undefined;
    case "description":
      return value.length < 10 ? "Must be at least 10 characters long" : undefined;
    case "locationName":
      return value.length < 3 ? "Location name must be at least 3 characters long" : undefined;
    case "locationGuide":
      return value.length < 10 ? "Must provide detailed directions" : undefined;
    case "latitude":
      const lat = parseFloat(value);
      if (isNaN(lat) || lat < -90 || lat > 90) return "Must be between -90 and 90";
      return undefined;
    case "longitude":
      const lng = parseFloat(value);
      if (isNaN(lng) || lng < -180 || lng > 180) return "Must be between -180 and 180";
      return undefined;
    case "website":
      try {
        if (value) {
          new URL(value);
        }
        return undefined;
      } catch {
        return "Must be a valid URL (e.g., https://example.com)";
      }
    default:
      return undefined;
  }
};

export function MarketStandForm({ userId, marketStand, onSuccess }: MarketStandFormProps): JSX.Element {
  const router = useRouter();
  const [images, setImages] = useState<string[]>(marketStand?.images || []);
  const [formState, setFormState] = useState<FormState>({
    values: {
      name: marketStand?.name || '',
      description: marketStand?.description || '',
      locationName: marketStand?.locationName || '',
      locationGuide: marketStand?.locationGuide || '',
      latitude: marketStand?.latitude?.toString() || '',
      longitude: marketStand?.longitude?.toString() || '',
      tags: marketStand?.tags || [],
      currentTag: '',
      website: marketStand?.website || '',
      socialMedia: marketStand?.socialMedia || [],
      currentSocialMedia: '',
      hours: marketStand?.hours || DEFAULT_WEEKLY_HOURS
    },
    errors: {}
  });

  const handleFieldChange = (name: string, value: string) => {
    setFormState(prev => {
      const newErrors = { ...prev.errors };
      const error = validateField(name, value);
      
      if (error) {
        newErrors[name as keyof FormState['errors']] = error;
      } else {
        delete newErrors[name as keyof FormState['errors']];
      }

      return {
        ...prev,
        values: { ...prev.values, [name]: value },
        errors: newErrors
      };
    });
  };

  const removeImage = (indexToRemove: number) => {
    setImages(prev => prev.filter((_, index) => index !== indexToRemove));
  };

  const validateForm = (): boolean => {
    const newErrors: FormState['errors'] = {};
    let isValid = true;

    // Validate required fields only
    const fieldsToValidate = ['name', 'description', 'locationName', 'locationGuide', 'latitude', 'longitude', 'website'];
    fieldsToValidate.forEach(name => {
      const value = formState.values[name as keyof typeof formState.values];
      const error = validateField(name, value);
      if (error) {
        newErrors[name as keyof FormState['errors']] = error;
        isValid = false;
      }
    });

    // Validate images
    if (images.length === 0) {
      newErrors.images = "At least one image is required";
      isValid = false;
    }

    // Validate social media URLs
    const invalidSocialMedia = formState.values.socialMedia.some(url => {
      try {
        new URL(url);
        return false;
      } catch {
        return true;
      }
    });

    if (invalidSocialMedia) {
      newErrors.socialMedia = "All social media links must be valid URLs";
      isValid = false;
    }

    setFormState(prev => ({
      ...prev,
      errors: newErrors
    }));

    return isValid;
  };

  const handleAddTag = () => {
    const tag = formState.values.currentTag.trim();
    if (tag) {
      const capitalizedTag = tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase();
      if (!formState.values.tags.includes(capitalizedTag)) {
        setFormState(prev => ({
          ...prev,
          values: {
            ...prev.values,
            tags: [...prev.values.tags, capitalizedTag],
            currentTag: ''
          }
        }));
      }
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormState(prev => ({
      ...prev,
      values: {
        ...prev.values,
        tags: prev.values.tags.filter(tag => tag !== tagToRemove)
      }
    }));
  };

  const handleAddSocialMedia = () => {
    const link = formState.values.currentSocialMedia.trim();
    if (link) {
      try {
        new URL(link);
        if (!formState.values.socialMedia.includes(link)) {
          setFormState(prev => ({
            ...prev,
            values: {
              ...prev.values,
              socialMedia: [...prev.values.socialMedia, link],
              currentSocialMedia: ''
            }
          }));
        }
      } catch {
        setFormState(prev => ({
          ...prev,
          errors: {
            ...prev.errors,
            socialMedia: "Please enter a valid URL"
          }
        }));
      }
    }
  };

  const handleRemoveSocialMedia = (linkToRemove: string) => {
    setFormState(prev => ({
      ...prev,
      values: {
        ...prev.values,
        socialMedia: prev.values.socialMedia.filter(link => link !== linkToRemove)
      }
    }));
  };

  const handleTagKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };

  const handleSocialMediaKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddSocialMedia();
    }
  };

  const createFormData = () => {
    const formData = new FormData();
    
    // Add all form values manually instead of relying on the form element
    formData.append('name', formState.values.name);
    formData.append('description', formState.values.description);
    formData.append('locationName', formState.values.locationName);
    formData.append('locationGuide', formState.values.locationGuide);
    formData.append('latitude', formState.values.latitude);
    formData.append('longitude', formState.values.longitude);
    formData.append('images', JSON.stringify(images));
    formData.append('tags', JSON.stringify(formState.values.tags));
    formData.append('website', formState.values.website);
    formData.append('socialMedia', JSON.stringify(formState.values.socialMedia));
    formData.append('hours', JSON.stringify(formState.values.hours));
    formData.append('userId', userId);
    
    return formData;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>, retryCount = 0) => {
    e.preventDefault();
    
    if (!validateForm()) {
      toast.error("Please fix the validation errors");
      return;
    }

    const formData = createFormData();

    const maxRetries = 3;
    const retryDelay = 1000; // 1 second

    try {
      if (marketStand) {
        formData.append("id", marketStand.id);
        const result = await UpdateMarketStand({ status: undefined, message: null }, formData);
        
        if (result.success) {
          toast.success("Market stand updated successfully");
          if (onSuccess) {
            onSuccess();
          } else {
            router.push('/dashboard/market-stand/setup');
          }
        } else {
          console.error('Update failed:', result.error);
          if (retryCount < maxRetries) {
            toast.error(`Update failed, retrying... (${retryCount + 1}/${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            await handleSubmit(e, retryCount + 1);
            return;
          }
          toast.error(result.error || "Failed to update market stand");
          return;
        }
      } else {
        const result = await CreateMarketStand({ status: undefined, message: null }, formData);
        
        if (result.success) {
          toast.success("Market stand created successfully");
          if (onSuccess) {
            onSuccess();
          } else {
            router.push('/dashboard/market-stand/setup');
          }
        } else {
          console.error('Creation failed:', result.error);
          if (retryCount < maxRetries) {
            toast.error(`Creation failed, retrying... (${retryCount + 1}/${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            await handleSubmit(e, retryCount + 1);
            return;
          }
          toast.error(result.error || "Failed to create market stand");
          return;
        }
      }
    } catch (error) {
      console.error('Submission error:', error);
      if (retryCount < maxRetries) {
        toast.error(`An error occurred, retrying... (${retryCount + 1}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        await handleSubmit(e, retryCount + 1);
        return;
      }
      toast.error("An error occurred. Please try again.");
    }
  };

  // Validate images when they change
  useEffect(() => {
    if (images.length === 0) {
      setFormState(prev => ({
        ...prev,
        errors: { ...prev.errors, images: "At least one image is required" }
      }));
    } else {
      setFormState(prev => {
        const newErrors = { ...prev.errors };
        delete newErrors.images;
        return { ...prev, errors: newErrors };
      });
    }
  }, [images]);

  const isFormValid = Object.keys(formState.errors).length === 0;

  return (
    <form onSubmit={handleSubmit} className="w-full max-w-4xl mx-auto">
      <CardHeader>
        <CardDescription>
          Please provide details about your market stand
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-8">
        <div className="flex flex-col gap-y-2">
          <Label>Name</Label>
          <Input
            name="name"
            type="text"
            placeholder="Name of your Market Stand"
            required
            minLength={3}
            value={formState.values.name}
            onChange={(e) => handleFieldChange('name', e.target.value)}
            className={formState.errors.name ? 'border-destructive' : ''}
          />
          {formState.errors.name && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.name}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Description</Label>
          <Textarea
            name="description"
            placeholder="Please describe your market stand..."
            required
            minLength={10}
            value={formState.values.description}
            onChange={(e) => handleFieldChange('description', e.target.value)}
            className={formState.errors.description ? 'border-destructive' : ''}
          />
          {formState.errors.description && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.description}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Location Name</Label>
          <Input
            name="locationName"
            type="text"
            placeholder="e.g., Central Park, Downtown Market"
            required
            minLength={3}
            value={formState.values.locationName}
            onChange={(e) => handleFieldChange('locationName', e.target.value)}
            className={formState.errors.locationName ? 'border-destructive' : ''}
          />
          {formState.errors.locationName && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.locationName}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Location Guide</Label>
          <Textarea
            name="locationGuide"
            placeholder="Please provide detailed directions to find your stand..."
            required
            minLength={10}
            value={formState.values.locationGuide}
            onChange={(e) => handleFieldChange('locationGuide', e.target.value)}
            className={formState.errors.locationGuide ? 'border-destructive' : ''}
          />
          {formState.errors.locationGuide && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.locationGuide}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Website (Optional)</Label>
          <Input
            name="website"
            type="url"
            placeholder="https://your-website.com"
            value={formState.values.website}
            onChange={(e) => handleFieldChange('website', e.target.value)}
            className={formState.errors.website ? 'border-destructive' : ''}
          />
          {formState.errors.website && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.website}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2 mb-8">
          <Label>Social Media Links</Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {formState.values.socialMedia.map((link, index) => (
              <div
                key={index}
                className="flex items-center gap-1 bg-secondary px-2 py-1 rounded-md"
              >
                <span className="text-sm truncate max-w-[200px]">{link}</span>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => handleRemoveSocialMedia(link)}
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            ))}
          </div>
          <div className="flex gap-x-2">
            <Input
              type="url"
              placeholder="Add a social media link"
              value={formState.values.currentSocialMedia}
              onChange={(e) => setFormState(prev => ({
                ...prev,
                values: { ...prev.values, currentSocialMedia: e.target.value }
              }))}
              onKeyPress={handleSocialMediaKeyPress}
            />
            <Button
              type="button"
              onClick={handleAddSocialMedia}
              disabled={!formState.values.currentSocialMedia.trim()}
            >
              Add
            </Button>
          </div>
          {formState.errors.socialMedia && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.socialMedia}</p>
          )}
        </div>

        <div className="flex flex-col gap-y-2 mb-8">
          <Label>Tags</Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {formState.values.tags.map((tag, index) => (
              <div
                key={index}
                className="flex items-center gap-1 bg-secondary px-2 py-1 rounded-md"
              >
                <span>{tag}</span>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => handleRemoveTag(tag)}
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            ))}
          </div>
          <div className="flex gap-x-2">
            <Input
              type="text"
              placeholder="Add a tag"
              value={formState.values.currentTag}
              onChange={(e) => setFormState(prev => ({
                ...prev,
                values: { ...prev.values, currentTag: e.target.value }
              }))}
              onKeyPress={handleTagKeyPress}
            />
            <Button
              type="button"
              onClick={handleAddTag}
              disabled={!formState.values.currentTag.trim()}
            >
              Add
            </Button>
          </div>
        </div>

        {/* TODO: Fix HoursInput component to match DTO structure */}
        {/* <div className="flex flex-col gap-y-2">
          <Label>Operating Hours</Label>
          <HoursInput
            value={formState.values.hours || DEFAULT_WEEKLY_HOURS}
            onChange={(hours) => {
              setFormState(prev => ({
                ...prev,
                values: { ...prev.values, hours }
              }));
            }}
          />
          {formState.errors.hours && (
            <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.hours}</p>
          )}
        </div> */}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
          <div className="flex flex-col gap-y-2">
            <Label>Latitude</Label>
            <Input
              name="latitude"
              type="number"
              step="any"
              placeholder="e.g., 40.7128"
              required
              value={formState.values.latitude}
              onChange={(e) => handleFieldChange('latitude', e.target.value)}
              className={formState.errors.latitude ? 'border-destructive' : ''}
            />
            {formState.errors.latitude && (
              <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.latitude}</p>
            )}
          </div>

          <div className="flex flex-col gap-y-2">
            <Label>Longitude</Label>
            <Input
              name="longitude"
              type="number"
              step="any"
              placeholder="e.g., -74.0060"
              required
              value={formState.values.longitude}
              onChange={(e) => handleFieldChange('longitude', e.target.value)}
              className={formState.errors.longitude ? 'border-destructive' : ''}
            />
            {formState.errors.longitude && (
              <p className="text-sm font-medium text-destructive mt-1.5">{formState.errors.longitude}</p>
            )}
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Market Stand Images</Label>
          {formState.errors.images && (
            <p className="text-sm font-medium text-destructive mb-2">{formState.errors.images}</p>
          )}
          {images.length > 0 && (
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
              {images.map((url, index) => (
                <div key={index} className="relative aspect-square group">
                  <Image
                    src={url}
                    alt={`Market stand image ${index + 1}`}
                    className="object-cover rounded-lg"
                    fill
                    sizes="(max-width: 768px) 50vw, 33vw"
                      onError={(e) => {
                        // Replace with placeholder
                        e.currentTarget.style.display = 'none';
                        const parent = e.currentTarget.parentElement;
                        if (parent) {
                          const placeholder = document.createElement('div');
                          placeholder.className = 'flex flex-col items-center justify-center h-full';
                          placeholder.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mb-2 text-muted-foreground">
                              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                              <circle cx="8.5" cy="8.5" r="1.5"></circle>
                              <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <span class="text-sm text-muted-foreground">Image not available</span>
                          `;
                          parent.appendChild(placeholder);
                        }
                    }}
                  />
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => removeImage(index)}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}
          <ImageUpload
            onUploadComplete={(urls) => {
              if (urls && urls.length > 0) {
                setImages(prev => [...prev, ...urls]);
                toast.success("Images uploaded successfully");
              }
            }}
            maxFiles={5}
            bucket="market-stand-images"
          />
        </div>
      </CardContent>
      <CardFooter className="mt-5">
        <div className="flex-1 flex justify-end">
          <SubmitStandButton 
            title={marketStand ? "Save Changes" : "Create Market Stand"}
            isFormValid={isFormValid}
          />
        </div>
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/Sellform.tsx">
"use client";

import { SellProduct, type State } from "@/app/actions";
import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useFormState } from "react-dom";
import { X } from "lucide-react";
import { toast } from "sonner";
import { Textarea } from "@/components/ui/textarea";
import { ImageUpload } from "@/components/ImageUpload";
import { Submitbutton } from "@/components/SubmitButtons";
import Image from "next/image";

interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  latitude: number;
  longitude: number;
  createdAt: Date;
  userId: string | null;
}

interface SellFormProps {
  marketStand?: MarketStand;
  initialData?: {
    name: string;
    price: number;
    description: string;
    images: string[];
    tags: string[];
    marketStandId: string;
    inventory?: number;
    inventoryUpdatedAt?: Date | null;
  };
  productId?: string;
}

function isState(state: State | Response): state is State {
  return (state as State).status !== undefined;
}

const sellProductAction = async (state: State | Response, formData: FormData) => {
  const result = await SellProduct(state as State, formData);
  return result;
};

export function SellForm({ marketStand, initialData, productId }: SellFormProps) {
  const initialState: State = { message: null, status: undefined };
  const [state, formAction] = useFormState(sellProductAction, initialState);
  const [images, setImages] = useState<string[]>(initialData?.images || []);
  const [tags, setTags] = useState<string[]>(initialData?.tags || []);
  const [currentTag, setCurrentTag] = useState('');

  const handleAddTag = () => {
    const tag = currentTag.trim();
    if (tag) {
      const capitalizedTag = tag.charAt(0).toUpperCase() + tag.slice(1).toLowerCase();
      if (!tags.includes(capitalizedTag)) {
        setTags(prev => [...prev, capitalizedTag]);
        setCurrentTag('');
      }
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setTags(prev => prev.filter(tag => tag !== tagToRemove));
  };

  const handleTagKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };
  
  const router = useRouter();

  useEffect(() => {
    if (isState(state) && state.status === "success" && state.message) {
      toast.success(state.message);
      router.push('/dashboard/sell');
    } else if (isState(state) && state.status === "error" && state.message) {
      if (state.message.includes("Stripe account")) {
        toast.error(
          <div className="flex flex-col gap-2">
            <p>{state.message}</p>
            <Link href="/billing" className="text-sm text-blue-500 hover:underline">
              Go to billing settings
            </Link>
          </div>
        );
      } else {
        toast.error(state.message);
      }
    }
  }, [state, router]);

  return (
    <form action={formAction}>
      <CardHeader>
        <CardTitle>{productId ? 'Edit your product' : 'Sell your product with ease'}</CardTitle>
        <CardDescription>
          Please describe your product here in detail so that it can be sold
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-8">
        <div className="flex flex-col gap-y-2">
          <Label htmlFor="name">Name</Label>
          <Input
            id="name"
            name="name"
            type="text"
            placeholder="Name of your Product"
            required
            minLength={3}
            defaultValue={initialData?.name}
            aria-label="Product name"
          />
          {isState(state) && state.errors?.name?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.name[0]}</p>
          )}
        </div>

        {productId && <input type="hidden" name="productId" value={productId} />}
        <input 
          type="hidden" 
          name="marketStandId" 
          value={initialData?.marketStandId || marketStand?.id} 
        />

        {marketStand && (
          <div className="flex flex-col gap-y-4">
            <Label>Market Stand</Label>
            <div className="p-4 border rounded-lg">
              <h3 className="font-medium">{marketStand.name}</h3>
              <p className="text-sm text-muted-foreground mt-1">
                {marketStand.description || 'No description'}
              </p>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
          <div className="flex flex-col gap-y-2">
            <Label htmlFor="price">Price</Label>
            <Input
              id="price"
              placeholder="29.99"
              type="text"
              pattern="^\d*\.?\d{0,2}$"
              name="price"
              required
              defaultValue={initialData ? (initialData.price / 100).toFixed(2) : undefined}
              aria-label="Product price"
              title="Enter a valid price with up to 2 decimal places"
            />
            {isState(state) && state.errors?.price?.[0] && (
              <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.price[0]}</p>
            )}
          </div>

          <div className="flex flex-col gap-y-2">
            <Label htmlFor="inventory">Initial Inventory</Label>
            <Input
              id="inventory"
              placeholder="0"
              type="number"
              name="inventory"
              min={0}
              defaultValue={initialData?.inventory ?? 0}
              aria-label="Initial inventory amount"
            />
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <Label htmlFor="description">Description</Label>
          <Textarea
            id="description"
            name="description"
            placeholder="Please describe your product in detail..."
            required
            minLength={10}
            defaultValue={initialData?.description}
            aria-label="Product description"
          />
          {isState(state) && state.errors?.description?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">
              {state.errors.description[0]}
            </p>
          )}
        </div>

        <div className="flex flex-col gap-y-2 mb-8">
          <Label>Tags</Label>
          <div className="flex flex-wrap gap-2 mb-2">
            {tags.map((tag, index) => (
              <div
                key={index}
                className="flex items-center gap-1 bg-secondary px-2 py-1 rounded-md"
              >
                <span>{tag}</span>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="h-4 w-4 p-0 hover:bg-transparent"
                  onClick={() => handleRemoveTag(tag)}
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            ))}
          </div>
          <div className="flex gap-x-2">
            <Input
              type="text"
              placeholder="Add a tag"
              value={currentTag}
              onChange={(e) => setCurrentTag(e.target.value)}
              onKeyPress={handleTagKeyPress}
            />
            <Button
              type="button"
              onClick={handleAddTag}
              disabled={!currentTag.trim()}
            >
              Add
            </Button>
          </div>
        </div>

        <div className="flex flex-col gap-y-2">
          <input type="hidden" name="images" value={JSON.stringify(images)} />
          <input type="hidden" name="tags" value={JSON.stringify(tags)} />
          <Label>Product Images</Label>
          {images.length > 0 && (
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
              {images.map((url, index) => (
                <div key={index} className="relative w-full h-48 group">
                  <Image
                    src={url}
                    alt={`Product image ${index + 1}`}
                    fill
                    sizes="(max-width: 768px) 50vw, 33vw"
                    className="rounded-lg object-cover"
                  />
                  <Button
                    type="button"
                    variant="destructive"
                    size="icon"
                    className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => setImages(images.filter((_, i) => i !== index))}
                    aria-label={`Remove image ${index + 1}`}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}
          <ImageUpload
            onUploadComplete={(urls) => {
              setImages(prev => [...prev, ...urls]);
              toast.success("Images uploaded successfully");
            }}
            maxFiles={5}
          />
          {isState(state) && state.errors?.images?.[0] && (
            <p className="text-sm font-medium text-destructive mt-1.5">{state.errors.images[0]}</p>
          )}
        </div>
      </CardContent>
      <CardFooter className="mt-5">
        <Submitbutton title={productId ? "Save Changes" : "Create your Product"} />
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/SettingsForm.tsx">
"use client";

import {
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

import { useFormState } from "react-dom";

import { useEffect } from "react";
import { toast } from "sonner";
import { type State, UpdateUserSettings } from "@/app/actions/settings";
import { Submitbutton } from "../SubmitButtons";

interface iAppProps {
  firstName: string;
  lastName: string;
  email: string;
}

export function SettingsForm({ email, firstName, lastName }: iAppProps) {
  const initalState: State = { message: "", status: undefined };
  const [state, formAction] = useFormState(UpdateUserSettings, initalState);

  useEffect(() => {
    if (state?.status === "error") {
      toast.error(state.message);
    } else if (state?.status === "success") {
      toast.success(state.message);
    }
  }, [state]);
  return (
    <form action={formAction}>
      <CardHeader>
        <CardTitle>Settings</CardTitle>
        <CardDescription>
          Here you will find settings regarding your account
        </CardDescription>
      </CardHeader>
      <CardContent className="flex flex-col gap-y-5">
        <div className="flex flex-col gap-y-2">
          <Label>First Name</Label>
          <Input name="firstName" type="text" defaultValue={firstName} />
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Last Name</Label>
          <Input name="lastName" type="text" defaultValue={lastName} />
        </div>

        <div className="flex flex-col gap-y-2">
          <Label>Email</Label>
          <Input
            name="email"
            type="email"
            disabled
            defaultValue={email}
          />
        </div>
      </CardContent>
      <CardFooter>
        <Submitbutton title="Update your settings" />
      </CardFooter>
    </form>
  );
}
</file>

<file path="components/form/SubmitStandButton.tsx">
"use client";

import { useFormStatus } from "react-dom";
import { Button } from "../ui/button";

interface SubmitStandButtonProps {
  title: string;
  isFormValid: boolean;
}

export function SubmitStandButton({ title, isFormValid }: SubmitStandButtonProps) {
  const { pending } = useFormStatus();
  
  return (
    <Button 
      type="submit"
      disabled={!isFormValid || pending}
      className="min-w-[150px]"
    >
      {pending ? "Submitting..." : title}
    </Button>
  );
}
</file>

<file path="components/ProductGrid/error.tsx">
'use client';

import { Button } from "../ui/button";
import { useEffect } from "react";
import { FallbackProps } from "react-error-boundary";

export default function ProductError({ error, resetErrorBoundary }: FallbackProps) {
  useEffect(() => {
    // Log the error to an error reporting service
  }, [error]);

  return (
    <div className="text-center py-12">
      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Error Loading Products</h2>
        <p className="text-muted-foreground">
          Sorry, there was a problem loading the products.
        </p>
        <Button 
          onClick={resetErrorBoundary}
          variant="outline"
        >
          Try Again
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="components/ProductGrid/index.tsx">
export { ProductGridClient as ProductGrid } from "./ProductGridClient";
</file>

<file path="components/ProductGrid/ProductGridClient.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { ProductCard } from "@/components/ProductCard";
import useUserLocation from "@/app/hooks/useUserLocation";
import { Button } from "@/components/ui/button";
import { getHomeProducts, type SerializedProduct, type LocationType } from "@/app/actions/home-products";
import LoadingStateGrid from "@/components/LoadingStateGrid";

interface ProductGridClientProps {
  initialProducts: SerializedProduct[];
  userLocation: LocationType | null;
}

export function ProductGridClient({ initialProducts, userLocation }: ProductGridClientProps) {
  const [products, setProducts] = useState(() => {
    try {
      console.log('Initializing products state with:', {
        hasLocation: !!userLocation,
        initialProductsCount: initialProducts.length
      });
      
      // Initialize products state once during component mount
      if (userLocation) {
        const local = initialProducts.filter(p => p.distance !== null && p.distance <= 160.934);
        const explore = initialProducts.filter(p => p.distance === null || p.distance > 160.934);
        console.log('Initial products split:', {
          localCount: local.length,
          exploreCount: explore.length
        });
        return {
          local,
          explore,
          lastId: explore.length > 0 ? explore[explore.length - 1].id : undefined
        };
      }
      return {
        local: [],
        explore: initialProducts,
        lastId: initialProducts.length > 0 ? initialProducts[initialProducts.length - 1].id : undefined
      };
    } catch (error) {
      console.error('Error initializing products state:', error);
      // Provide a safe fallback state
      return {
        local: [],
        explore: [],
        lastId: undefined
      };
    }
  });
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { locationError, isLoadingLocation, retryLocation } = useUserLocation();
  const isHydrated = useRef(false);

  // Set hydration state
  useEffect(() => {
    isHydrated.current = true;
  }, []);

  // Update products when location or initial data changes
  useEffect(() => {
    try {
      console.log('Updating products state:', {
        hasLocation: !!userLocation,
        initialProductsCount: initialProducts.length
      });

      if (userLocation) {
        const local = initialProducts.filter(p => p.distance !== null && p.distance <= 160.934);
        const explore = initialProducts.filter(p => p.distance === null || p.distance > 160.934);
        console.log('Updated products split:', {
          localCount: local.length,
          exploreCount: explore.length
        });
        setProducts({
          local,
          explore,
          lastId: explore.length > 0 ? explore[explore.length - 1].id : undefined
        });
      } else {
        setProducts({
          local: [],
          explore: initialProducts,
          lastId: initialProducts.length > 0 ? initialProducts[initialProducts.length - 1].id : undefined
        });
      }
    } catch (error) {
      console.error('Error updating products state:', error);
      // Don't update state on error to prevent reverting to explore-only view
    }
  }, [initialProducts, userLocation]);

  const loadMoreProducts = async () => {
    if (!products.lastId) return;
    
    try {
      setIsLoading(true);
      setError(null);
      console.log('Loading more products with cursor:', products.lastId);
      const newProducts = await getHomeProducts(userLocation, products.lastId);
      console.log('Loaded additional products:', newProducts.length);
      
      if (newProducts.length > 0) {
        setProducts(prev => {
          const updatedState = {
            ...prev,
            explore: [...prev.explore, ...newProducts],
            lastId: newProducts[newProducts.length - 1].id
          };
          console.log('Updated products state:', {
            localCount: updatedState.local.length,
            exploreCount: updatedState.explore.length
          });
          return updatedState;
        });
      }
    } catch (err) {
      console.error('Error loading more products:', err);
      setError('Failed to load more products');
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return <LoadingStateGrid />;
  }

  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      {locationError && (
        <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3 flex-grow">
              <p className="text-sm leading-5 text-yellow-700">
                {locationError}
              </p>
            </div>
            <div className="ml-3">
              <Button
                variant="outline"
                size="sm"
                onClick={retryLocation}
                disabled={isLoadingLocation}
              >
                {isLoadingLocation ? 'Retrying...' : 'Retry'}
              </Button>
            </div>
          </div>
        </div>
      )}

      {userLocation && (
        <>
          <h2 className="text-2xl font-bold mb-6">Local Products</h2>
          {products.local.length > 0 ? (
            <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-10 mb-12">
              {products.local.map((product) => (
                <ProductCard
                  key={product.id}
                  id={product.id}
                  name={product.name}
                  images={product.images}
                  locationName={product.marketStand.locationName}
                  updatedAt={product.updatedAt}
                  price={product.price}
                  tags={product.tags}
                  distance={product.distance}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-12 bg-gray-50 rounded-lg mb-12">
              <h3 className="text-xl font-semibold mb-4">No Local Products Yet</h3>
              <p className="text-gray-600 mb-6">Be the first to sell products in your area!</p>
              <Button
                onClick={() => window.location.href = '/market-stand/setup'}
                size="lg"
                className="bg-primary hover:bg-primary/90"
              >
                Become the First
              </Button>
            </div>
          )}
        </>
      )}

      {(!userLocation || products.local.length < 15) && products.explore.length > 0 && (
        <>
          <h2 className="text-2xl font-bold mb-6">Explore Products</h2>
          <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-10">
            {products.explore.map((product) => (
              <ProductCard
                key={product.id}
                id={product.id}
                name={product.name}
                images={product.images}
                locationName={product.marketStand.locationName}
                updatedAt={product.updatedAt}
                price={product.price}
                tags={product.tags}
                distance={product.distance}
              />
            ))}
          </div>
        </>
      )}

      {error && (
        <div className="text-center mt-6">
          <p className="text-red-500">{error}</p>
        </div>
      )}

      {products.explore.length >= 12 && (
        <div className="flex justify-center mt-8">
          <Button
            onClick={loadMoreProducts}
            disabled={isLoading}
            variant="outline"
            size="lg"
          >
            {isLoading ? 'Loading...' : 'Load More'}
          </Button>
        </div>
      )}
    </section>
  );
}
</file>

<file path="components/providers/EnvProvider.tsx">
// Import and execute env module first to ensure environment variables are loaded
import '@/lib/env';

// Then import other dependencies that might need environment variables
import { config } from '@/lib/config';
import { env } from '@/lib/env';

export function EnvProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // Log environment status in development
  if (process.env.NODE_ENV !== 'production') {
    console.log('Environment variables loaded:', {
      databaseUrl: env.DATABASE_URL ? 'set' : 'missing',
      supabaseUrl: env.SUPABASE_URL ? 'set' : 'missing',
      appUrl: env.APP_URL ? 'set' : 'missing',
    });
  }

  return <>{children}</>;
}
</file>

<file path="components/providers/PostHogProvider.tsx">
'use client'

// Create a mock PostHog provider that doesn't do anything
// This prevents errors when PostHog is not properly configured

export function PHProvider({ children }: { children: React.ReactNode }) {
  // Simply render children without any PostHog functionality
  return <>{children}</>;
}
</file>

<file path="components/providers/ProductCacheProvider.tsx">
'use client';

import { createContext, useContext, useCallback, ReactNode } from 'react';
import { SerializedProduct } from '@/app/actions/home-products';

interface CacheEntry {
  products: SerializedProduct[];
  timestamp: number;
  cursor?: string;
}

interface LocationCacheData {
  local: CacheEntry;
  explore: CacheEntry;
}

type LocationCache = Map<string, LocationCacheData>;

interface ProductCacheContextType {
  getCachedProducts: (location: { lat: number; lng: number } | null, cursor?: string) => SerializedProduct[] | null;
  cacheProducts: (products: SerializedProduct[], location: { lat: number; lng: number } | null, cursor?: string) => void;
  invalidateCache: () => void;
}

const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds

const ProductCacheContext = createContext<ProductCacheContextType | null>(null);

function getLocationHash(location: { lat: number; lng: number } | null): string {
  if (!location) return 'no-location';
  // Round coordinates to 2 decimal places for cache grouping
  const lat = Math.round(location.lat * 100) / 100;
  const lng = Math.round(location.lng * 100) / 100;
  return `${lat},${lng}`;
}

export function ProductCacheProvider({ children }: { children: ReactNode }) {
  const getCachedProducts = useCallback((location: { lat: number; lng: number } | null, cursor?: string): SerializedProduct[] | null => {
    if (typeof window === 'undefined') return null;

    try {
      const locationHash = getLocationHash(location);
      const cacheKey = `products-${locationHash}${cursor ? `-${cursor}` : ''}`;
      const cachedData = localStorage.getItem(cacheKey);
      
      if (!cachedData) return null;

      const { products, timestamp } = JSON.parse(cachedData);
      const now = Date.now();

      // Check if cache is still valid
      if (now - timestamp > CACHE_DURATION) {
        localStorage.removeItem(cacheKey);
        return null;
      }

      return products;
    } catch (error) {
      return null;
    }
  }, []);

  const cacheProducts = useCallback((products: SerializedProduct[], location: { lat: number; lng: number } | null, cursor?: string) => {
    if (typeof window === 'undefined') return;

    try {
      const locationHash = getLocationHash(location);
      const cacheKey = `products-${locationHash}${cursor ? `-${cursor}` : ''}`;
      const cacheData = {
        products,
        timestamp: Date.now(),
        cursor
      };

      localStorage.setItem(cacheKey, JSON.stringify(cacheData));
    } catch (error) {
    }
  }, []);

  const invalidateCache = useCallback(() => {
    if (typeof window === 'undefined') return;

    try {
      const keys = Object.keys(localStorage);
      keys.forEach(key => {
        if (key.startsWith('products-')) {
          localStorage.removeItem(key);
        }
      });
    } catch (error) {
    }
  }, []);

  return (
    <ProductCacheContext.Provider value={{ getCachedProducts, cacheProducts, invalidateCache }}>
      {children}
    </ProductCacheContext.Provider>
  );
}

export function useProductCache() {
  const context = useContext(ProductCacheContext);
  if (!context) {
    throw new Error('useProductCache must be used within a ProductCacheProvider');
  }
  return context;
}
</file>

<file path="components/providers/SupabaseProvider.tsx">
"use client";

import { createContext, useContext, useEffect, useState, useRef } from "react";
import { User } from "@supabase/supabase-js";
import { getSupabaseBrowser } from "@/lib/supabase-browser";

interface SupabaseContextType {
  user: User | null;
  isLoading: boolean;
}

const SupabaseContext = createContext<SupabaseContextType>({
  user: null,
  isLoading: true,
});

export function SupabaseProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const lastSyncedState = useRef<string | null>(null);
  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const retryCountRef = useRef(0);
  const MAX_RETRIES = 3;
  const RETRY_DELAY = 1000; // 1 second
  const DEBOUNCE_DELAY = 300; // 300ms

  // Enhanced debounced sync function with retry logic
  const syncAuthState = async (event: string, session: any) => {
    // Generate a unique state key including relevant session data
    const stateKey = `${event}-${session?.user?.id || 'none'}-${session?.expires_at || 'no-expiry'}`;
    
    // Skip if this exact state was already synced
    if (stateKey === lastSyncedState.current) {
      return;
    }

    try {
      const response = await fetch('/api/auth/sync', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ event, session })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to sync auth state: ${response.statusText}`);
      }
      
      // Reset retry count on success
      retryCountRef.current = 0;
      // Update last synced state on success
      lastSyncedState.current = stateKey;
    } catch (error) {
      console.error('Auth sync error:', error);
      
      // Implement retry logic with backoff
      if (retryCountRef.current < MAX_RETRIES) {
        retryCountRef.current++;
        setTimeout(() => {
          syncAuthState(event, session);
        }, RETRY_DELAY * retryCountRef.current);
      }
    }
  };

  useEffect(() => {
    const supabase = getSupabaseBrowser();
    
    // Get initial session
    supabase.auth.getSession().then(({ data: { session }, error }) => {
      if (error) {
        console.error('Session fetch error:', error);
        return;
      }
      const newUser = session?.user ?? null;
      setUser(newUser);
      setIsLoading(false);

      // Initial sync if we have a session
      if (session) {
        syncAuthState('INITIAL', session);
      }
    });

    // Set up auto token refresh
    const refreshInterval = setInterval(async () => {
      try {
        const { data } = await supabase.auth.getSession();
        if (data.session) {
          // Refresh the session
          const { data: refreshData } = await supabase.auth.refreshSession();
          if (refreshData.session) {
            syncAuthState('TOKEN_REFRESHED', refreshData.session);
          }
        }
      } catch (error) {
        console.error('Token refresh error:', error);
      }
    }, 10 * 60 * 1000); // Refresh every 10 minutes

    // Listen for auth changes
    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange(async (event, session) => {
      const newUser = session?.user ?? null;
      
      // Deep compare user state to prevent unnecessary updates
      const userChanged = JSON.stringify(newUser) !== JSON.stringify(user);
      const isAuthEvent = event === 'SIGNED_IN' || event === 'SIGNED_OUT' || event === 'TOKEN_REFRESHED';
      
      if (userChanged || isAuthEvent) {
        setUser(newUser);
        setIsLoading(false);

        // Clear any pending sync
        if (syncTimeoutRef.current) {
          clearTimeout(syncTimeoutRef.current);
        }

        // Debounce sync operation with increased delay
        syncTimeoutRef.current = setTimeout(() => {
          syncAuthState(event, session);
        }, DEBOUNCE_DELAY);
      }
    });

    return () => {
      subscription.unsubscribe();
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
      clearInterval(refreshInterval);
    };
  }, []);

  return (
    <SupabaseContext.Provider value={{ user, isLoading }}>
      {children}
    </SupabaseContext.Provider>
  );
}

export const useSupabase = () => {
  const context = useContext(SupabaseContext);
  if (context === undefined) {
    throw new Error("useSupabase must be used within a SupabaseProvider");
  }
  return context;
};
</file>

<file path="components/providers/ThemeProvider.tsx">
'use client'

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
</file>

<file path="components/skeletons/ProductCardSkeleton.tsx">
import { Skeleton } from "@/components/ui/skeleton";

export function ProductCardSkeleton() {
  return (
    <div className="rounded-lg overflow-hidden shadow-md">
      <div className="relative aspect-[4/3] w-full">
        <Skeleton className="w-full h-full rounded-t-lg" />
        <div className="absolute top-2 right-2 flex gap-2">
          <Skeleton className="h-7 w-16 rounded-md" />
        </div>
      </div>
      <div className="p-3 bg-white space-y-2">
        <div className="flex items-center justify-between">
          <Skeleton className="h-6 w-2/3" />
          <Skeleton className="h-6 w-16" />
        </div>
        <div className="flex items-center justify-between">
          <Skeleton className="h-4 w-1/2" />
          <Skeleton className="h-4 w-20" />
        </div>
        <div className="flex gap-2">
          <Skeleton className="h-6 w-16 rounded-md" />
          <Skeleton className="h-6 w-20 rounded-md" />
        </div>
      </div>
    </div>
  );
}

export function ProductGridSkeleton({ count = 12 }: { count?: number }) {
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-10">
      {Array.from({ length: count }).map((_, i) => (
        <ProductCardSkeleton key={i} />
      ))}
    </div>
  );
}
</file>

<file path="components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "../../lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
        success: "border-transparent bg-green-500 text-white hover:bg-green-600",
        warning: "border-transparent bg-yellow-500 text-white hover:bg-yellow-600",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="components/ui/carousel.tsx">
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "../../lib/utils"
import { Button } from "./button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full opacity-70 hover:opacity-100 transition-opacity",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      aria-label="View previous slide"
      title="Previous slide"
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full opacity-70 hover:opacity-100 transition-opacity",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      aria-label="View next slide"
      title="Next slide"
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="components/ui/data-table.tsx">
'use client'

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
  getPaginationRowModel,
  getSortedRowModel,
  SortingState,
} from "@tanstack/react-table"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { useState } from "react"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
}

export function DataTable<TData, TValue>({
  columns,
  data,
}: DataTableProps<TData, TValue>) {
  const [sorting, setSorting] = useState<SortingState>([])

  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    onSortingChange: setSorting,
    state: {
      sorting,
    },
  })

  return (
    <div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  )
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      <div className="flex items-center justify-end space-x-2 py-4">
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.previousPage()}
          disabled={!table.getCanPreviousPage()}
        >
          Previous
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.nextPage()}
          disabled={!table.getCanNextPage()}
        >
          Next
        </Button>
      </div>
    </div>
  )
}
</file>

<file path="components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "../../lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="components/ui/line-chart.tsx">
'use client'

import { Line, LineChart as RechartsLineChart, ResponsiveContainer, XAxis, YAxis, Tooltip } from 'recharts'

interface LineChartProps {
  data: Array<{
    date: Date | string
    [key: string]: any
  }>
  xField: string
  yField: string
  height?: number
  valuePrefix?: string
}

export function LineChart({ data, xField, yField, height = 300, valuePrefix = '' }: LineChartProps) {
  return (
    <ResponsiveContainer width="100%" height={height}>
      <RechartsLineChart data={data}>
        <XAxis 
          dataKey={xField}
          tickFormatter={(value: any) => {
            if (value instanceof Date) {
              return new Date(value).toLocaleDateString()
            }
            return String(value)
          }}
        />
        <YAxis 
          tickFormatter={(value: number) => `${valuePrefix}${String(value)}`}
        />
        <Tooltip 
          formatter={(value: number) => [`${valuePrefix}${value}`, yField]}
          labelFormatter={(label: string | number | Date) => {
            if (label instanceof Date) {
              return new Date(label).toLocaleDateString()
            }
            return label
          }}
        />
        <Line 
          type="monotone" 
          dataKey={yField} 
          stroke="#8884d8" 
          strokeWidth={2}
          dot={false}
        />
      </RechartsLineChart>
    </ResponsiveContainer>
  )
}
</file>

<file path="components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"
import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "../../lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="components/ui/sheet.tsx">
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "../../lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "../../lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="components/ui/sonner.tsx">
'use client'

import { useTheme } from 'next-themes'
import { Toaster as Sonner } from 'sonner'

type ToasterProps = React.ComponentProps<typeof Sonner>

export function Toaster({ ...props }: ToasterProps) {
  const { theme = 'system' } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}
</file>

<file path="components/ui/switch.tsx">
import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";
import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-[24px] w-[44px] shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn("bg-primary font-medium text-primary-foreground", className)}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "../../lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="components/AuthDialog.tsx">
"use client";

import { useState } from "react";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { LogIn } from "lucide-react";
import { getSupabaseBrowser } from "@/lib/supabase-browser";
import { getAuthRedirectUrl } from "@/lib/supabase-config";
import { signInWithEmail, signUpWithEmail } from "@/app/actions/auth";

interface AuthDialogProps {
  mode?: 'login' | 'signup';
  trigger?: React.ReactNode;
  className?: string;
  returnTo?: string;
}

export function AuthDialog({ mode = 'login', trigger, className, returnTo }: AuthDialogProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [isEmailMode, setIsEmailMode] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSignUp, setIsSignUp] = useState(mode === 'signup');
  const [open, setOpen] = useState(false);

  const handleGoogleAuth = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const supabase = getSupabaseBrowser();
      await supabase.auth.signInWithOAuth({
        provider: 'google',
        options: {
          redirectTo: `${window.location.origin}/api/auth/callback`,
          queryParams: {
            access_type: 'offline',
            prompt: 'consent',
            returnTo: returnTo || window.location.pathname
          }
        },
      });
    } catch (error) {
      setError((error as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleEmailAuth = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formData = new FormData(e.currentTarget);
    const email = formData.get("email") as string;
    const password = formData.get("password") as string;

    try {
      if (isSignUp) {
        await signUpWithEmail(email, password);
        setError("Please check your email to confirm your account");
      } else {
        await signInWithEmail(email, password);
        setOpen(false);
      }
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  };

  const customTrigger = trigger || (
    <Button 
      variant="ghost" 
      size="sm" 
      className={`gap-2 ${className}`}
      disabled={isLoading}
    >
      <LogIn className="h-4 w-4" />
      {isSignUp ? "Sign Up" : "Login"}
    </Button>
  );

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {customTrigger}
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <div className="flex flex-col space-y-4 py-4">
          <h2 className="text-lg font-semibold text-center">
            {isSignUp ? "Create an account" : "Sign in to your account"}
          </h2>

          {!isEmailMode ? (
            <>
              <Button
                variant="outline"
                onClick={handleGoogleAuth}
                disabled={isLoading}
                className="w-full"
              >
                Continue with Google
              </Button>

              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <span className="w-full border-t" />
                </div>
                <div className="relative flex justify-center text-xs uppercase">
                  <span className="bg-background px-2 text-muted-foreground">
                    Or continue with
                  </span>
                </div>
              </div>

              <Button
                variant="outline"
                onClick={() => setIsEmailMode(true)}
                disabled={isLoading}
              >
                Continue with Email
              </Button>
            </>
          ) : (
            <form onSubmit={handleEmailAuth} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="email">Email</Label>
                <Input
                  id="email"
                  name="email"
                  type="email"
                  required
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="password">Password</Label>
                <Input
                  id="password"
                  name="password"
                  type="password"
                  required
                  disabled={isLoading}
                />
              </div>

              {error && (
                <div className="text-sm text-red-500 text-center">{error}</div>
              )}

              <Button
                type="submit"
                className="w-full"
                disabled={isLoading}
              >
                {isLoading
                  ? "Loading..."
                  : isSignUp
                  ? "Sign up"
                  : "Sign in"}
              </Button>

              <Button
                type="button"
                variant="ghost"
                className="w-full"
                onClick={() => setIsEmailMode(false)}
                disabled={isLoading}
              >
                Back to options
              </Button>
            </form>
          )}

          <div className="text-center text-sm">
            <button
              type="button"
              onClick={() => setIsSignUp(!isSignUp)}
              className="text-blue-600 hover:text-blue-500"
              disabled={isLoading}
            >
              {isSignUp
                ? "Already have an account? Sign in"
                : "Don't have an account? Sign up"}
            </button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/Editor.tsx">
"use client";

import { Button } from "./ui/button";
import {
  EditorContent,
  JSONContent,
  useEditor,
  type Editor,
} from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import {
  Bold,
  Italic,
  Strikethrough,
  Heading1,
  Heading2,
  Heading3,
} from "lucide-react";

export const MenuBar = ({ editor }: { editor: Editor | null }) => {
  if (!editor) {
    return null;
  }

  return (
    <div className="flex flex-wrap gap-2">
      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
        variant={editor.isActive("heading", { level: 1 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 1"
        title="Heading 1 (Ctrl+Alt+1)"
      >
        <Heading1 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        variant={editor.isActive("heading", { level: 2 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 2"
        title="Heading 2 (Ctrl+Alt+2)"
      >
        <Heading2 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        variant={editor.isActive("heading", { level: 3 }) ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Heading 3"
        title="Heading 3 (Ctrl+Alt+3)"
      >
        <Heading3 className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleBold().run()}
        variant={editor.isActive("bold") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Bold"
        title="Bold (Ctrl+B)"
      >
        <Bold className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleItalic().run()}
        variant={editor.isActive("italic") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Italic"
        title="Italic (Ctrl+I)"
      >
        <Italic className="h-4 w-4" />
      </Button>

      <Button
        onClick={() => editor.chain().focus().toggleStrike().run()}
        variant={editor.isActive("strike") ? "default" : "secondary"}
        type="button"
        size="sm"
        className="w-10"
        aria-label="Strikethrough"
        title="Strikethrough (Ctrl+Shift+X)"
      >
        <Strikethrough className="h-4 w-4" />
      </Button>
    </div>
  );
};

export function TipTapEditor({
  setJson,
  json,
}: {
  setJson: (json: JSONContent) => void;
  json: JSONContent | null;
}) {
  const editor = useEditor({
    extensions: [StarterKit],
    content: json,
    editorProps: {
      attributes: {
        class: "focus:outline-none min-h-[150px] prose prose-sm sm:prose-base",
      },
    },
    onUpdate: ({ editor }) => {
      setJson(editor.getJSON());
    },
  });

  return (
    <div className="rounded-md border">
      <div className="border-b bg-muted/50 p-2">
        <MenuBar editor={editor} />
      </div>
      <EditorContent
        editor={editor}
        className="p-3 min-h-[150px]"
      />
    </div>
  );
}
</file>

<file path="components/ErrorBoundary.tsx">
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { AlertTriangle } from 'lucide-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

/**
 * Error Boundary Component
 * Catches JavaScript errors anywhere in the child component tree
 */
export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  handleReset = (): void => {
    this.setState({
      hasError: false,
      error: null,
    });
  };

  render(): ReactNode {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="flex min-h-[400px] flex-col items-center justify-center p-6">
          <div className="text-center space-y-4">
            <AlertTriangle className="w-12 h-12 text-destructive mx-auto" />
            <div className="space-y-2">
              <h2 className="text-2xl font-bold">Something went wrong</h2>
              <p className="text-muted-foreground max-w-md">
                {this.state.error?.message || 'An unexpected error occurred'}
              </p>
            </div>
            <div className="flex gap-2 justify-center">
              <Button onClick={this.handleReset} variant="default">
                Try again
              </Button>
              <Button onClick={() => window.location.reload()} variant="outline">
                Reload page
              </Button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/**
 * Async Error Boundary Hook
 * For handling async errors in functional components
 */
export function useErrorHandler(): (error: Error) => void {
  const [, setError] = React.useState<Error>();
  
  return React.useCallback((error: Error) => {
    setError(() => {
      throw error;
    });
  }, []);
}
</file>

<file path="components/FloatingTimer.tsx">
'use client';

import { useEffect, useState } from 'react';

interface FloatingTimerProps {
  updatedAt: Date;
}

export function FloatingTimer({ updatedAt }: FloatingTimerProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <div className="absolute top-2 right-2 bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm font-mono">
      {timeElapsed}
    </div>
  );
}
</file>

<file path="components/ImageUpload.tsx">
"use client";

import { useCallback, useState } from 'react';
import { Button } from './ui/button';
import { toast } from 'sonner';
import { uploadImages } from '@/lib/supabase-browser';

interface ImageUploadProps {
  onUploadComplete: (urls: string[]) => void;
  maxFiles?: number;
  bucket?: string;
}

export function ImageUpload({
  onUploadComplete,
  maxFiles = 5,
  bucket = 'product-images',
}: ImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false);

  const handleFileChange = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files || e.target.files.length === 0) {
      return;
    }

    const files = Array.from(e.target.files).slice(0, maxFiles);
    setIsUploading(true);

    try {
      const urls = await uploadImages(files, bucket);
      onUploadComplete(urls);
      toast.success(`Successfully uploaded ${urls.length} image${urls.length === 1 ? '' : 's'}`);
    } catch (error) {
      if (error instanceof Error) {
        toast.error(error.message);
      } else {
        toast.error('Failed to upload images');
      }
    } finally {
      setIsUploading(false);
      if (e.target) {
        e.target.value = ''; // Reset the input
      }
    }
  }, [maxFiles, onUploadComplete]);

  return (
    <div className="flex flex-col items-center gap-4">
      <input
        type="file"
        accept="image/*"
        multiple
        max={maxFiles}
        onChange={handleFileChange}
        className="hidden"
        id="image-upload"
        disabled={isUploading}
      />
      <label htmlFor="image-upload">
        <Button
          type="button"
          variant="outline"
          disabled={isUploading}
          className="cursor-pointer"
          asChild
        >
          <span>
            {isUploading ? 'Uploading...' : `Upload Images (Max ${maxFiles})`}
          </span>
        </Button>
      </label>
    </div>
  );
}
</file>

<file path="components/InventoryManager.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Minus, Plus } from "lucide-react";
import { toast } from "sonner";

interface InventoryManagerProps {
  currentInventory: number;
  onUpdate: (newInventory: number) => Promise<void>;
}

export function InventoryManager({ 
  currentInventory,
  onUpdate 
}: InventoryManagerProps) {
  const [inventory, setInventory] = useState(currentInventory);
  const [pendingInventory, setPendingInventory] = useState(currentInventory);
  const [isUpdating, setIsUpdating] = useState(false);
  const [isEditing, setIsEditing] = useState(false);

  const handleChange = (change: number) => {
    const newInventory = pendingInventory + change;
    if (newInventory < 0) return;
    setPendingInventory(newInventory);
  };

  const handleDirectInput = (value: string) => {
    const num = parseInt(value, 10);
    if (isNaN(num) || num < 0) return;
    setPendingInventory(num);
  };

  const handleSubmit = async () => {
    if (pendingInventory === inventory) return;
    
    setIsUpdating(true);
    try {
      await onUpdate(pendingInventory);
      setInventory(pendingInventory);
      toast.success("Inventory updated successfully");
    } catch {
      setPendingInventory(inventory); // Reset to last saved value
      toast.error("Failed to update inventory");
    } finally {
      setIsUpdating(false);
      setIsEditing(false);
    }
  };

  return (
    <div className="flex items-center gap-2">
      <Button
        variant="outline"
        size="icon"
        onClick={() => handleChange(-1)}
        disabled={pendingInventory === 0 || isUpdating}
      >
        <Minus className="h-4 w-4" />
      </Button>
      {isEditing ? (
        <Input
          type="number"
          value={pendingInventory}
          onChange={(e) => handleDirectInput(e.target.value)}
          className="w-20 text-center"
          min="0"
          onBlur={() => setIsEditing(false)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              e.currentTarget.blur();
              handleSubmit();
            }
          }}
          autoFocus
        />
      ) : (
        <Button
          variant="ghost"
          className="min-w-[3ch] px-2 h-9"
          onClick={() => setIsEditing(true)}
        >
          {pendingInventory}
        </Button>
      )}
      <Button
        variant="outline"
        size="icon"
        onClick={() => handleChange(1)}
        disabled={isUpdating}
      >
        <Plus className="h-4 w-4" />
      </Button>
      <Button
        variant="default"
        size="sm"
        onClick={handleSubmit}
        disabled={pendingInventory === inventory || isUpdating}
      >
        Submit
      </Button>
    </div>
  );
}
</file>

<file path="components/LoadingState.tsx">
'use client';

import React from 'react';
import { Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';

interface LoadingStateProps {
  message?: string;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  fullScreen?: boolean;
}

/**
 * Consistent Loading State Component
 * Displays a spinner with optional message
 */
export function LoadingState({
  message = 'Loading...',
  size = 'md',
  className,
  fullScreen = false,
}: LoadingStateProps) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-8 h-8',
    lg: 'w-12 h-12',
  };

  const containerClasses = fullScreen
    ? 'fixed inset-0 flex items-center justify-center bg-background/80 backdrop-blur-sm z-50'
    : 'flex items-center justify-center p-8';

  return (
    <div className={cn(containerClasses, className)}>
      <div className="flex flex-col items-center gap-3">
        <Loader2 className={cn('animate-spin text-primary', sizeClasses[size])} />
        {message && (
          <p className="text-sm text-muted-foreground animate-pulse">{message}</p>
        )}
      </div>
    </div>
  );
}

/**
 * Skeleton loading component for cards
 */
export function SkeletonCard({ className }: { className?: string }) {
  return (
    <div className={cn('rounded-lg border bg-card p-4', className)}>
      <div className="space-y-3">
        <div className="h-4 w-3/4 bg-muted animate-pulse rounded" />
        <div className="h-4 w-1/2 bg-muted animate-pulse rounded" />
        <div className="h-20 bg-muted animate-pulse rounded" />
      </div>
    </div>
  );
}

/**
 * Skeleton loading for lists
 */
export function SkeletonList({ count = 3, className }: { count?: number; className?: string }) {
  return (
    <div className={cn('space-y-3', className)}>
      {Array.from({ length: count }).map((_, i) => (
        <SkeletonCard key={i} />
      ))}
    </div>
  );
}

/**
 * Skeleton loading for text
 */
export function SkeletonText({
  lines = 3,
  className,
}: {
  lines?: number;
  className?: string;
}) {
  return (
    <div className={cn('space-y-2', className)}>
      {Array.from({ length: lines }).map((_, i) => (
        <div
          key={i}
          className="h-4 bg-muted animate-pulse rounded"
          style={{ width: `${100 - i * 10}%` }}
        />
      ))}
    </div>
  );
}

/**
 * Spinner only component
 */
export function Spinner({
  size = 'md',
  className,
}: {
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}) {
  const sizeClasses = {
    sm: 'w-4 h-4',
    md: 'w-6 h-6',
    lg: 'w-8 h-8',
  };

  return (
    <Loader2 className={cn('animate-spin text-primary', sizeClasses[size], className)} />
  );
}
</file>

<file path="components/LoadingStateGrid.tsx">
import { Skeleton } from "./ui/skeleton";

export default function LoadingStateGrid() {
  return (
    <section className="max-w-7xl mx-auto px-4 md:px-8">
      <div className="mb-12">
        <div className="md:flex md:items-center md:justify-between mb-6">
          <Skeleton className="h-8 w-48" />
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 gap-10">
          {[...Array(6)].map((_, i) => (
            <div key={i} className="rounded-lg overflow-hidden shadow-md hover:shadow-lg transition-shadow">
              <div className="relative aspect-[4/3] w-full">
                <div className="absolute top-2 right-2 flex gap-2 z-10">
                  <Skeleton className="h-7 w-20 rounded-md" /> {/* Timer placeholder */}
                </div>
                <Skeleton className="w-full h-full" />
              </div>
              <div className="p-3 bg-white space-y-3">
                <div className="flex items-center justify-between">
                  <Skeleton className="h-6 w-1/2" /> {/* Product name */}
                  <Skeleton className="h-6 w-20" /> {/* Price */}
                </div>
                <div className="flex items-center justify-between">
                  <Skeleton className="h-4 w-1/3" /> {/* Location */}
                  <Skeleton className="h-4 w-24" /> {/* Distance */}
                </div>
                <div className="flex gap-2">
                  <Skeleton className="h-6 w-16 rounded-md" /> {/* Tag */}
                  <Skeleton className="h-6 w-16 rounded-md" /> {/* Tag */}
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/LocalCard.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Edit, Eye } from "lucide-react";

interface LocalCardProps {
  local: {
    id: string;
    name: string;
    description: string | null;
    locationName: string;
    images: string[];
    _count: {
      products: number;
    };
  };
  userId: string;
}

export function LocalCard({ local }: LocalCardProps) {
  return (
    <Card className="overflow-hidden">
      <div className="relative h-48">
        <img
          src={local.images[0] || "/images/placeholder.jpg"}
          alt={local.name}
          className="w-full h-full object-cover"
        />
      </div>
      <div className="p-6">
        <h3 className="text-xl font-semibold mb-2">{local.name}</h3>
        <p className="text-muted-foreground text-sm mb-4 line-clamp-2">
          {local.description}
        </p>
        <div className="space-y-2">
          <div className="flex items-center text-sm text-muted-foreground">
            <span>📍 {local.locationName}</span>
          </div>
          <div className="flex items-center text-sm text-muted-foreground">
            <span>🛍️ {local._count.products} Products</span>
          </div>
        </div>
        <div className="flex gap-2 mt-4">
          <Link href={`/local/${local.id}/edit`} className="flex-1">
            <Button variant="outline" className="w-full">
              <Edit className="h-4 w-4 mr-2" />
              Edit
            </Button>
          </Link>
          <Link href={`/local/${local.id}`} className="flex-1">
            <Button variant="default" className="w-full">
              <Eye className="h-4 w-4 mr-2" />
              View
            </Button>
          </Link>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="components/MapView.tsx">
export interface MapViewProps {
  latitude: number;
  longitude: number;
  locationName: string;
}

export default function MapView({ latitude, longitude, locationName }: MapViewProps) {
  // Validate coordinates
  if (typeof latitude !== 'number' || typeof longitude !== 'number' || 
      isNaN(latitude) || isNaN(longitude)) {
    return (
      <div className="w-full h-full min-h-[200px] flex items-center justify-center">
        Invalid coordinates
      </div>
    );
  }

  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS || '';
  const mapUrl = `https://www.google.com/maps/embed/v1/place?key=${apiKey}&q=${latitude},${longitude}&zoom=14`;

  return (
    <iframe
      width="100%"
      height="100%"
      style={{ minHeight: '200px', border: 0 }}
      loading="lazy"
      allowFullScreen
      referrerPolicy="no-referrer-when-downgrade"
      src={mapUrl}
      title={`Map showing location of ${locationName}`}
    />
  );
}
</file>

<file path="components/MapViewClient.tsx">
'use client';

import dynamic from "next/dynamic";

import { MapViewProps } from './MapView';

const MapView = dynamic<MapViewProps>(
  () => import('./MapView'),
  {
    ssr: false,
    loading: () => <div className="h-[400px] animate-pulse bg-gray-200 rounded-lg" />
  }
);

type MapViewClientProps = MapViewProps;

export default function MapViewClient({ latitude, longitude, locationName }: MapViewClientProps) {
  return <MapView latitude={latitude} longitude={longitude} locationName={locationName} />;
}
</file>

<file path="components/MapViewEditable.tsx">
"use client";

export interface MapViewEditableProps {
  latitude: number;
  longitude: number;
  locationName: string;
  onLocationChange: (lat: number, lng: number) => void;
}

export default function MapViewEditable({ 
  latitude, 
  longitude, 
  locationName,
  onLocationChange 
}: MapViewEditableProps) {
  // Validate coordinates
  if (typeof latitude !== 'number' || typeof longitude !== 'number' || 
      isNaN(latitude) || isNaN(longitude)) {
    return (
      <div className="w-full h-full min-h-[200px] flex items-center justify-center">
        Invalid coordinates
      </div>
    );
  }

  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS || '';
  const mapUrl = `https://www.google.com/maps/embed/v1/place?key=${apiKey}&q=${latitude},${longitude}&zoom=14&maptype=roadmap&draggable=true`;

  // Handle message from the iframe when location is changed
  const handleMessage = (event: MessageEvent) => {
    if (event.data.type === 'location_change') {
      onLocationChange(event.data.latitude, event.data.longitude);
    }
  };

  // Add message listener
  if (typeof window !== 'undefined') {
    window.addEventListener('message', handleMessage);
  }

  return (
    <iframe
      width="100%"
      height="100%"
      style={{ minHeight: '200px', border: 0 }}
      loading="lazy"
      allowFullScreen
      referrerPolicy="no-referrer-when-downgrade"
      src={mapUrl}
      title={`Map showing location of ${locationName}`}
    />
  );
}
</file>

<file path="components/MarketStandCard.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { MapPin, Package, Pencil, Clock, Image as ImageIcon } from "lucide-react";
import { Button } from "@/components/ui/button";
import Image from "next/image";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { useState } from "react";

interface MarketStandCardProps {
  stand: {
    id: string;
    name: string;
    description: string | null;
    locationName: string;
    locationGuide: string;
    latitude: number;
    longitude: number;
    images: string[];
    tags: string[];
    _count?: {
      products: number;
    };
    lastProductUpdate?: Date | null;
  };
}

export function MarketStandCard({ stand }: MarketStandCardProps) {
  const [imageError, setImageError] = useState(false);
  
  if (!stand) {
    return null;
  }

  return (
    <Card className="overflow-hidden">
      <div className="flex">
        {/* Image Section - Fixed width and aspect ratio */}
        <div className="relative w-72 h-48 bg-muted flex items-center justify-center">
          {stand.images[0] && !imageError ? (
            <Image
              src={stand.images[0]}
              alt={stand.name}
              fill
              className="object-cover"
              sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
              onError={() => setImageError(true)}
            />
          ) : (
            <div className="flex flex-col items-center justify-center text-muted-foreground">
              <ImageIcon className="h-12 w-12 mb-2" />
              <span className="text-sm">Image not available</span>
            </div>
          )}
        </div>

        {/* Content Section */}
        <div className="flex-1 flex flex-col">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <div>
              <CardTitle>{stand.name}</CardTitle>
              <p className="text-sm text-muted-foreground mt-1">
                {stand.description}
              </p>
            </div>
            <Link href={`/dashboard/market-stand/setup/edit/${stand.id}`}>
              <Button variant="outline" size="icon" className="h-8 w-8">
                <Pencil className="h-4 w-4" />
                <span className="sr-only">Edit market stand</span>
              </Button>
            </Link>
          </CardHeader>

          <CardContent className="flex-1 flex flex-col justify-between">
            <div className="space-y-4">
              <div className="flex items-center gap-4 text-sm">
                <div className="flex items-center gap-1">
                  <MapPin className="h-4 w-4" />
                  {stand.locationName}
                </div>
                <div className="flex items-center gap-1">
                  <Package className="h-4 w-4" />
                  {stand._count?.products || 0} products
                </div>
                {stand.lastProductUpdate && (
                  <div className="flex items-center gap-1 text-muted-foreground">
                    <Clock className="h-4 w-4" />
                    Updated {formatDistanceToNow(new Date(stand.lastProductUpdate), { addSuffix: true })}
                  </div>
                )}
              </div>

              {stand.tags.length > 0 && (
                <div className="flex flex-wrap gap-2">
                  {stand.tags.map((tag, index) => (
                    <div
                      key={index}
                      className="bg-secondary px-2 py-1 rounded-md text-xs"
                    >
                      {tag}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </CardContent>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="components/MarketStandHours.tsx">
import { Clock } from "lucide-react";
import { WeeklyHours, DAYS_OF_WEEK, formatDaySchedule } from "@/types/hours";

interface MarketStandHoursProps {
  hours?: WeeklyHours;
}

export function MarketStandHours({ hours }: MarketStandHoursProps) {
  if (!hours) return null;

  const hasAnyHours = DAYS_OF_WEEK.some(day => hours[day].isOpen && hours[day].timeSlots.length > 0);

  if (!hasAnyHours) return null;

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-3">
        <Clock className="h-5 w-5 text-primary" />
        <h3 className="font-medium">Operating Hours</h3>
      </div>
      <div className="space-y-2">
        {DAYS_OF_WEEK.map((day) => {
          const schedule = hours[day];
          if (!schedule.isOpen) return null;
          
          return (
            <div key={day} className="flex justify-between text-sm">
              <span className="font-medium capitalize">{day}</span>
              <span className="text-muted-foreground">{formatDaySchedule(schedule)}</span>
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="components/MarketStandQR.tsx">
'use client';

import QRCode from "react-qr-code";

interface MarketStandQRProps {
  marketStandId: string;
  size?: number;
}

export function MarketStandQR({ marketStandId, size = 128 }: MarketStandQRProps) {
  // Create a URL that includes the market stand ID
  const qrValue = `${process.env.NEXT_PUBLIC_APP_URL}/market-stand/${marketStandId}`;

  return (
    <div className="bg-white p-4 rounded-lg inline-block">
      <QRCode
        value={qrValue}
        size={size}
        style={{ height: "auto", maxWidth: "100%", width: "100%" }}
        viewBox={`0 0 ${size} ${size}`}
      />
    </div>
  );
}
</file>

<file path="components/MarketStandSelect.tsx">
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select";
import { MarketStand } from "@prisma/client";

interface MarketStandSelectProps {
  stands: MarketStand[];
  selectedId: string;
  onSelect: (standId: string) => void;
}

export function MarketStandSelect({ stands, selectedId, onSelect }: MarketStandSelectProps) {
  return (
    <div className="w-full space-y-2">
      <label className="text-sm font-medium">Select Market Stand</label>
      <Select value={selectedId} onValueChange={onSelect}>
        <SelectTrigger>
          <SelectValue placeholder="Select a market stand" />
        </SelectTrigger>
        <SelectContent>
          {stands.map((stand) => (
            <SelectItem key={stand.id} value={stand.id}>
              {stand.name}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="components/MarketStandsMap.tsx">
'use client';

import { useState, useCallback, useMemo } from 'react';
import { GoogleMap, useJsApiLoader, Marker, InfoWindow, Libraries } from '@react-google-maps/api';
import Link from 'next/link';

const libraries: Libraries = ['places', 'geometry'];

interface MarketStand {
  id: string;
  name: string;
  locationName: string;
  latitude: number;
  longitude: number;
  distance?: number;
  tags: string[];
}

interface MarketStandsMapProps {
  marketStands: MarketStand[];
  userLocation?: { lat: number; lng: number } | null;
}

const containerStyle = {
  width: '100%',
  height: '600px',
  borderRadius: '0.5rem'
};

export default function MarketStandsMap({ marketStands, userLocation }: MarketStandsMapProps) {
  const [selectedStand, setSelectedStand] = useState<MarketStand | null>(null);
  const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS || '';

  const { isLoaded } = useJsApiLoader({
    id: 'google-map-script',
    googleMapsApiKey: apiKey,
    libraries
  });

  const onLoad = useCallback((map: google.maps.Map) => {
    if (marketStands.length === 0) return;
    
    const bounds = new google.maps.LatLngBounds();
    marketStands.forEach(stand => {
      bounds.extend({ lat: stand.latitude, lng: stand.longitude });
    });
    if (userLocation) {
      bounds.extend({ lat: userLocation.lat, lng: userLocation.lng });
    }
    map.fitBounds(bounds);
  }, [marketStands, userLocation]);

  const center = useMemo(() => {
    if (marketStands.length === 0) {
      return { lat: 0, lng: 0 };
    }
    return userLocation
      ? { lat: userLocation.lat, lng: userLocation.lng }
      : { lat: marketStands[0].latitude, lng: marketStands[0].longitude };
  }, [marketStands, userLocation]);

  if (!isLoaded) {
    return (
      <div className="w-full h-[600px] rounded-lg border flex items-center justify-center">
        Loading map...
      </div>
    );
  }

  if (marketStands.length === 0) {
    return (
      <div className="w-full h-[600px] rounded-lg border flex items-center justify-center">
        No market stands available
      </div>
    );
  }

  return (
    <div className="grid lg:grid-cols-[1fr,300px] gap-4">
      <GoogleMap
        mapContainerStyle={containerStyle}
        center={center}
        zoom={10}
        onLoad={onLoad}
        options={{
          styles: [
            {
              featureType: 'poi',
              elementType: 'labels',
              stylers: [{ visibility: 'off' }]
            }
          ]
        }}
      >
        {/* User location marker */}
        {userLocation && (
          <Marker
            position={{ lat: userLocation.lat, lng: userLocation.lng }}
            icon={{
              path: google.maps.SymbolPath.CIRCLE,
              scale: 7,
              fillColor: '#4F46E5',
              fillOpacity: 1,
              strokeWeight: 2,
              strokeColor: '#ffffff',
            }}
          />
        )}

        {/* Market stand markers */}
        {marketStands.map(stand => (
          <Marker
            key={stand.id}
            position={{ lat: stand.latitude, lng: stand.longitude }}
            onClick={() => setSelectedStand(stand)}
          />
        ))}

        {/* Info window for selected stand */}
        {selectedStand && (
          <InfoWindow
            position={{ lat: selectedStand.latitude, lng: selectedStand.longitude }}
            onCloseClick={() => setSelectedStand(null)}
          >
            <div className="p-2">
              <h3 className="font-medium mb-1">{selectedStand.name}</h3>
              <p className="text-sm text-gray-600 mb-2">{selectedStand.locationName}</p>
              {selectedStand.distance !== undefined && (
                <p className="text-sm text-primary mb-2">
                  {selectedStand.distance.toFixed(1)} km away
                </p>
              )}
              {selectedStand.tags && selectedStand.tags.length > 0 && (
                <div className="flex flex-wrap gap-1 mb-2">
                  {selectedStand.tags.map((tag, index) => (
                    <div
                      key={index}
                      className="bg-secondary px-2 py-0.5 rounded-md text-xs"
                    >
                      {tag}
                    </div>
                  ))}
                </div>
              )}
              <Link
                href={`/market-stand/${selectedStand.id}`}
                className="text-sm text-primary hover:underline"
              >
                View Details
              </Link>
            </div>
          </InfoWindow>
        )}
      </GoogleMap>

      <div className="bg-white rounded-lg p-4 shadow-sm h-[600px] overflow-y-auto">
        <h3 className="font-semibold text-lg mb-4">Market Stands</h3>
        <div className="space-y-3">
          {marketStands.map(stand => (
            <Link
              key={stand.id}
              href={`/market-stand/${stand.id}`}
              className="block p-3 rounded-md hover:bg-gray-50 transition-colors"
              onClick={() => setSelectedStand(stand)}
            >
              <h4 className="font-medium">{stand.name}</h4>
              <p className="text-sm text-muted-foreground">{stand.locationName}</p>
              {stand.distance !== undefined && (
                <p className="text-sm text-primary mt-1">
                  {stand.distance.toFixed(1)} km away
                </p>
              )}
              {stand.tags && stand.tags.length > 0 && (
                <div className="flex flex-wrap gap-1 mt-2">
                  {stand.tags.map((tag, index) => (
                    <div
                      key={index}
                      className="bg-secondary px-2 py-0.5 rounded-md text-xs"
                    >
                      {tag}
                    </div>
                  ))}
                </div>
              )}
            </Link>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/MarketStandViewNav.tsx">
import { MapPin, Grid } from "lucide-react";
import { Button } from "./ui/button";
import Link from "next/link";

interface MarketStandViewNavProps {
  currentView: 'grid' | 'map';
}

export function MarketStandViewNav({ currentView }: MarketStandViewNavProps) {
  return (
    <div className="flex gap-4">
      <Link href="/market-stand/grid">
        <Button variant={currentView === 'grid' ? 'default' : 'outline'}>
          <Grid className="h-4 w-4 mr-2" />
          Grid View
        </Button>
      </Link>
      <Link href="/market-stand/map">
        <Button variant={currentView === 'map' ? 'default' : 'outline'}>
          <MapPin className="h-4 w-4 mr-2" />
          Map View
        </Button>
      </Link>
    </div>
  );
}
</file>

<file path="components/MobileMenu.tsx">
"use client";

import { Button } from "./ui/button";
import { Sheet, SheetContent, SheetTrigger, SheetClose } from "./ui/sheet";
import { Menu } from "lucide-react";
import { navbarLinks } from "./NavbarLinks";
import Link from "next/link";
import { cn } from "../lib/utils";
import { usePathname } from "next/navigation";

export function MobileMenu() {
  const location = usePathname();
  
  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button 
          variant="outline" 
          size="icon"
          aria-label="Open menu"
        >
          <Menu className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-72">
        <nav className="mt-6 flex flex-col gap-1">
          {navbarLinks.map((item) => (
            <SheetClose asChild key={item.id}>
              <Link
                href={item.href}
                className={cn(
                  "flex items-center px-4 py-2 text-sm font-medium rounded-md transition-colors",
                  location === item.href
                    ? "bg-primary text-primary-foreground"
                    : "text-muted-foreground hover:bg-muted hover:text-primary"
                )}
              >
                {item.name}
              </Link>
            </SheetClose>
          ))}
        </nav>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="components/Navbar.tsx">
"use client";

import Link from "next/link";
import { NavbarLinks } from "./NavbarLinks";
import { UserNav } from "./UserNav";
import Image from "next/image";

export function Navbar() {
  return (
    <nav className="bg-[#0B4D2C]">
      <div className="flex h-16 items-center px-4 max-w-7xl mx-auto">
        <Link href="/" className="flex items-center">
          <div className="relative w-[180px] h-[45px]">
            <Image
              src="/logos/cornucopia-dark.svg"
              alt="Cornucopia"
              fill
              priority
              className="brightness-0 invert"
            />
          </div>
        </Link>

        <NavbarLinks />

        <div className="ml-auto flex items-center space-x-4">
          <UserNav />
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="components/NavbarLinks.tsx">
"use client";

import { cn } from "../lib/utils";
import Link from "next/link";
import { usePathname } from "next/navigation";

export const navbarLinks = [
  {
    id: 0,
    name: "Home",
    href: "/",
  },
  {
    id: 1,
    name: "Market Stands",
    href: "/market-stand",
  },
  {
    id: 2,
    name: "How it Works",
    href: "/how-it-works",
  },
  {
    id: 3,
    name: "Our Mission",
    href: "/our-mission",
  },
];

export function NavbarLinks() {
  const location = usePathname();

  return (
    <div className="flex justify-center items-center gap-x-6 ml-10">
      {navbarLinks.map((item) => (
        <Link
          href={item.href}
          key={item.id}
          className={cn(
            location === item.href
              ? "text-white font-medium"
              : "text-white/80 hover:text-white",
            "transition-colors"
          )}
        >
          {item.name}
        </Link>
      ))}
    </div>
  );
}
</file>

<file path="components/NewestProducts.tsx">
'use client';

import Link from "next/link";
import { ProductCard } from "./ProductCard";
import { useEffect, useState } from "react";
import { Skeleton } from "./ui/skeleton";
import { getHomeProducts } from "@/app/actions/home-products";
import { logError } from "@/lib/logger";
import type { SerializedProduct } from "@/app/actions/home-products";

export function NewestProducts() {
  const [products, setProducts] = useState<SerializedProduct[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await getHomeProducts(null); // Pass null to get all products without location filtering
        setProducts(data);
      } catch (err) {
        logError('Failed to fetch newest products:', err);
        setError('Failed to load products. Please try refreshing the page.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchProducts();
  }, []);

  if (isLoading) {
    return <LoadingState />;
  }

  if (error) {
    return (
      <div className="text-center py-12">
        <p className="text-destructive">{error}</p>
      </div>
    );
  }

  if (!products.length) {
    return (
      <div className="text-center py-12">
        <p className="text-muted-foreground">No products available at the moment.</p>
      </div>
    );
  }

  return (
    <section className="mt-12">
      <div className="md:flex md:items-center md:justify-between">
        <h2 className="text-2xl font-extrabold tracking-tighter">
          Newest Products
        </h2>
        <Link
          href="/market-stand/grid"
          className="text-sm hidden font-medium text-primary hover:text-primary/90 md:block"
        >
          All Products <span>&rarr;</span>
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 mt-4 gap-10">
        {products.map((product) => (
          <ProductCard
            key={product.id}
            images={product.images}
            id={product.id}
            name={product.name}
            locationName={product.marketStand.locationName}
            updatedAt={product.updatedAt}
            price={product.price}
            tags={product.tags}
          />
        ))}
      </div>
    </section>
  );
}

function LoadingState() {
  return (
    <section className="mt-12">
      <div className="md:flex md:items-center md:justify-between mb-6">
        <Skeleton className="h-8 w-48" />
        <Skeleton className="h-6 w-24 hidden md:block" />
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-10">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="space-y-4">
            <Skeleton className="w-full aspect-[4/3]" />
            <Skeleton className="h-6 w-3/4" />
            <Skeleton className="h-4 w-1/2" />
          </div>
        ))}
      </div>
    </section>
  );
}
</file>

<file path="components/PaymentTab.tsx">
import { Card } from "./ui/card";
import { Button } from "./ui/button";
import { QrCode, CreditCard } from "lucide-react";
import Link from "next/link";
import { MarketStandQR } from "./MarketStandQR";
import { StripeConnectButton } from "./StripeConnectButton";

interface PaymentTabProps {
  marketStands: {
    id: string;
    name: string;
  }[];
  stripeConnected: boolean;
}

export function PaymentTab({ marketStands, stripeConnected }: PaymentTabProps) {
  return (
    <div className="space-y-4">
      <Card className="p-6">
        <div className="flex flex-col items-center text-center">
          <div className="mb-6">
            <div className="inline-block p-3 bg-primary/10 rounded-full mb-4">
              <CreditCard className="w-6 h-6 text-primary" />
            </div>
            <h2 className="text-xl font-semibold">Payment Processing</h2>
            <p className="text-muted-foreground mt-2 mb-4 max-w-md">
              You can list products without connecting a Stripe account, but you&apos;ll need to connect one to receive payments from customers.
            </p>
            <p className="text-sm text-muted-foreground mb-6 max-w-md">
              When connected, Stripe provides secure payment processing and automatic transfers to your bank account.
            </p>
          </div>

          {stripeConnected ? (
            <div className="space-y-4 w-full max-w-md">
              <div className="bg-green-50 text-green-700 p-4 rounded-lg">
                <p className="font-medium">✓ Stripe account connected</p>
                <p className="text-sm mt-1">Your account is ready to receive payments</p>
              </div>
            </div>
          ) : (
            <div className="w-full max-w-md">
              <div className="bg-yellow-50 text-yellow-800 p-4 rounded-lg mb-6">
                <p className="font-medium">Optional Setup</p>
                <p className="text-sm mt-1">
                  You can list products now, but customers won&apos;t be able to make purchases until you connect a Stripe account.
                </p>
              </div>
              <StripeConnectButton />
              <p className="text-sm text-muted-foreground mt-4">
                You&apos;ll be redirected to Stripe to complete the account setup
              </p>
            </div>
          )}
        </div>
      </Card>

      <Card className="p-6">
        <div className="flex flex-col items-center text-center">
          <div className="mb-6">
            <div className="inline-block p-3 bg-primary/10 rounded-full mb-4">
              <QrCode className="w-6 h-6 text-primary" />
            </div>
            <h2 className="text-xl font-semibold">Market Stand QR Codes</h2>
            <p className="text-muted-foreground mt-2 mb-6 max-w-md">
              Display these QR codes at your market stands. When customers scan them, they&apos;ll be able to view your products and make purchases once you&apos;ve connected your Stripe account.
            </p>
          </div>

          {marketStands.length > 0 ? (
            <div className="space-y-8 w-full">
              {marketStands.map(stand => (
                <div key={stand.id} className="space-y-4">
                  <h3 className="font-medium">{stand.name}</h3>
                  <div className="flex flex-col items-center space-y-6">
                    <MarketStandQR marketStandId={stand.id} size={200} />
                    <div className="text-sm text-muted-foreground space-y-2">
                      <p>• Place this QR code where customers can easily scan it</p>
                      <p>• Customers need to scan this to make purchases</p>
                      <p>• The QR code helps verify product availability</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="bg-muted p-4 rounded-lg text-center">
              <p className="text-muted-foreground">
                Set up your market stand to get your QR code
              </p>
              <Button 
                variant="secondary" 
                size="sm"
                className="mt-4"
                asChild
                aria-label="Set up your market stand"
              >
                <Link href="/market-stand/setup">
                  Set Up Market Stand
                </Link>
              </Button>
            </div>
          )}
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="components/ProductCard.tsx">
'use client';

import { Skeleton } from "./ui/skeleton";
import Image from "next/image";
import Link from "next/link";
import { useEffect, useState } from "react";

interface ProductCardProps {
  images: string[];
  name: string;
  id: string;
  locationName: string;
  updatedAt: string;
  inventory?: number;
  isQRAccess?: boolean;
  price?: number;
  tags?: string[];
  distance?: number | null;
}

export function ProductCard({
  images,
  id,
  name,
  locationName,
  updatedAt,
  inventory,
  isQRAccess = false,
  price,
  tags = [],
  distance,
}: ProductCardProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <Link 
      href={`/product/${encodeURIComponent(id)}${isQRAccess ? '?qr=true' : ''}`}
      className="block group"
    >
      <div className="rounded-lg overflow-hidden shadow-md hover:shadow-lg transition-shadow">
        <div className="relative aspect-[4/3] w-full">
          <div className="absolute top-2 right-2 flex gap-2 z-10">
            <div className="bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm font-mono">
              {timeElapsed}
            </div>
            {typeof inventory === 'number' && (
              <div className="bg-black/50 backdrop-blur-sm text-white px-3 py-1.5 rounded-md text-sm">
                {inventory} left
              </div>
            )}
          </div>
          <Image
            alt={name}
            src={images[0]}
            fill
            className="object-cover rounded-t-lg transition-transform group-hover:scale-105"
            sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
            quality={85}
            placeholder="blur"
            blurDataURL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mN8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=="
          />
        </div>
        <div className="p-3 bg-white">
          <div className="flex items-center justify-between">
            <h2 className="font-semibold text-lg">{name}</h2>
            {typeof price === 'number' && (
              <p className="font-medium text-primary">
                {(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
              </p>
            )}
          </div>
          <div className="flex items-center justify-between mt-1">
            <p className="text-gray-600 text-sm">{locationName}</p>
            {distance !== null && distance !== undefined && (
              <p className="text-sm text-primary">
                {Math.round(distance * 0.621371)} miles away
              </p>
            )}
          </div>
          {tags.length > 0 && (
            <div className="flex flex-wrap gap-2 mt-2">
              {tags.map((tag: string, index: number) => (
                <div
                  key={index}
                  className="bg-secondary px-2 py-1 rounded-md text-xs"
                >
                  {tag}
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    </Link>
  );
}

export function LoadingProductCard() {
  return (
    <div className="rounded-lg overflow-hidden shadow-md">
      <Skeleton className="w-full aspect-[4/3]" />
      <div className="p-3">
        <Skeleton className="h-6 w-3/4 mb-2" />
        <Skeleton className="h-4 w-1/2" />
      </div>
    </div>
  );
}
</file>

<file path="components/ProductDashboardCard.tsx">
'use client';

import { useState } from "react";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { Loader2, Pencil } from "lucide-react";
import Image from "next/image";
import Link from "next/link";

interface ProductDashboardCardProps {
  id: string;
  name: string;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: Date | null;
}

export function ProductDashboardCard({ id, name, images, inventory, inventoryUpdatedAt }: ProductDashboardCardProps) {
  const [currentInventory, setCurrentInventory] = useState(inventory);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const handleUpdate = async () => {
    try {
      setIsLoading(true);
      setError("");

      const response = await fetch(`/api/product`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          id,
          inventory: currentInventory,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to update inventory");
      }

      // Refresh the page to show updated data
      window.location.reload();
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to update inventory");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="rounded-lg overflow-hidden border bg-card text-card-foreground shadow-sm">
      <div className="relative h-[200px]">
        <Image
          alt={`Product image for ${name}`}
          src={images[0]}
          fill
          className="object-cover"
          priority
          sizes="(max-width: 768px) 100vw, 300px"
        />
      </div>
      <div className="p-4">
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-semibold">{name}</h3>
          <Link href={`/dashboard/edit-product/${id}`}>
            <Button 
              variant="ghost" 
              size="icon"
              aria-label={`Edit ${name}`}
              title={`Edit ${name}`}
            >
              <Pencil className="h-4 w-4" />
            </Button>
          </Link>
        </div>

        <div className="space-y-4">
          <div className="flex items-center justify-between text-sm text-muted-foreground">
            <span>Current Inventory:</span>
            <span>{inventory} units</span>
          </div>

          {inventoryUpdatedAt && (
            <div className="text-xs text-muted-foreground">
              Last updated: {new Intl.DateTimeFormat("en-US", {
                dateStyle: "medium",
                timeStyle: "short",
              }).format(new Date(inventoryUpdatedAt))}
            </div>
          )}

          <div className="flex items-center gap-2">
            <Input
              id={`inventory-${id}`}
              type="number"
              min="0"
              value={currentInventory}
              onChange={(e) => setCurrentInventory(Number(e.target.value))}
              className="w-24"
              aria-label={`Update inventory for ${name}`}
              aria-describedby={error ? `error-${id}` : undefined}
            />
            <Button 
              onClick={handleUpdate} 
              disabled={isLoading || currentInventory === inventory}
              size="sm"
              aria-label={isLoading ? "Updating inventory..." : "Update inventory"}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  <span>Updating...</span>
                </>
              ) : (
                "Update"
              )}
            </Button>
          </div>
          {error && (
            <p 
              id={`error-${id}`}
              className="text-sm font-medium text-destructive mt-1.5"
            >
              {error}
            </p>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ProductDescription.tsx">
"use client";

import { type JSONContent, useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";

export function ProductDescription({ content }: { content: JSONContent }) {
const editor = useEditor({
  editable: false,
  extensions: [StarterKit],
  content: content,
  editorProps: {
    attributes: {
      class: "prose prose-sm sm:prose-base",
    },
  },
  immediatelyRender: false,
});

  if (!editor) {
    return null;
  }

  return (
    <>
      <EditorContent editor={editor} />
    </>
  );
}
</file>

<file path="components/ProductEmail.tsx">
import {
  Body,
  Button,
  Container,
  Head,
  Html,
  Preview,
  Section,
  Tailwind,
  Text,
} from "@react-email/components";

export default function ProductEmail({ link }: { link: string }) {
  return (
    <Html>
      <Head />
      <Preview>Your product is here...</Preview>
      <Tailwind>
        <Body className="bg-white font-sans">
          <Container style={container}>
            <Text className="text-2xl font-semibold">Hi Friend,</Text>
            <Text className="text-lg text-gray-600">
              Thank you for buying your product at MarshalUI
            </Text>
            <Section className="w-full flex justify-center mt-7">
              <Button
                href={link}
                className="text-white bg-blue-500 rounded-lg px-10 py-4"
              >
                Your Download Link
              </Button>
            </Section>
            <Text className="text-lg">
              Best, <br /> MarshalUI Team
            </Text>
          </Container>
        </Body>
      </Tailwind>
    </Html>
  );
}

const container = {
  margin: "0 auto",
  padding: "20px 0 48px",
};
</file>

<file path="components/ProductRow.tsx">
'use client';

import { useState } from 'react';
import { ProductCard } from "./ProductCard";
import Link from "next/link";
import { type SerializedProduct } from "@/app/actions/home-products";

interface ProductRowProps {
  title: string;
  initialProducts: SerializedProduct[];
}

export function ProductRow({ title, initialProducts }: ProductRowProps) {
  const [isLocalLoading] = useState(false);

  // Use initialProducts directly and filter based on distance
  const data = initialProducts;
  const localProducts = data.filter(product => (product.distance ?? Infinity) <= 500);
  const nonLocalProducts = data.filter(product => (product.distance ?? Infinity) > 500);
  const hasLocalProducts = localProducts.length > 0;
  const hasNonLocalProducts = nonLocalProducts.length > 0;

  const renderProductGrid = (products: SerializedProduct[]) => (
    <div className="grid grid-cols-1 lg:grid-cols-3 sm:grid-cols-2 mt-4 gap-10">
      {products.map((product) => (
        <ProductCard
          key={product.id}
          images={product.images}
          id={product.id}
          name={product.name}
          locationName={product.marketStand?.locationName ?? ''}
          updatedAt={product.updatedAt}
          price={product.price}
          tags={product.tags}
        />
      ))}
    </div>
  );

  return (
    <section className="mt-12">
      {/* Local Products Section */}
      <div className="mb-12">
        <div className="md:flex md:items-center md:justify-between mb-6">
          <h2 className="text-2xl font-extrabold tracking-tighter">
            {title}
          </h2>
        </div>

        {localProducts.length === 0 && (
          <div className="text-center py-12 border rounded-lg bg-muted/50 mb-12">
            <h3 className="text-xl font-semibold mb-4">Sorry, there are no local products nearby</h3>
            <Link 
              href="/market-stand/setup"
              className="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2"
            >
              Become the First
            </Link>
          </div>
        )}

        {!isLocalLoading && hasLocalProducts && renderProductGrid(localProducts)}
      </div>

      {/* Non-Local Products Section */}
      {hasNonLocalProducts && (
        <div className="mt-16">
          <div className="md:flex md:items-center md:justify-between mb-6">
            <h2 className="text-2xl font-extrabold tracking-tighter">
              Explore Products
            </h2>
          </div>
          {renderProductGrid(nonLocalProducts)}
        </div>
      )}
    </section>
  );
}
</file>

<file path="components/ProductTimer.tsx">
'use client';

import { useEffect, useState } from 'react';

interface ProductTimerProps {
  updatedAt: Date;
  size?: 'small' | 'normal';
}

export function ProductTimer({ updatedAt, size = 'normal' }: ProductTimerProps) {
  const [timeElapsed, setTimeElapsed] = useState('00:00');

  useEffect(() => {
    const calculateTime = () => {
      const now = new Date();
      const updated = new Date(updatedAt);
      const diff = Math.floor((now.getTime() - updated.getTime()) / 1000); // difference in seconds
      
      const days = Math.floor(diff / 86400);
      const hours = Math.floor((diff % 86400) / 3600);
      const minutes = Math.floor((diff % 3600) / 60);
      const seconds = diff % 60;

      // First hour: show minutes:seconds
      if (diff < 3600) {
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      // Next two days: show hours:minutes
      else if (days < 2) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }
      // After two days: show days
      else {
        return `${days}d ago`;
      }
    };

    // Initial calculation
    setTimeElapsed(calculateTime());

    // Update every second
    const interval = setInterval(() => {
      setTimeElapsed(calculateTime());
    }, 1000);

    return () => clearInterval(interval);
  }, [updatedAt]);

  return (
    <div className={`absolute top-0 left-0 bg-black/60 text-white rounded-br-md font-mono
      ${size === 'small' ? 'px-2 py-1 text-xs' : 'px-3 py-1.5 text-sm'}`}>
      {timeElapsed}
    </div>
  );
}
</file>

<file path="components/ServiceWorkerRegistration.tsx">
'use client';

import { useEffect } from 'react';

export function ServiceWorkerRegistration() {
  useEffect(() => {
    if ('serviceWorker' in navigator && process.env.NODE_ENV === 'production') {
      window.addEventListener('load', () => {
        navigator.serviceWorker
          .register('/sw.js')
          .then((registration) => {
            console.log('[SW] Service Worker registered successfully:', registration.scope);
            
            // Check for updates periodically
            setInterval(() => {
              registration.update();
            }, 60000); // Check every minute
          })
          .catch((error) => {
            console.error('[SW] Service Worker registration failed:', error);
          });
      });
    }
  }, []);

  return null;
}
</file>

<file path="components/StripeConnectButton.tsx">
"use client";

import { Button } from "./ui/button";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";

export function StripeConnectButton() {
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  const handleConnect = async () => {
    try {
      setLoading(true);
      const response = await fetch("/api/stripe/connect", {
        method: "POST",
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || `HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.url) {
        router.push(data.url);
      } else {
        throw new Error("No redirect URL received from Stripe");
      }
    } catch (error) {
        toast.error(
        error instanceof Error 
          ? error.message 
          : "Failed to connect Stripe account. Please try again."
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button 
      onClick={handleConnect}
      disabled={loading}
      className="w-full relative"
      aria-label="Connect Stripe account for payments"
    >
      {loading ? (
        <>
          <span className="opacity-0">Connect Stripe Account</span>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="h-4 w-4 border-2 border-current border-r-transparent animate-spin rounded-full" />
          </div>
        </>
      ) : (
        "Connect Stripe Account"
      )}
    </Button>
  );
}
</file>

<file path="components/SubmitButtons.tsx">
"use client";

import { Button } from "./ui/button";
import { Loader2 } from "lucide-react";
import { useFormStatus } from "react-dom";

export function Submitbutton({ title, disabled }: { title: string; disabled?: boolean }) {
  const { pending } = useFormStatus();

  return (
    <>
      {pending || disabled ? (
        <Button 
          disabled={true}
          aria-label="Form submission in progress"
          className="min-w-[100px]"
        >
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Submitting...
        </Button>
      ) : (
        <Button 
          type="submit"
          aria-label={title}
          className="min-w-[100px]"
        >
          {title}
        </Button>
      )}
    </>
  );
}

export function BuyButton({ price }: { price: number }) {
  const { pending } = useFormStatus();

  return (
    <>
      {pending ? (
        <Button 
          disabled 
          size="lg" 
          className="w-full mt-10"
          aria-label="Purchase in progress"
        >
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          Processing...
        </Button>
      ) : (
        <Button 
          type="submit" 
          size="lg" 
          className="w-full mt-10"
          aria-label={`Buy for ${(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`}
        >
          Buy for {(price / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' })}
        </Button>
      )}
    </>
  );
}
</file>

<file path="components/UnderConstruction.tsx">
export function UnderConstruction() {
  return (
    <div className="flex flex-col items-center justify-center min-h-[60vh] space-y-4">
      <div className="text-6xl">🚧</div>
      <h1 className="text-2xl font-semibold text-gray-900">Under Construction</h1>
      <p className="text-gray-600">This page is currently being built. Check back soon!</p>
    </div>
  );
}
</file>

<file path="components/UserNav.tsx">
"use client";

import { useSupabase } from "./providers/SupabaseProvider";
import { useState } from "react";
import { useRouter } from "next/navigation";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Button } from "./ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "./ui/avatar";
import { AuthDialog } from "./AuthDialog";
import { getSupabaseBrowser } from "@/lib/supabase-browser";
import { getAuthRedirectUrl } from "@/lib/supabase-config";

export function UserNav() {
  const { user, isLoading } = useSupabase();
  const [isAuthenticating, setIsAuthenticating] = useState(false);
  const router = useRouter();

  const handleLogout = async () => {
    try {
      setIsAuthenticating(true);
      const supabase = getSupabaseBrowser();
      await supabase.auth.signOut();
      router.push('/');
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      setIsAuthenticating(false);
    }
  };

  const navigate = (path: string) => {
    router.push(path);
  };

  if (isLoading || isAuthenticating) {
    return (
      <Button variant="ghost" size="sm" className="relative h-8 w-8">
        <Avatar>
          <AvatarFallback className="animate-pulse">...</AvatarFallback>
        </Avatar>
      </Button>
    );
  }

  if (!user) {
    return (
      <div className="flex items-center gap-4">
        <AuthDialog 
          mode="login"
          trigger={
            <Button 
              variant="ghost" 
              size="sm" 
              disabled={isAuthenticating}
              className="text-white hover:text-white/80"
            >
              Login
            </Button>
          }
        />
        <AuthDialog 
          mode="signup" 
          trigger={
            <Button 
              size="sm" 
              disabled={isAuthenticating}
              className="bg-white text-[#0B4D2C] hover:bg-white/90"
            >
              Create an account
            </Button>
          }
        />
      </div>
    );
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="relative h-8 w-8">
          <Avatar>
            <AvatarImage
              src={user?.user_metadata?.avatar_url || ''}
              alt={user?.user_metadata?.given_name || 'User'}
            />
            <AvatarFallback>{user?.user_metadata?.given_name?.[0] || 'U'}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">{user?.user_metadata?.given_name || 'User'}</p>
            <p className="text-xs leading-none text-muted-foreground">
              {user?.email || ''}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/sell')}
        >
          Sell My Products
        </DropdownMenuItem>
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/dashboard/market-stand')}
        >
          Market Stands
        </DropdownMenuItem>
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/dashboard/local')}
        >
          Farm/Ranch Profiles
        </DropdownMenuItem>
        <DropdownMenuItem 
          className="cursor-pointer"
          onClick={() => navigate('/settings')}
        >
          Settings
        </DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem 
          className="cursor-pointer text-destructive focus:text-destructive"
          onClick={handleLogout}
          disabled={isAuthenticating}
        >
          Logout
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="components/ZipSearchBanner.tsx">
'use client';

import { useState, useCallback, useEffect } from 'react';
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { geocodeZipCode } from "@/app/actions/geocode";
import { type LocationType } from "@/app/actions/home-products";
import { MapPin } from 'lucide-react';
import useUserLocation from '@/app/hooks/useUserLocation';

interface ZipSearchBannerProps {
  onLocationUpdate: (location: LocationType | null) => void;
}

export function ZipSearchBanner({ onLocationUpdate }: ZipSearchBannerProps) {
  const [zipCode, setZipCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const { 
    userLocation,
    locationError,
    isLoadingLocation,
    retryLocation
  } = useUserLocation({
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0,
    onSuccess: useCallback((location: LocationType) => {
      onLocationUpdate(location);
    }, [onLocationUpdate])
  });

  const handleSearch = useCallback(async () => {
    if (!zipCode.match(/^\d{5}$/)) {
      setError('Please enter a valid 5-digit zip code');
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      const location = await geocodeZipCode(zipCode);
      
      if (!location) {
        setError('Invalid zip code');
        onLocationUpdate(null);
        return;
      }

      const zipLocation: LocationType = {
        coords: {
          lat: location.lat,
          lng: location.lng,
          timestamp: Date.now()
        },
        source: 'zipcode'
      };

      console.log('Zip code location found:', zipLocation);
      onLocationUpdate(zipLocation);
    } catch (err) {
      console.error('Geocoding error:', err);
      setError('Failed to search by zip code');
      onLocationUpdate(null);
    } finally {
      setIsLoading(false);
    }
  }, [zipCode, onLocationUpdate]);

  return (
    <div className="w-full h-[500px] relative mb-8">
      <div 
        className="absolute inset-0 bg-cover bg-center"
        style={{ backgroundImage: 'url("/images/zip-search-banner.avif")' }}
      >
        <div className="absolute inset-0 bg-black/60" />
      </div>
      <div className="relative h-full flex flex-col items-center justify-center text-center px-4">
        <h1 className="text-5xl md:text-6xl font-extrabold text-white mb-6 drop-shadow-md max-w-4xl">
          Harvesting Nature's Best for You
        </h1>
        <p className="text-white text-xl mb-12 max-w-2xl drop-shadow">
          Experience the finest organic produce, sustainably grown and handpicked with care.
          Join us in nurturing the earth while enjoying its freshest offerings.
        </p>
        <div className="flex gap-2 justify-center">
          <Input
            type="text"
            placeholder="Enter Zip Code"
            value={zipCode}
            onChange={(e) => setZipCode(e.target.value)}
            className="w-[280px] px-4 py-3 bg-white/95 shadow-lg text-lg placeholder:text-gray-500"
            maxLength={5}
          />
          <Button 
            onClick={handleSearch}
            disabled={isLoading}
            className="shadow-lg text-lg px-8 bg-[#0B4D2C] hover:bg-[#0B4D2C]/90 text-white"
          >
            {isLoading ? 'Searching...' : 'Search'}
          </Button>
          <Button
            onClick={retryLocation}
            variant="outline"
            className="shadow-lg"
            disabled={isLoadingLocation}
          >
            <MapPin className="h-4 w-4 mr-2" />
            Use My Location
          </Button>
        </div>
        {error && (
          <p className="text-red-500 text-sm mt-2 bg-white/95 px-3 py-1 rounded shadow">
            {error}
          </p>
        )}
        {isLoadingLocation && (
          <p className="text-white text-sm mt-2 bg-black/30 px-3 py-1 rounded">
            Getting your location...
          </p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="hooks/index.ts">
/**
 * Custom Hooks
 * Export all custom hooks from a single location
 */

export { useProducts } from './useProducts';
export { useMarketStands } from './useMarketStands';
export { useAuth } from './useAuth';
export { default as useUserLocation } from './useUserLocation';
export { useForm } from './useForm';
</file>

<file path="hooks/useAuth.ts">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { User } from '@supabase/supabase-js';
import { createBrowserClient } from '@supabase/ssr';
import { DataLoadingState } from '@/types';

interface UseAuthReturn extends DataLoadingState<User> {
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
  updatePassword: (newPassword: string) => Promise<void>;
  isAuthenticated: boolean;
}

/**
 * Custom hook for authentication
 * Provides user state and authentication methods
 */
export function useAuth(): UseAuthReturn {
  const [state, setState] = useState<DataLoadingState<User>>({
    data: null,
    isLoading: true,
    error: null,
  });

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  const fetchUser = useCallback(async () => {
    try {
      const {
        data: { user },
        error,
      } = await supabase.auth.getUser();

      if (error) throw error;

      setState({
        data: user,
        isLoading: false,
        error: null,
      });
    } catch (error) {
      setState({
        data: null,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to fetch user',
      });
    }
  }, [supabase]);

  const signIn = useCallback(
    async (email: string, password: string) => {
      setState((prev) => ({ ...prev, isLoading: true, error: null }));

      try {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password,
        });

        if (error) throw error;

        setState({
          data: data.user,
          isLoading: false,
          error: null,
        });
      } catch (error) {
        setState({
          data: null,
          isLoading: false,
          error: error instanceof Error ? error.message : 'Failed to sign in',
        });
        throw error;
      }
    },
    [supabase]
  );

  const signUp = useCallback(
    async (email: string, password: string) => {
      setState((prev) => ({ ...prev, isLoading: true, error: null }));

      try {
        const { data, error } = await supabase.auth.signUp({
          email,
          password,
        });

        if (error) throw error;

        setState({
          data: data.user,
          isLoading: false,
          error: null,
        });
      } catch (error) {
        setState({
          data: null,
          isLoading: false,
          error: error instanceof Error ? error.message : 'Failed to sign up',
        });
        throw error;
      }
    },
    [supabase]
  );

  const signOut = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const { error } = await supabase.auth.signOut();

      if (error) throw error;

      setState({
        data: null,
        isLoading: false,
        error: null,
      });
    } catch (error) {
      setState((prev) => ({
        ...prev,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to sign out',
      }));
      throw error;
    }
  }, [supabase]);

  const resetPassword = useCallback(
    async (email: string) => {
      try {
        const { error } = await supabase.auth.resetPasswordForEmail(email, {
          redirectTo: `${window.location.origin}/auth/callback`,
        });

        if (error) throw error;
      } catch (error) {
        throw error;
      }
    },
    [supabase]
  );

  const updatePassword = useCallback(
    async (newPassword: string) => {
      try {
        const { error } = await supabase.auth.updateUser({
          password: newPassword,
        });

        if (error) throw error;
      } catch (error) {
        throw error;
      }
    },
    [supabase]
  );

  useEffect(() => {
    fetchUser();

    const {
      data: { subscription },
    } = supabase.auth.onAuthStateChange((_event, session) => {
      setState({
        data: session?.user ?? null,
        isLoading: false,
        error: null,
      });
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [fetchUser, supabase]);

  return {
    ...state,
    signIn,
    signUp,
    signOut,
    resetPassword,
    updatePassword,
    isAuthenticated: !!state.data,
  };
}
</file>

<file path="hooks/useForm.ts">
'use client';

import { useState, useCallback, ChangeEvent, FormEvent } from 'react';
import { FormState, FormFieldState } from '@/types';

interface UseFormOptions<T> {
  initialValues: T;
  onSubmit: (values: T) => Promise<void> | void;
  validate?: (values: T) => Record<string, string>;
}

interface UseFormReturn<T> {
  values: T;
  errors: Record<string, string>;
  touched: Record<string, boolean>;
  isSubmitting: boolean;
  isDirty: boolean;
  isValid: boolean;
  handleChange: (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => void;
  handleBlur: (
    e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => void;
  handleSubmit: (e: FormEvent<HTMLFormElement>) => Promise<void>;
  setFieldValue: (name: keyof T, value: any) => void;
  setFieldError: (name: keyof T, error: string) => void;
  setFieldTouched: (name: keyof T, touched: boolean) => void;
  resetForm: () => void;
  setValues: (values: Partial<T>) => void;
}

/**
 * Custom hook for form handling
 * Provides form state management, validation, and submission
 */
export function useForm<T extends Record<string, any>>({
  initialValues,
  onSubmit,
  validate,
}: UseFormOptions<T>): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [touched, setTouched] = useState<Record<string, boolean>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const isDirty = JSON.stringify(values) !== JSON.stringify(initialValues);
  const isValid = Object.keys(errors).length === 0;

  const validateForm = useCallback(
    (formValues: T): Record<string, string> => {
      if (!validate) return {};
      return validate(formValues);
    },
    [validate]
  );

  const handleChange = useCallback(
    (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      const { name, value, type } = e.target;
      const fieldValue =
        type === 'checkbox' ? (e.target as HTMLInputElement).checked : value;

      setValues((prev) => ({
        ...prev,
        [name]: fieldValue,
      }));

      // Clear error when user starts typing
      if (errors[name]) {
        setErrors((prev) => {
          const newErrors = { ...prev };
          delete newErrors[name];
          return newErrors;
        });
      }
    },
    [errors]
  );

  const handleBlur = useCallback(
    (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
      const { name } = e.target;
      setTouched((prev) => ({ ...prev, [name]: true }));

      // Validate on blur
      const formErrors = validateForm(values);
      if (formErrors[name]) {
        setErrors((prev) => ({ ...prev, [name]: formErrors[name] }));
      }
    },
    [values, validateForm]
  );

  const handleSubmit = useCallback(
    async (e: FormEvent<HTMLFormElement>) => {
      e.preventDefault();

      // Mark all fields as touched
      const allTouched = Object.keys(values).reduce(
        (acc, key) => ({ ...acc, [key]: true }),
        {}
      );
      setTouched(allTouched);

      // Validate
      const formErrors = validateForm(values);
      setErrors(formErrors);

      if (Object.keys(formErrors).length > 0) {
        return;
      }

      setIsSubmitting(true);
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Form submission error:', error);
      } finally {
        setIsSubmitting(false);
      }
    },
    [values, validateForm, onSubmit]
  );

  const setFieldValue = useCallback((name: keyof T, value: any) => {
    setValues((prev) => ({ ...prev, [name]: value }));
  }, []);

  const setFieldError = useCallback((name: keyof T, error: string) => {
    setErrors((prev) => ({ ...prev, [name as string]: error }));
  }, []);

  const setFieldTouched = useCallback((name: keyof T, isTouched: boolean) => {
    setTouched((prev) => ({ ...prev, [name as string]: isTouched }));
  }, []);

  const resetForm = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  const setFormValues = useCallback((newValues: Partial<T>) => {
    setValues((prev) => ({ ...prev, ...newValues }));
  }, []);

  return {
    values,
    errors,
    touched,
    isSubmitting,
    isDirty,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    setFieldValue,
    setFieldError,
    setFieldTouched,
    resetForm,
    setValues: setFormValues,
  };
}
</file>

<file path="hooks/useMarketStands.ts">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { MarketStand, MarketStandWithDistance } from '@/types/marketStand';
import { DataLoadingState } from '@/types';

interface UseMarketStandsOptions {
  userId?: string;
  latitude?: number;
  longitude?: number;
  radiusKm?: number;
  limit?: number;
  autoFetch?: boolean;
}

interface UseMarketStandsReturn extends DataLoadingState<MarketStandWithDistance[]> {
  refetch: () => Promise<void>;
  addMarketStand: (marketStand: MarketStand) => void;
  updateMarketStand: (id: string, updates: Partial<MarketStand>) => void;
  removeMarketStand: (id: string) => void;
}

/**
 * Custom hook for managing market stands
 * Provides fetching, caching, and mutation capabilities for market stands
 */
export function useMarketStands(
  options: UseMarketStandsOptions = {}
): UseMarketStandsReturn {
  const {
    userId,
    latitude,
    longitude,
    radiusKm = 50,
    limit = 20,
    autoFetch = true,
  } = options;

  const [state, setState] = useState<DataLoadingState<MarketStandWithDistance[]>>({
    data: null,
    isLoading: false,
    error: null,
  });

  const fetchMarketStands = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const params = new URLSearchParams();
      if (userId) params.append('userId', userId);
      if (latitude !== undefined) params.append('latitude', latitude.toString());
      if (longitude !== undefined) params.append('longitude', longitude.toString());
      if (radiusKm !== undefined) params.append('radiusKm', radiusKm.toString());
      params.append('limit', limit.toString());

      const response = await fetch(`/api/market-stand?${params.toString()}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch market stands');
      }

      const data = await response.json();
      
      setState({
        data: data.marketStands || [],
        isLoading: false,
        error: null,
      });
    } catch (error) {
      setState({
        data: null,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to fetch market stands',
      });
    }
  }, [userId, latitude, longitude, radiusKm, limit]);

  const addMarketStand = useCallback((marketStand: MarketStand) => {
    setState((prev) => ({
      ...prev,
      data: prev.data
        ? [marketStand as MarketStandWithDistance, ...prev.data]
        : [marketStand as MarketStandWithDistance],
    }));
  }, []);

  const updateMarketStand = useCallback((id: string, updates: Partial<MarketStand>) => {
    setState((prev) => ({
      ...prev,
      data: prev.data
        ? prev.data.map((ms) => (ms.id === id ? { ...ms, ...updates } : ms))
        : null,
    }));
  }, []);

  const removeMarketStand = useCallback((id: string) => {
    setState((prev) => ({
      ...prev,
      data: prev.data ? prev.data.filter((ms) => ms.id !== id) : null,
    }));
  }, []);

  useEffect(() => {
    if (autoFetch) {
      fetchMarketStands();
    }
  }, [autoFetch, fetchMarketStands]);

  return {
    ...state,
    refetch: fetchMarketStands,
    addMarketStand,
    updateMarketStand,
    removeMarketStand,
  };
}
</file>

<file path="hooks/useProducts.ts">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Product, ExtendedProduct } from '@/types/product';
import { DataLoadingState } from '@/types';

interface UseProductsOptions {
  userId?: string;
  marketStandId?: string;
  limit?: number;
  autoFetch?: boolean;
}

interface UseProductsReturn extends DataLoadingState<ExtendedProduct[]> {
  refetch: () => Promise<void>;
  addProduct: (product: Product) => void;
  updateProduct: (id: string, updates: Partial<Product>) => void;
  removeProduct: (id: string) => void;
}

/**
 * Custom hook for managing products
 * Provides fetching, caching, and mutation capabilities for products
 */
export function useProducts(options: UseProductsOptions = {}): UseProductsReturn {
  const {
    userId,
    marketStandId,
    limit = 20,
    autoFetch = true,
  } = options;

  const [state, setState] = useState<DataLoadingState<ExtendedProduct[]>>({
    data: null,
    isLoading: false,
    error: null,
  });

  const fetchProducts = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const params = new URLSearchParams();
      if (userId) params.append('userId', userId);
      if (marketStandId) params.append('marketStandId', marketStandId);
      params.append('limit', limit.toString());

      const response = await fetch(`/api/product?${params.toString()}`);
      
      if (!response.ok) {
        throw new Error('Failed to fetch products');
      }

      const data = await response.json();
      
      setState({
        data: data.products || [],
        isLoading: false,
        error: null,
      });
    } catch (error) {
      setState({
        data: null,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Failed to fetch products',
      });
    }
  }, [userId, marketStandId, limit]);

  const addProduct = useCallback((product: Product) => {
    setState((prev) => ({
      ...prev,
      data: prev.data ? [product as ExtendedProduct, ...prev.data] : [product as ExtendedProduct],
    }));
  }, []);

  const updateProduct = useCallback((id: string, updates: Partial<Product>) => {
    setState((prev) => ({
      ...prev,
      data: prev.data
        ? prev.data.map((p) => (p.id === id ? { ...p, ...updates } : p))
        : null,
    }));
  }, []);

  const removeProduct = useCallback((id: string) => {
    setState((prev) => ({
      ...prev,
      data: prev.data ? prev.data.filter((p) => p.id !== id) : null,
    }));
  }, []);

  useEffect(() => {
    if (autoFetch) {
      fetchProducts();
    }
  }, [autoFetch, fetchProducts]);

  return {
    ...state,
    refetch: fetchProducts,
    addProduct,
    updateProduct,
    removeProduct,
  };
}
</file>

<file path="hooks/useUserLocation.ts">
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { type LocationType } from '../actions/home-products';

interface UseUserLocationOptions {
  enableHighAccuracy?: boolean;
  timeout?: number;
  maximumAge?: number;
  watchPosition?: boolean;
  minAccuracy?: number;
  cacheKey?: string;
  retryAttempts?: number;
  retryDelay?: number;
  onSuccess?: (location: LocationType) => void;
}

interface UseUserLocationResult {
  userLocation: LocationType | null;
  locationError: string | null;
  isLoadingLocation: boolean;
  retryLocation: () => void;
  accuracy: number | null;
  lastUpdated: number | null;
  clearLocation: () => void;
  setManualLocation: (location: LocationType) => void;
}

const DEFAULT_OPTIONS: UseUserLocationOptions = {
  enableHighAccuracy: true,
  timeout: 15000, // Increased timeout
  maximumAge: 5 * 60 * 1000, // 5 minutes
  watchPosition: false,
  minAccuracy: 2000, // Increased to 2km to be more lenient
  cacheKey: 'user_location',
  retryAttempts: 5, // Increased retry attempts
  retryDelay: 2000, // Increased delay between retries
};

const isLocationValid = (location: LocationType | null, minAccuracy: number): boolean => {
  if (!location?.coords) return false;
  return location.coords.accuracy ? location.coords.accuracy <= minAccuracy : true;
};

const getCachedLocation = (cacheKey: string): LocationType | null => {
  try {
    const cached = localStorage.getItem(cacheKey);
    if (!cached) return null;

    const parsed = JSON.parse(cached);
    const now = Date.now();
    const age = now - (parsed.coords.timestamp || 0);

    // Validate cache freshness (default 5 minutes)
    if (age > DEFAULT_OPTIONS.maximumAge!) {
      localStorage.removeItem(cacheKey);
      return null;
    }

    return parsed;
  } catch {
    return null;
  }
};

const cacheLocation = (location: LocationType, cacheKey: string): void => {
  try {
    localStorage.setItem(cacheKey, JSON.stringify(location));
  } catch (error) {
    console.error('Failed to cache location:', error);
  }
};

export default function useUserLocation(options: UseUserLocationOptions = {}): UseUserLocationResult {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
  const {
    enableHighAccuracy,
    timeout,
    maximumAge,
    watchPosition,
    minAccuracy,
    cacheKey,
    retryAttempts,
    retryDelay
  } = mergedOptions;

  const [userLocation, setUserLocation] = useState<LocationType | null>(() => {
    // Initialize with cached data if available
    return getCachedLocation(cacheKey!);
  });
  const [locationError, setLocationError] = useState<string | null>(null);
  const [isLoadingLocation, setIsLoadingLocation] = useState<boolean>(false);
  const [accuracy, setAccuracy] = useState<number | null>(null);
  const [lastUpdated, setLastUpdated] = useState<number | null>(null);

  const watchIdRef = useRef<number | null>(null);
  const retryCountRef = useRef<number>(0);
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Forward declarations
  const requestLocationRef = useRef<() => void>(() => {});
  const requestLocationFnRef = useRef<() => void>(() => requestLocationRef.current());

  const handleLocationSuccess = useCallback((position: GeolocationPosition): void => {
    const newLocation: LocationType = {
      coords: {
        lat: position.coords.latitude,
        lng: position.coords.longitude,
        accuracy: position.coords.accuracy,
        timestamp: position.timestamp
      },
      source: 'browser'
    };

    // Always set the location, but continue trying to get better accuracy if needed
    setUserLocation(newLocation);
    setAccuracy(position.coords.accuracy);
    setLastUpdated(position.timestamp);
    cacheLocation(newLocation, cacheKey!);
    
    // Call onSuccess callback if provided
    if (mergedOptions.onSuccess) {
      mergedOptions.onSuccess(newLocation);
    }

    if (!isLocationValid(newLocation, minAccuracy!)) {
      setLocationError(`Location accuracy is ${Math.round(position.coords.accuracy)}m (trying to improve...)`);
      if (retryCountRef.current < retryAttempts!) {
        retryTimeoutRef.current = setTimeout(() => {
          retryCountRef.current++;
          requestLocationFnRef.current();
        }, retryDelay! * Math.pow(2, retryCountRef.current));
      }
    } else {
      setLocationError(null);
      retryCountRef.current = 0;
    }
    setIsLoadingLocation(false);
  }, [minAccuracy, cacheKey, retryAttempts, retryDelay]);

  const handleLocationError = useCallback((error: GeolocationPositionError): void => {
    let errorMessage: string;
    switch (error.code) {
      case error.PERMISSION_DENIED:
        // Set a null location but don't treat it as an error to allow the app to proceed
        setUserLocation(null);
        setLocationError(null);
        break;
      case error.POSITION_UNAVAILABLE:
        errorMessage = 'Location information is unavailable. Please check your device settings.';
        setLocationError(errorMessage);
        break;
      case error.TIMEOUT:
        errorMessage = 'Location request timed out. Please check your connection and try again.';
        setLocationError(errorMessage);
        break;
      default:
        errorMessage = `Failed to get location: ${error.message}`;
        setLocationError(errorMessage);
    }

    setIsLoadingLocation(false);

    // Only retry for non-denial errors
    if (error.code !== error.PERMISSION_DENIED && retryCountRef.current < retryAttempts!) {
      retryTimeoutRef.current = setTimeout(() => {
        retryCountRef.current++;
        requestLocationFnRef.current();
      }, retryDelay! * Math.pow(2, retryCountRef.current));
    }
  }, [retryAttempts, retryDelay]);

  const clearLocation = useCallback((): void => {
    setUserLocation(null);
    setLocationError(null);
    setAccuracy(null);
    setLastUpdated(null);
    localStorage.removeItem(cacheKey!);
  }, [cacheKey]);

  const retryLocation = useCallback((): void => {
    if (retryTimeoutRef.current) {
      clearTimeout(retryTimeoutRef.current);
    }
    retryCountRef.current = 0;
    requestLocationFnRef.current();
  }, []);

  // Initialize requestLocationRef implementation
  useEffect(() => {
    requestLocationRef.current = () => {
      if (!navigator.geolocation) {
        setLocationError('Geolocation is not supported by this browser.');
        return;
      }

      if (!window.isSecureContext) {
        setLocationError('Geolocation requires a secure context (HTTPS).');
        return;
      }

      setIsLoadingLocation(true);
      setLocationError(null);

      const options: PositionOptions = {
        enableHighAccuracy,
        timeout,
        maximumAge
      };

      if (watchPosition && !watchIdRef.current) {
        watchIdRef.current = navigator.geolocation.watchPosition(
          handleLocationSuccess,
          handleLocationError,
          options
        );
      } else {
        navigator.geolocation.getCurrentPosition(
          handleLocationSuccess,
          handleLocationError,
          options
        );
      }
    };
  }, [enableHighAccuracy, timeout, maximumAge, watchPosition, handleLocationSuccess, handleLocationError]);

  // Start location tracking
  useEffect(() => {
    requestLocationFnRef.current();

    return () => {
      if (watchIdRef.current !== null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
        watchIdRef.current = null;
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, []);

  const setManualLocation = useCallback((location: LocationType): void => {
    setUserLocation(location);
    setLocationError(null);
    setAccuracy(location.coords.accuracy || 0);
    setLastUpdated(location.coords.timestamp || Date.now());
    cacheLocation(location, cacheKey!);
  }, [cacheKey]);

  return {
    userLocation,
    locationError,
    isLoadingLocation,
    retryLocation,
    accuracy,
    lastUpdated,
    clearLocation,
    setManualLocation
  };
}
</file>

<file path="lib/cache/redis.ts">
import { Redis } from '@upstash/redis';
import { env } from '@/lib/env';
import { logError } from '@/lib/logger';

/**
 * Redis Cache Service
 * Provides caching functionality using Upstash Redis
 */

// Initialize Redis client
const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

/**
 * Cache TTL configurations (in seconds)
 */
export const CACHE_TTL = {
  PRODUCT_LISTING: 5 * 60, // 5 minutes
  MARKET_STAND_DATA: 10 * 60, // 10 minutes
  USER_PROFILE: 15 * 60, // 15 minutes
  STATIC_CONTENT: 60 * 60, // 1 hour
  USER_SESSION: 24 * 60 * 60, // 24 hours
} as const;

/**
 * Cache key prefixes for organization
 */
export const CACHE_KEYS = {
  PRODUCT: 'product',
  PRODUCTS_LIST: 'products:list',
  PRODUCTS_BY_STAND: 'products:stand',
  PRODUCTS_BY_USER: 'products:user',
  MARKET_STAND: 'stand',
  MARKET_STANDS_LIST: 'stands:list',
  MARKET_STANDS_BY_LOCATION: 'stands:location',
  MARKET_STANDS_BY_USER: 'stands:user',
  USER_PROFILE: 'user:profile',
  USER_SESSION: 'user:session',
} as const;

/**
 * Generate cache key
 */
export function generateCacheKey(prefix: string, ...parts: (string | number | boolean)[]): string {
  return `${prefix}:${parts.join(':')}`;
}

/**
 * Get value from cache
 */
export async function getCached<T>(key: string): Promise<T | null> {
  try {
    const data = await redis.get<T>(key);
    return data;
  } catch (error) {
    logError(`Cache get error for key ${key}:`, error);
    return null;
  }
}

/**
 * Set value in cache with TTL
 */
export async function setCached<T>(
  key: string,
  value: T,
  ttlSeconds: number = CACHE_TTL.PRODUCT_LISTING
): Promise<void> {
  try {
    await redis.setex(key, ttlSeconds, JSON.stringify(value));
  } catch (error) {
    logError(`Cache set error for key ${key}:`, error);
  }
}

/**
 * Delete value from cache
 */
export async function deleteCached(key: string): Promise<void> {
  try {
    await redis.del(key);
  } catch (error) {
    logError(`Cache delete error for key ${key}:`, error);
  }
}

/**
 * Delete multiple keys by pattern
 */
export async function deleteByPattern(pattern: string): Promise<void> {
  try {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  } catch (error) {
    logError(`Cache delete pattern error for pattern ${pattern}:`, error);
  }
}

/**
 * Invalidate all product-related caches
 */
export async function invalidateProductCaches(productId?: string): Promise<void> {
  try {
    const patterns = [
      `${CACHE_KEYS.PRODUCTS_LIST}:*`,
      `${CACHE_KEYS.PRODUCTS_BY_STAND}:*`,
      `${CACHE_KEYS.PRODUCTS_BY_USER}:*`,
    ];

    if (productId) {
      patterns.push(generateCacheKey(CACHE_KEYS.PRODUCT, productId));
    }

    await Promise.all(patterns.map(pattern => deleteByPattern(pattern)));
  } catch (error) {
    logError('Product cache invalidation error:', error);
  }
}

/**
 * Invalidate all market stand-related caches
 */
export async function invalidateMarketStandCaches(standId?: string): Promise<void> {
  try {
    const patterns = [
      `${CACHE_KEYS.MARKET_STANDS_LIST}:*`,
      `${CACHE_KEYS.MARKET_STANDS_BY_LOCATION}:*`,
      `${CACHE_KEYS.MARKET_STANDS_BY_USER}:*`,
      `${CACHE_KEYS.PRODUCTS_BY_STAND}:*`, // Also invalidate products by stand
    ];

    if (standId) {
      patterns.push(generateCacheKey(CACHE_KEYS.MARKET_STAND, standId));
    }

    await Promise.all(patterns.map(pattern => deleteByPattern(pattern)));
  } catch (error) {
    logError('Market stand cache invalidation error:', error);
  }
}

/**
 * Invalidate user-related caches
 */
export async function invalidateUserCaches(userId: string): Promise<void> {
  try {
    const patterns = [
      generateCacheKey(CACHE_KEYS.USER_PROFILE, userId),
      `${CACHE_KEYS.PRODUCTS_BY_USER}:${userId}:*`,
      `${CACHE_KEYS.MARKET_STANDS_BY_USER}:${userId}:*`,
    ];

    await Promise.all(patterns.map(pattern => deleteByPattern(pattern)));
  } catch (error) {
    logError('User cache invalidation error:', error);
  }
}

/**
 * Cache-aside pattern helper
 * Checks cache first, if miss, executes function and caches result
 */
export async function cacheAside<T>(
  key: string,
  ttl: number,
  fetchFn: () => Promise<T>
): Promise<T> {
  // Try to get from cache first
  const cached = await getCached<T>(key);
  if (cached !== null) {
    return cached;
  }

  // Cache miss - fetch from source
  const data = await fetchFn();

  // Store in cache (don't await to avoid blocking)
  setCached(key, data, ttl).catch(err =>
    logError(`Background cache set failed for key ${key}:`, err)
  );

  return data;
}

/**
 * Batch cache operations for better performance
 */
export async function batchGetCached<T>(keys: string[]): Promise<(T | null)[]> {
  try {
    const pipeline = redis.pipeline();
    keys.forEach(key => pipeline.get(key));
    const results = await pipeline.exec();
    return results as (T | null)[];
  } catch (error) {
    logError('Batch cache get error:', error);
    return keys.map(() => null);
  }
}

/**
 * Health check for Redis connection
 */
export async function checkRedisHealth(): Promise<boolean> {
  try {
    await redis.ping();
    return true;
  } catch (error) {
    logError('Redis health check failed:', error);
    return false;
  }
}

export { redis };
</file>

<file path="lib/cache/revalidation.ts">
import { revalidateTag, revalidatePath } from 'next/cache';

/**
 * Cache tag constants for data revalidation
 */
export const CacheTags = {
  PRODUCTS: 'products',
  PRODUCT: (id: string) => `product-${id}`,
  MARKET_STANDS: 'market-stands',
  MARKET_STAND: (id: string) => `market-stand-${id}`,
  USER_PRODUCTS: (userId: string) => `user-products-${userId}`,
  USER_MARKET_STAND: (userId: string) => `user-market-stand-${userId}`,
} as const;

/**
 * Revalidate all product-related caches
 */
export function revalidateProducts() {
  revalidateTag(CacheTags.PRODUCTS);
  revalidatePath('/', 'page');
  revalidatePath('/dashboard/sell', 'page');
}

/**
 * Revalidate a specific product cache
 */
export function revalidateProduct(productId: string) {
  revalidateTag(CacheTags.PRODUCT(productId));
  revalidateTag(CacheTags.PRODUCTS);
  revalidatePath('/', 'page');
  revalidatePath(`/product/${productId}`, 'page');
}

/**
 * Revalidate user's products
 */
export function revalidateUserProducts(userId: string) {
  revalidateTag(CacheTags.USER_PRODUCTS(userId));
  revalidateTag(CacheTags.PRODUCTS);
  revalidatePath('/dashboard/sell', 'page');
}

/**
 * Revalidate all market stand caches
 */
export function revalidateMarketStands() {
  revalidateTag(CacheTags.MARKET_STANDS);
  revalidatePath('/', 'page');
  revalidatePath('/dashboard/market-stand', 'page');
}

/**
 * Revalidate a specific market stand cache
 */
export function revalidateMarketStand(standId: string) {
  revalidateTag(CacheTags.MARKET_STAND(standId));
  revalidateTag(CacheTags.MARKET_STANDS);
  revalidatePath(`/market-stand/${standId}`, 'page');
  revalidatePath('/dashboard/market-stand', 'page');
}

/**
 * Revalidate user's market stand
 */
export function revalidateUserMarketStand(userId: string) {
  revalidateTag(CacheTags.USER_MARKET_STAND(userId));
  revalidateTag(CacheTags.MARKET_STANDS);
  revalidatePath('/dashboard/market-stand', 'page');
}
</file>

<file path="lib/dto/marketStand.dto.ts">
import { Status } from "@prisma/client";

// Weekly hours type
export interface DayHours {
  open: string | null;
  close: string | null;
  closed: boolean;
}

export interface WeeklyHours {
  monday: DayHours;
  tuesday: DayHours;
  wednesday: DayHours;
  thursday: DayHours;
  friday: DayHours;
  saturday: DayHours;
  sunday: DayHours;
}

// Base market stand DTO
export interface MarketStandDTO {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  tags: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  website: string | null;
  socialMedia: string[];
  status: Status;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  userId: string;
  averageRating: number | null;
  totalReviews: number;
  hours: WeeklyHours | null;
}

// Market stand creation DTO
export interface CreateMarketStandDTO {
  userId: string;
  name: string;
  description: string;
  locationName: string;
  locationGuide: string;
  latitude: number;
  longitude: number;
  website?: string | null;
  images: string[];
  tags: string[];
  socialMedia: string[];
  hours: WeeklyHours;
  status: Status;
  isActive: boolean;
}

// Market stand update DTO
export interface UpdateMarketStandDTO {
  name?: string;
  description?: string;
  locationName?: string;
  locationGuide?: string;
  latitude?: number;
  longitude?: number;
  website?: string | null;
  images?: string[];
  tags?: string[];
  socialMedia?: string[];
  hours?: WeeklyHours;
  status?: Status;
  isActive?: boolean;
}

// Market stand query filters
export interface MarketStandQueryFilters {
  userId?: string;
  limit?: number;
  cursor?: string;
  isActive?: boolean;
  latitude?: number;
  longitude?: number;
  radiusKm?: number;
}

// Market stand list response
export interface MarketStandListDTO {
  marketStands: MarketStandDTO[];
  nextCursor?: string;
  hasMore: boolean;
}

// Market stand with distance (for location-based queries)
export interface MarketStandWithDistanceDTO extends MarketStandDTO {
  distanceKm: number;
}
</file>

<file path="lib/dto/product.dto.ts">
import { Status } from "@prisma/client";

// Base product DTO
export interface ProductDTO {
  id: string;
  name: string;
  description: string;
  price: number;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: string | null;
  status: Status;
  isActive: boolean;
  userId: string;
  marketStandId: string;
  createdAt: string;
  updatedAt: string;
  totalReviews: number;
  averageRating: number | null;
  tags: string[];
}

// Product with market stand details
export interface ProductWithMarketStandDTO extends ProductDTO {
  marketStand: {
    id: string;
    name: string;
    locationName?: string;
    latitude: number;
    longitude: number;
  };
  locationName?: string;
}

// Product creation DTO
export interface CreateProductDTO {
  name: string;
  description: string;
  price: number;
  images: string[];
  inventory: number;
  inventoryUpdatedAt?: string | null;
  status: Status;
  isActive: boolean;
  userId: string;
  marketStandId: string;
  tags: string[];
}

// Product update DTO
export interface UpdateProductDTO {
  name?: string;
  description?: string;
  price?: number;
  images?: string[];
  inventory?: number;
  inventoryUpdatedAt?: string | null;
  status?: Status;
  isActive?: boolean;
  tags?: string[];
}

// Product query filters
export interface ProductQueryFilters {
  userId?: string;
  marketStandId?: string;
  limit?: number;
  cursor?: string;
  isActive?: boolean;
}

// Product list response
export interface ProductListDTO {
  products: ProductWithMarketStandDTO[];
  nextCursor?: string;
  hasMore: boolean;
}
</file>

<file path="lib/repositories/marketStandRepository.ts">
import prisma, { withTransaction } from "@/lib/db";
import { Status } from "@prisma/client";
import { serializeMarketStand, serializeMarketStands } from "@/lib/serializers";
import { MarketStandDTO, MarketStandQueryFilters, WeeklyHours } from "@/lib/dto/marketStand.dto";
import {
  cacheAside,
  generateCacheKey,
  CACHE_KEYS,
  CACHE_TTL,
  invalidateMarketStandCaches,
} from "@/lib/cache/redis";

/**
 * Market Stand Repository - Handles all database operations for market stands
 * Follows the Repository pattern to abstract data access logic
 */
export class MarketStandRepository {
  /**
   * Find market stands with optional filtering
   * Implements caching for frequently accessed market stand listings
   */
  async findMany(filters: MarketStandQueryFilters): Promise<MarketStandDTO[]> {
    const {
      userId,
      limit = 50,
      cursor,
      isActive = true,
    } = filters;

    // Generate cache key based on filters
    const cacheKeyPrefix = userId
      ? CACHE_KEYS.MARKET_STANDS_BY_USER
      : CACHE_KEYS.MARKET_STANDS_LIST;

    const cacheKey = generateCacheKey(
      cacheKeyPrefix,
      userId || 'all',
      isActive,
      limit,
      cursor || 'start'
    );

    return cacheAside(cacheKey, CACHE_TTL.MARKET_STAND_DATA, async () => {
      const marketStands = await prisma.marketStand.findMany({
        take: limit,
        skip: cursor ? 1 : 0,
        cursor: cursor ? { id: cursor } : undefined,
        where: {
          isActive,
          ...(userId && { userId }),
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      return serializeMarketStands(marketStands);
    });
  }

  /**
   * Find market stands by location (within radius)
   * Implements caching for location-based queries
   */
  async findByLocation(
    latitude: number,
    longitude: number,
    radiusKm: number,
    filters: Omit<MarketStandQueryFilters, 'latitude' | 'longitude' | 'radiusKm'> = {}
  ): Promise<MarketStandDTO[]> {
    const { limit = 50, isActive = true } = filters;

    // Generate cache key for location-based query (rounded to reduce cache variations)
    const roundedLat = Math.round(latitude * 100) / 100;
    const roundedLng = Math.round(longitude * 100) / 100;
    const cacheKey = generateCacheKey(
      CACHE_KEYS.MARKET_STANDS_BY_LOCATION,
      roundedLat,
      roundedLng,
      radiusKm,
      isActive,
      limit
    );

    return cacheAside(cacheKey, CACHE_TTL.MARKET_STAND_DATA, async () => {
      // Calculate approximate lat/lng bounds (rough approximation)
      // 1 degree of latitude ≈ 111 km
      // 1 degree of longitude ≈ 111 km * cos(latitude)
      const latDelta = radiusKm / 111;
      const lngDelta = radiusKm / (111 * Math.cos((latitude * Math.PI) / 180));

      const marketStands = await prisma.marketStand.findMany({
        take: limit,
        where: {
          isActive,
          latitude: {
            gte: latitude - latDelta,
            lte: latitude + latDelta,
          },
          longitude: {
            gte: longitude - lngDelta,
            lte: longitude + lngDelta,
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      return serializeMarketStands(marketStands);
    });
  }

  /**
   * Find a single market stand by ID
   * Implements caching for individual market stand lookups
   */
  async findById(id: string): Promise<MarketStandDTO | null> {
    const cacheKey = generateCacheKey(CACHE_KEYS.MARKET_STAND, id);

    return cacheAside(cacheKey, CACHE_TTL.MARKET_STAND_DATA, async () => {
      const marketStand = await prisma.marketStand.findUnique({
        where: { id },
      });

      if (!marketStand) return null;

      return serializeMarketStand(marketStand);
    });
  }

  /**
   * Find market stand by ID for a specific user (ownership check)
   */
  async findByIdAndUserId(id: string, userId: string): Promise<MarketStandDTO | null> {
    const marketStand = await prisma.marketStand.findFirst({
      where: {
        id,
        userId,
      },
    });

    if (!marketStand) return null;

    return serializeMarketStand(marketStand);
  }

  /**
   * Create a new market stand
   * Invalidates relevant caches after creation
   */
  async create(data: {
    userId: string;
    name: string;
    description: string;
    locationName: string;
    locationGuide: string;
    latitude: number;
    longitude: number;
    website?: string | null;
    images: string[];
    tags: string[];
    socialMedia: string[];
    hours: WeeklyHours;
    status: Status;
    isActive: boolean;
  }): Promise<MarketStandDTO> {
    const marketStand = await withTransaction(async (tx) => {
      return tx.marketStand.create({
        data: {
          userId: data.userId,
          name: data.name,
          description: data.description,
          locationName: data.locationName,
          locationGuide: data.locationGuide,
          latitude: data.latitude,
          longitude: data.longitude,
          website: data.website || null,
          images: data.images,
          tags: data.tags,
          socialMedia: data.socialMedia,
          hours: data.hours as any,
          status: data.status,
          isActive: data.isActive,
        },
      });
    });

    // Invalidate caches asynchronously
    invalidateMarketStandCaches().catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeMarketStand(marketStand);
  }

  /**
   * Update an existing market stand
   * Invalidates relevant caches after update
   */
  async update(
    id: string,
    data: Partial<{
      name: string;
      description: string;
      locationName: string;
      locationGuide: string;
      latitude: number;
      longitude: number;
      website: string | null;
      images: string[];
      tags: string[];
      socialMedia: string[];
      hours: WeeklyHours;
      status: Status;
      isActive: boolean;
    }>
  ): Promise<MarketStandDTO> {
    const marketStand = await withTransaction(async (tx) => {
      // First verify the market stand exists
      const existing = await tx.marketStand.findUnique({
        where: { id },
      });

      if (!existing) {
        throw new Error('Market stand not found');
      }

      return tx.marketStand.update({
        where: { id },
        data: {
          ...(data.name !== undefined && { name: data.name }),
          ...(data.description !== undefined && { description: data.description }),
          ...(data.locationName !== undefined && { locationName: data.locationName }),
          ...(data.locationGuide !== undefined && { locationGuide: data.locationGuide }),
          ...(data.latitude !== undefined && { latitude: data.latitude }),
          ...(data.longitude !== undefined && { longitude: data.longitude }),
          ...(data.website !== undefined && { website: data.website }),
          ...(data.images !== undefined && { images: data.images }),
          ...(data.tags !== undefined && { tags: data.tags }),
          ...(data.socialMedia !== undefined && { socialMedia: data.socialMedia }),
          ...(data.hours !== undefined && { hours: data.hours as any }),
          ...(data.status !== undefined && { status: data.status }),
          ...(data.isActive !== undefined && { isActive: data.isActive }),
        },
      });
    });

    // Invalidate caches asynchronously
    invalidateMarketStandCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeMarketStand(marketStand);
  }

  /**
   * Delete a market stand
   * Invalidates relevant caches after deletion
   */
  async delete(id: string): Promise<void> {
    await prisma.marketStand.delete({
      where: { id },
    });

    // Invalidate caches asynchronously
    invalidateMarketStandCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });
  }

  /**
   * Check if a market stand exists
   */
  async exists(id: string): Promise<boolean> {
    const count = await prisma.marketStand.count({
      where: { id },
    });
    return count > 0;
  }

  /**
   * Count market stands with optional filters
   */
  async count(filters: Omit<MarketStandQueryFilters, 'limit' | 'cursor'>): Promise<number> {
    const { userId, isActive = true } = filters;

    return await prisma.marketStand.count({
      where: {
        isActive,
        ...(userId && { userId }),
      },
    });
  }

  /**
   * Update market stand status
   * Invalidates relevant caches after update
   */
  async updateStatus(id: string, status: Status): Promise<MarketStandDTO> {
    const marketStand = await prisma.marketStand.update({
      where: { id },
      data: {
        status,
      },
    });

    // Invalidate caches asynchronously
    invalidateMarketStandCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeMarketStand(marketStand);
  }

  /**
   * Get market stands by user ID
   */
  async findByUserId(userId: string): Promise<MarketStandDTO[]> {
    const marketStands = await prisma.marketStand.findMany({
      where: { userId },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return serializeMarketStands(marketStands);
  }
}

// Export singleton instance
export const marketStandRepository = new MarketStandRepository();
</file>

<file path="lib/repositories/productRepository.ts">
import prisma from "@/lib/db";
import { Prisma, Status } from "@prisma/client";
import { serializeProduct, serializeProducts } from "@/lib/serializers";
import { ProductWithMarketStandDTO, ProductQueryFilters } from "@/lib/dto/product.dto";
import {
  cacheAside,
  generateCacheKey,
  CACHE_KEYS,
  CACHE_TTL,
  invalidateProductCaches,
} from "@/lib/cache/redis";

/**
 * Product Repository - Handles all database operations for products
 * Follows the Repository pattern to abstract data access logic
 */
export class ProductRepository {
  /**
   * Find products with optional filtering
   * Implements caching for frequently accessed product listings
   */
  async findMany(filters: ProductQueryFilters): Promise<ProductWithMarketStandDTO[]> {
    const {
      userId,
      marketStandId,
      limit = 50,
      cursor,
      isActive = true,
    } = filters;

    // Generate cache key based on filters
    const cacheKeyPrefix = marketStandId
      ? CACHE_KEYS.PRODUCTS_BY_STAND
      : userId
      ? CACHE_KEYS.PRODUCTS_BY_USER
      : CACHE_KEYS.PRODUCTS_LIST;

    const cacheKey = generateCacheKey(
      cacheKeyPrefix,
      userId || 'all',
      marketStandId || 'all',
      isActive,
      limit,
      cursor || 'start'
    );

    return cacheAside(cacheKey, CACHE_TTL.PRODUCT_LISTING, async () => {
      const products = await prisma.product.findMany({
        take: limit,
        skip: cursor ? 1 : 0,
        cursor: cursor ? { id: cursor } : undefined,
        where: {
          isActive,
          ...(userId && { userId }),
          ...(marketStandId && { marketStandId }),
        },
        orderBy: {
          createdAt: 'desc',
        },
        include: {
          marketStand: {
            select: {
              id: true,
              name: true,
              locationName: true,
              latitude: true,
              longitude: true,
            },
          },
        },
      });

      return serializeProducts(products);
    });
  }

  /**
   * Find a single product by ID
   * Implements caching for individual product lookups
   */
  async findById(id: string): Promise<ProductWithMarketStandDTO | null> {
    const cacheKey = generateCacheKey(CACHE_KEYS.PRODUCT, id);

    return cacheAside(cacheKey, CACHE_TTL.PRODUCT_LISTING, async () => {
      const product = await prisma.product.findUnique({
        where: { id },
        include: {
          marketStand: {
            select: {
              id: true,
              name: true,
              locationName: true,
              latitude: true,
              longitude: true,
            },
          },
        },
      });

      if (!product) return null;

      return serializeProduct(product);
    });
  }

  /**
   * Find product by ID for a specific user (ownership check)
   */
  async findByIdAndUserId(id: string, userId: string): Promise<ProductWithMarketStandDTO | null> {
    const product = await prisma.product.findFirst({
      where: {
        id,
        userId,
      },
      include: {
        marketStand: {
          select: {
            id: true,
            name: true,
            locationName: true,
            latitude: true,
            longitude: true,
          },
        },
      },
    });

    if (!product) return null;

    return serializeProduct(product);
  }

  /**
   * Create a new product
   * Invalidates relevant caches after creation
   */
  async create(data: {
    name: string;
    description: string;
    price: number;
    images: string[];
    inventory: number;
    inventoryUpdatedAt?: Date | null;
    status: Status;
    isActive: boolean;
    userId: string;
    marketStandId: string;
    tags: string[];
  }): Promise<ProductWithMarketStandDTO> {
    const product = await prisma.product.create({
      data,
      include: {
        marketStand: {
          select: {
            id: true,
            name: true,
            locationName: true,
            latitude: true,
            longitude: true,
          },
        },
      },
    });

    // Invalidate caches asynchronously
    invalidateProductCaches().catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeProduct(product);
  }

  /**
   * Update an existing product
   * Invalidates relevant caches after update
   */
  async update(
    id: string,
    data: Partial<{
      name: string;
      description: string;
      price: number;
      images: string[];
      inventory: number;
      inventoryUpdatedAt: Date | null;
      status: Status;
      isActive: boolean;
      tags: string[];
    }>
  ): Promise<ProductWithMarketStandDTO> {
    const product = await prisma.product.update({
      where: { id },
      data,
      include: {
        marketStand: {
          select: {
            id: true,
            name: true,
            locationName: true,
            latitude: true,
            longitude: true,
          },
        },
      },
    });

    // Invalidate caches asynchronously
    invalidateProductCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeProduct(product);
  }

  /**
   * Delete a product
   * Invalidates relevant caches after deletion
   */
  async delete(id: string): Promise<void> {
    await prisma.product.delete({
      where: { id },
    });

    // Invalidate caches asynchronously
    invalidateProductCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });
  }

  /**
   * Check if a product exists
   */
  async exists(id: string): Promise<boolean> {
    const count = await prisma.product.count({
      where: { id },
    });
    return count > 0;
  }

  /**
   * Count products with optional filters
   */
  async count(filters: Omit<ProductQueryFilters, 'limit' | 'cursor'>): Promise<number> {
    const { userId, marketStandId, isActive = true } = filters;

    return await prisma.product.count({
      where: {
        isActive,
        ...(userId && { userId }),
        ...(marketStandId && { marketStandId }),
      },
    });
  }

  /**
   * Update product inventory
   * Invalidates relevant caches after update
   */
  async updateInventory(id: string, inventory: number): Promise<ProductWithMarketStandDTO> {
    const product = await prisma.product.update({
      where: { id },
      data: {
        inventory,
        inventoryUpdatedAt: new Date(),
      },
      include: {
        marketStand: {
          select: {
            id: true,
            name: true,
            locationName: true,
            latitude: true,
            longitude: true,
          },
        },
      },
    });

    // Invalidate caches asynchronously
    invalidateProductCaches(id).catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return serializeProduct(product);
  }

  /**
   * Bulk update product status
   * Invalidates relevant caches after update
   */
  async bulkUpdateStatus(productIds: string[], status: Status): Promise<number> {
    const result = await prisma.product.updateMany({
      where: {
        id: {
          in: productIds,
        },
      },
      data: {
        status,
      },
    });

    // Invalidate caches asynchronously
    invalidateProductCaches().catch(err => {
      console.error('Cache invalidation error:', err);
    });

    return result.count;
  }
}

// Export singleton instance
export const productRepository = new ProductRepository();
</file>

<file path="lib/services/marketStandService.ts">
import { marketStandRepository } from "@/lib/repositories/marketStandRepository";
import {
  createMarketStandSchema,
  updateMarketStandSchema,
  getMarketStandsQuerySchema,
  marketStandIdSchema,
  type CreateMarketStandInput,
  type UpdateMarketStandInput,
  type GetMarketStandsQuery,
} from "@/lib/validators/marketStandSchemas";
import { MarketStandDTO, MarketStandQueryFilters } from "@/lib/dto/marketStand.dto";
import { handleDatabaseError } from "@/lib/error-handler";
import { ZodError } from "zod";

/**
 * Market Stand Service - Contains business logic for market stand operations
 * Uses repository for data access and validators for input validation
 */
export class MarketStandService {
  /**
   * Get multiple market stands with filtering
   */
  async getMarketStands(query: GetMarketStandsQuery): Promise<MarketStandDTO[]> {
    try {
      // Validate query parameters
      const validatedQuery = getMarketStandsQuerySchema.parse(query);

      // If location-based search is requested
      if (
        validatedQuery.latitude !== undefined &&
        validatedQuery.longitude !== undefined &&
        validatedQuery.radiusKm !== undefined
      ) {
        return await marketStandRepository.findByLocation(
          validatedQuery.latitude,
          validatedQuery.longitude,
          validatedQuery.radiusKm,
          {
            limit: validatedQuery.limit,
            isActive: validatedQuery.isActive,
          }
        );
      }

      // Use repository to fetch data
      return await marketStandRepository.findMany(validatedQuery);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      const errorData = handleDatabaseError(error, "Failed to fetch market stands", {
        query,
      });
      console.error('Error fetching market stands:', errorData);
      return [];
    }
  }

  /**
   * Get a single market stand by ID
   */
  async getMarketStandById(id: string): Promise<MarketStandDTO | null> {
    try {
      // Validate ID
      const validatedId = marketStandIdSchema.parse(id);

      // Use repository to fetch data
      return await marketStandRepository.findById(validatedId);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Invalid market stand ID: ${error.errors[0].message}`);
      }

      const errorData = handleDatabaseError(error, "Failed to fetch market stand", {
        marketStandId: id,
      });
      console.error('Error fetching market stand:', errorData);
      return null;
    }
  }

  /**
   * Create a new market stand
   */
  async createMarketStand(input: CreateMarketStandInput): Promise<MarketStandDTO> {
    try {
      // Validate input
      const validatedData = createMarketStandSchema.parse(input);

      // Business logic validations could go here
      // For example: Check if user already has a market stand, validate location, etc.

      // Use repository to create market stand
      return await marketStandRepository.create(validatedData);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      const errorData = handleDatabaseError(error, "Failed to create market stand", {
        name: input.name,
        userId: input.userId,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Update an existing market stand
   */
  async updateMarketStand(
    id: string,
    input: UpdateMarketStandInput
  ): Promise<MarketStandDTO> {
    try {
      // Validate ID and input
      const validatedId = marketStandIdSchema.parse(id);
      const validatedData = updateMarketStandSchema.parse(input);

      // Check if market stand exists
      const exists = await marketStandRepository.exists(validatedId);
      if (!exists) {
        throw new Error(`Market stand with ID ${validatedId} not found`);
      }

      // Use repository to update market stand
      return await marketStandRepository.update(validatedId, validatedData);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      if (error instanceof Error && error.message.includes('not found')) {
        throw error;
      }

      const errorData = handleDatabaseError(error, "Failed to update market stand", {
        marketStandId: id,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Delete a market stand
   */
  async deleteMarketStand(id: string): Promise<void> {
    try {
      // Validate ID
      const validatedId = marketStandIdSchema.parse(id);

      // Check if market stand exists
      const exists = await marketStandRepository.exists(validatedId);
      if (!exists) {
        throw new Error(`Market stand with ID ${validatedId} not found`);
      }

      // Business logic: Check if there are associated products
      // (You might want to prevent deletion if products exist, or cascade delete)

      // Use repository to delete market stand
      await marketStandRepository.delete(validatedId);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Invalid market stand ID: ${error.errors[0].message}`);
      }

      if (error instanceof Error && error.message.includes('not found')) {
        throw error;
      }

      const errorData = handleDatabaseError(error, "Failed to delete market stand", {
        marketStandId: id,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Get market stands by user ID
   */
  async getMarketStandsByUserId(
    userId: string,
    filters?: Omit<MarketStandQueryFilters, 'userId'>
  ): Promise<MarketStandDTO[]> {
    try {
      return await marketStandRepository.findByUserId(userId);
    } catch (error) {
      const errorData = handleDatabaseError(error, "Failed to fetch user market stands", {
        userId,
      });
      console.error('Error fetching user market stands:', errorData);
      return [];
    }
  }

  /**
   * Get market stands near a location
   */
  async getMarketStandsNearLocation(
    latitude: number,
    longitude: number,
    radiusKm: number = 10
  ): Promise<MarketStandDTO[]> {
    try {
      return await marketStandRepository.findByLocation(latitude, longitude, radiusKm);
    } catch (error) {
      const errorData = handleDatabaseError(error, "Failed to fetch nearby market stands", {
        latitude,
        longitude,
        radiusKm,
      });
      console.error('Error fetching nearby market stands:', errorData);
      return [];
    }
  }

  /**
   * Check if user owns market stand
   */
  async checkMarketStandOwnership(marketStandId: string, userId: string): Promise<boolean> {
    try {
      const marketStand = await marketStandRepository.findByIdAndUserId(marketStandId, userId);
      return marketStand !== null;
    } catch (error) {
      console.error('Error checking market stand ownership:', error);
      return false;
    }
  }

  /**
   * Count market stands with optional filters
   */
  async countMarketStands(filters: Omit<MarketStandQueryFilters, 'limit' | 'cursor'>): Promise<number> {
    try {
      return await marketStandRepository.count(filters);
    } catch (error) {
      const errorData = handleDatabaseError(error, "Failed to count market stands", {
        filters,
      });
      console.error('Error counting market stands:', errorData);
      return 0;
    }
  }
}

// Export singleton instance
export const marketStandService = new MarketStandService();
</file>

<file path="lib/services/productService.ts">
import { productRepository } from "@/lib/repositories/productRepository";
import {
  createProductSchema,
  updateProductSchema,
  getProductsQuerySchema,
  productIdSchema,
  type CreateProductInput,
  type UpdateProductInput,
  type GetProductsQuery,
} from "@/lib/validators/productSchemas";
import {
  ProductWithMarketStandDTO,
  ProductQueryFilters,
} from "@/lib/dto/product.dto";
import { handleDatabaseError } from "@/lib/error-handler";
import { ZodError } from "zod";

/**
 * Product Service - Contains business logic for product operations
 * Uses repository for data access and validators for input validation
 */
export class ProductService {
  /**
   * Get multiple products with filtering
   */
  async getProducts(query: GetProductsQuery): Promise<ProductWithMarketStandDTO[]> {
    try {
      // Validate query parameters
      const validatedQuery = getProductsQuerySchema.parse(query);

      // Use repository to fetch data
      return await productRepository.findMany(validatedQuery);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      const errorData = handleDatabaseError(error, "Failed to fetch products", {
        query,
      });
      console.error('Error fetching products:', errorData);
      return [];
    }
  }

  /**
   * Get a single product by ID
   */
  async getProductById(id: string): Promise<ProductWithMarketStandDTO | null> {
    try {
      // Validate ID
      const validatedId = productIdSchema.parse(id);

      // Use repository to fetch data
      return await productRepository.findById(validatedId);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Invalid product ID: ${error.errors[0].message}`);
      }

      const errorData = handleDatabaseError(error, "Failed to fetch product", {
        productId: id,
      });
      console.error('Error fetching product:', errorData);
      return null;
    }
  }

  /**
   * Create a new product
   */
  async createProduct(input: CreateProductInput): Promise<ProductWithMarketStandDTO> {
    try {
      // Validate input
      const validatedData = createProductSchema.parse(input);

      // Convert inventoryUpdatedAt string to Date if provided
      const createData = {
        ...validatedData,
        inventoryUpdatedAt: validatedData.inventoryUpdatedAt
          ? new Date(validatedData.inventoryUpdatedAt)
          : null,
      };

      // Business logic: Ensure market stand exists before creating product
      // (This could be expanded with additional business rules)

      // Use repository to create product
      return await productRepository.create(createData);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      const errorData = handleDatabaseError(error, "Failed to create product", {
        name: input.name,
        userId: input.userId,
        marketStandId: input.marketStandId,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Update an existing product
   */
  async updateProduct(
    id: string,
    input: UpdateProductInput
  ): Promise<ProductWithMarketStandDTO> {
    try {
      // Validate ID and input
      const validatedId = productIdSchema.parse(id);
      const validatedData = updateProductSchema.parse(input);

      // Check if product exists
      const exists = await productRepository.exists(validatedId);
      if (!exists) {
        throw new Error(`Product with ID ${validatedId} not found`);
      }

      // Convert inventoryUpdatedAt string to Date if provided
      const updateData = {
        ...validatedData,
        inventoryUpdatedAt:
          validatedData.inventoryUpdatedAt !== undefined
            ? validatedData.inventoryUpdatedAt
              ? new Date(validatedData.inventoryUpdatedAt)
              : null
            : undefined,
      };

      // Use repository to update product
      return await productRepository.update(validatedId, updateData);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Validation error: ${error.errors.map(e => e.message).join(', ')}`);
      }

      if (error instanceof Error && error.message.includes('not found')) {
        throw error;
      }

      const errorData = handleDatabaseError(error, "Failed to update product", {
        productId: id,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Delete a product
   */
  async deleteProduct(id: string): Promise<void> {
    try {
      // Validate ID
      const validatedId = productIdSchema.parse(id);

      // Check if product exists
      const exists = await productRepository.exists(validatedId);
      if (!exists) {
        throw new Error(`Product with ID ${validatedId} not found`);
      }

      // Use repository to delete product
      await productRepository.delete(validatedId);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Invalid product ID: ${error.errors[0].message}`);
      }

      if (error instanceof Error && error.message.includes('not found')) {
        throw error;
      }

      const errorData = handleDatabaseError(error, "Failed to delete product", {
        productId: id,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Update product inventory
   */
  async updateProductInventory(
    id: string,
    inventory: number
  ): Promise<ProductWithMarketStandDTO> {
    try {
      // Validate ID and inventory
      const validatedId = productIdSchema.parse(id);

      if (inventory < 0) {
        throw new Error('Inventory cannot be negative');
      }

      // Check if product exists
      const exists = await productRepository.exists(validatedId);
      if (!exists) {
        throw new Error(`Product with ID ${validatedId} not found`);
      }

      // Use repository to update inventory
      return await productRepository.updateInventory(validatedId, inventory);
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(`Invalid product ID: ${error.errors[0].message}`);
      }

      if (error instanceof Error && (error.message.includes('not found') || error.message.includes('cannot be negative'))) {
        throw error;
      }

      const errorData = handleDatabaseError(error, "Failed to update inventory", {
        productId: id,
        inventory,
      });
      throw new Error(errorData.error);
    }
  }

  /**
   * Get products by user ID
   */
  async getProductsByUserId(
    userId: string,
    filters?: Omit<ProductQueryFilters, 'userId'>
  ): Promise<ProductWithMarketStandDTO[]> {
    try {
      return await productRepository.findMany({
        ...filters,
        userId,
      });
    } catch (error) {
      const errorData = handleDatabaseError(error, "Failed to fetch user products", {
        userId,
      });
      console.error('Error fetching user products:', errorData);
      return [];
    }
  }

  /**
   * Get products by market stand ID
   */
  async getProductsByMarketStandId(
    marketStandId: string,
    filters?: Omit<ProductQueryFilters, 'marketStandId'>
  ): Promise<ProductWithMarketStandDTO[]> {
    try {
      return await productRepository.findMany({
        ...filters,
        marketStandId,
      });
    } catch (error) {
      const errorData = handleDatabaseError(error, "Failed to fetch market stand products", {
        marketStandId,
      });
      console.error('Error fetching market stand products:', errorData);
      return [];
    }
  }

  /**
   * Check if user owns product
   */
  async checkProductOwnership(productId: string, userId: string): Promise<boolean> {
    try {
      const product = await productRepository.findByIdAndUserId(productId, userId);
      return product !== null;
    } catch (error) {
      console.error('Error checking product ownership:', error);
      return false;
    }
  }
}

// Export singleton instance
export const productService = new ProductService();
</file>

<file path="lib/utils/format.ts">
/**
 * Formatting utilities
 */

/**
 * Format price to USD currency
 */
export function formatPrice(price: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(price);
}

/**
 * Format date to locale string
 */
export function formatDate(date: Date | string, options?: Intl.DateTimeFormatOptions): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  return dateObj.toLocaleDateString('en-US', options);
}

/**
 * Format date to relative time (e.g., "2 hours ago")
 */
export function formatRelativeTime(date: Date | string): string {
  const dateObj = typeof date === 'string' ? new Date(date) : date;
  const now = new Date();
  const diffInMs = now.getTime() - dateObj.getTime();
  const diffInSeconds = Math.floor(diffInMs / 1000);
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  const diffInHours = Math.floor(diffInMinutes / 60);
  const diffInDays = Math.floor(diffInHours / 24);

  if (diffInSeconds < 60) {
    return 'just now';
  } else if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes === 1 ? '' : 's'} ago`;
  } else if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours === 1 ? '' : 's'} ago`;
  } else if (diffInDays < 30) {
    return `${diffInDays} day${diffInDays === 1 ? '' : 's'} ago`;
  } else {
    return formatDate(dateObj);
  }
}

/**
 * Format distance in kilometers to readable string
 */
export function formatDistance(distanceKm: number): string {
  if (distanceKm < 1) {
    return `${Math.round(distanceKm * 1000)}m away`;
  } else if (distanceKm < 10) {
    return `${distanceKm.toFixed(1)}km away`;
  } else {
    return `${Math.round(distanceKm)}km away`;
  }
}

/**
 * Format phone number
 */
export function formatPhoneNumber(phone: string): string {
  const cleaned = phone.replace(/\D/g, '');
  const match = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);
  if (match) {
    return `(${match[1]}) ${match[2]}-${match[3]}`;
  }
  return phone;
}

/**
 * Truncate text to specified length
 */
export function truncateText(text: string, maxLength: number, ellipsis = '...'): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength - ellipsis.length) + ellipsis;
}

/**
 * Format file size
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

/**
 * Capitalize first letter of string
 */
export function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Convert string to slug
 */
export function slugify(str: string): string {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
}
</file>

<file path="lib/utils/index.ts">
/**
 * Utility functions
 * Export all utilities from a single location
 */

export * from './format';
export * from './validation';

// Re-export cn from utils.ts if it exists
export { cn } from '../utils';

/**
 * Delay execution for specified milliseconds
 */
export function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Debounce function execution
 */
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;

  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };

    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle function execution
 */
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;

  return function executedFunction(...args: Parameters<T>) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * Check if value is empty
 */
export function isEmpty(value: unknown): boolean {
  if (value === null || value === undefined) return true;
  if (typeof value === 'string') return value.trim().length === 0;
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === 'object') return Object.keys(value).length === 0;
  return false;
}

/**
 * Generate random ID
 */
export function generateId(length = 8): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Group array items by key
 */
export function groupBy<T>(
  array: T[],
  key: keyof T | ((item: T) => string | number)
): Record<string, T[]> {
  return array.reduce((result, item) => {
    const groupKey = typeof key === 'function' ? key(item) : String(item[key]);
    if (!result[groupKey]) {
      result[groupKey] = [];
    }
    result[groupKey].push(item);
    return result;
  }, {} as Record<string, T[]>);
}

/**
 * Remove duplicates from array
 */
export function unique<T>(array: T[], key?: keyof T): T[] {
  if (!key) {
    return Array.from(new Set(array));
  }
  
  const seen = new Set();
  return array.filter((item) => {
    const k = item[key];
    if (seen.has(k)) {
      return false;
    }
    seen.add(k);
    return true;
  });
}

/**
 * Sort array of objects by key
 */
export function sortBy<T>(
  array: T[],
  key: keyof T,
  order: 'asc' | 'desc' = 'asc'
): T[] {
  return [...array].sort((a, b) => {
    const aVal = a[key];
    const bVal = b[key];
    
    if (aVal < bVal) return order === 'asc' ? -1 : 1;
    if (aVal > bVal) return order === 'asc' ? 1 : -1;
    return 0;
  });
}
</file>

<file path="lib/utils/validation.ts">
/**
 * Validation utilities
 */

/**
 * Validate email format
 */
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Validate phone number (US format)
 */
export function isValidPhoneNumber(phone: string): boolean {
  const phoneRegex = /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$/;
  return phoneRegex.test(phone);
}

/**
 * Validate URL format
 */
export function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validate password strength
 */
export function isValidPassword(password: string): {
  isValid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  if (password.length < 8) {
    errors.push('Password must be at least 8 characters long');
  }

  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }

  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }

  if (!/[0-9]/.test(password)) {
    errors.push('Password must contain at least one number');
  }

  if (!/[!@#$%^&*]/.test(password)) {
    errors.push('Password must contain at least one special character (!@#$%^&*)');
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

/**
 * Validate ZIP code (US format)
 */
export function isValidZipCode(zipCode: string): boolean {
  const zipRegex = /^\d{5}(-\d{4})?$/;
  return zipRegex.test(zipCode);
}

/**
 * Validate credit card number (Luhn algorithm)
 */
export function isValidCreditCard(cardNumber: string): boolean {
  const cleaned = cardNumber.replace(/\D/g, '');
  
  if (cleaned.length < 13 || cleaned.length > 19) {
    return false;
  }

  let sum = 0;
  let isEven = false;

  for (let i = cleaned.length - 1; i >= 0; i--) {
    let digit = parseInt(cleaned[i], 10);

    if (isEven) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }

    sum += digit;
    isEven = !isEven;
  }

  return sum % 10 === 0;
}

/**
 * Validate file type
 */
export function isValidFileType(
  file: File,
  allowedTypes: string[]
): boolean {
  return allowedTypes.includes(file.type);
}

/**
 * Validate file size
 */
export function isValidFileSize(
  file: File,
  maxSizeInMB: number
): boolean {
  const maxSizeInBytes = maxSizeInMB * 1024 * 1024;
  return file.size <= maxSizeInBytes;
}

/**
 * Validate required fields in an object
 */
export function validateRequiredFields<T extends Record<string, unknown>>(
  data: T,
  requiredFields: (keyof T)[]
): { isValid: boolean; missingFields: string[] } {
  const missingFields = requiredFields.filter(
    (field) => !data[field] || (typeof data[field] === 'string' && !(data[field] as string).trim())
  );

  return {
    isValid: missingFields.length === 0,
    missingFields: missingFields as string[],
  };
}

/**
 * Sanitize HTML to prevent XSS
 */
export function sanitizeHtml(html: string): string {
  const div = document.createElement('div');
  div.textContent = html;
  return div.innerHTML;
}

/**
 * Validate coordinates
 */
export function isValidCoordinates(
  latitude: number,
  longitude: number
): boolean {
  return (
    latitude >= -90 &&
    latitude <= 90 &&
    longitude >= -180 &&
    longitude <= 180
  );
}
</file>

<file path="lib/validators/marketStandSchemas.ts">
import { z } from "zod";
import { Status } from "@prisma/client";

// Weekly hours schema
const dayHoursSchema = z.object({
  open: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/).nullable(),
  close: z.string().regex(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/).nullable(),
  closed: z.boolean().default(false),
});

export const weeklyHoursSchema = z.object({
  monday: dayHoursSchema,
  tuesday: dayHoursSchema,
  wednesday: dayHoursSchema,
  thursday: dayHoursSchema,
  friday: dayHoursSchema,
  saturday: dayHoursSchema,
  sunday: dayHoursSchema,
});

// Market stand creation schema
export const createMarketStandSchema = z.object({
  userId: z.string().uuid("Invalid user ID"),
  name: z.string().min(1, "Market stand name is required").max(255),
  description: z.string().min(1, "Description is required"),
  locationName: z.string().min(1, "Location name is required").max(255),
  locationGuide: z.string().min(1, "Location guide is required"),
  latitude: z.number().min(-90).max(90),
  longitude: z.number().min(-180).max(180),
  website: z.string().url().nullable().optional(),
  images: z.array(z.string().url()).min(1, "At least one image is required"),
  tags: z.array(z.string()).default([]),
  socialMedia: z.array(z.string().url()).default([]),
  hours: weeklyHoursSchema,
  status: z.nativeEnum(Status).default(Status.PENDING),
  isActive: z.boolean().default(true),
});

// Market stand update schema - all fields optional except validation rules
export const updateMarketStandSchema = z.object({
  name: z.string().min(1).max(255).optional(),
  description: z.string().min(1).optional(),
  locationName: z.string().min(1).max(255).optional(),
  locationGuide: z.string().min(1).optional(),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  website: z.string().url().nullable().optional(),
  images: z.array(z.string().url()).min(1).optional(),
  tags: z.array(z.string()).optional(),
  socialMedia: z.array(z.string().url()).optional(),
  hours: weeklyHoursSchema.optional(),
  status: z.nativeEnum(Status).optional(),
  isActive: z.boolean().optional(),
});

// Market stand query schema
export const getMarketStandsQuerySchema = z.object({
  userId: z.string().uuid().optional(),
  limit: z.number().int().positive().max(100).default(50),
  cursor: z.string().optional(),
  isActive: z.boolean().default(true),
  latitude: z.number().min(-90).max(90).optional(),
  longitude: z.number().min(-180).max(180).optional(),
  radiusKm: z.number().positive().max(100).optional(),
});

// Market stand ID schema
export const marketStandIdSchema = z.string().uuid("Invalid market stand ID");

// Export types
export type CreateMarketStandInput = z.infer<typeof createMarketStandSchema>;
export type UpdateMarketStandInput = z.infer<typeof updateMarketStandSchema>;
export type GetMarketStandsQuery = z.infer<typeof getMarketStandsQuerySchema>;
export type WeeklyHours = z.infer<typeof weeklyHoursSchema>;
</file>

<file path="lib/validators/productSchemas.ts">
import { z } from "zod";
import { Status } from "@prisma/client";

// Product creation schema
export const createProductSchema = z.object({
  name: z.string().min(1, "Product name is required").max(100),
  description: z.string().min(1, "Description is required"),
  price: z.number().positive("Price must be positive"),
  images: z.array(z.string().url()).min(1, "At least one image is required"),
  inventory: z.number().int().min(0, "Inventory cannot be negative"),
  inventoryUpdatedAt: z.string().datetime().nullable().optional(),
  status: z.nativeEnum(Status).default(Status.PENDING),
  isActive: z.boolean().default(true),
  userId: z.string().uuid("Invalid user ID"),
  marketStandId: z.string().uuid("Invalid market stand ID"),
  tags: z.array(z.string()).default([]),
});

// Product update schema - all fields optional except validation rules
export const updateProductSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().min(1).optional(),
  price: z.number().positive().optional(),
  images: z.array(z.string().url()).min(1).optional(),
  inventory: z.number().int().min(0).optional(),
  inventoryUpdatedAt: z.string().datetime().nullable().optional(),
  status: z.nativeEnum(Status).optional(),
  isActive: z.boolean().optional(),
  tags: z.array(z.string()).optional(),
});

// Product query schema
export const getProductsQuerySchema = z.object({
  userId: z.string().uuid().optional(),
  marketStandId: z.string().uuid().optional(),
  limit: z.number().int().positive().max(100).default(50),
  cursor: z.string().optional(),
  isActive: z.boolean().default(true),
});

// Product ID schema
export const productIdSchema = z.string().uuid("Invalid product ID");

// Export types
export type CreateProductInput = z.infer<typeof createProductSchema>;
export type UpdateProductInput = z.infer<typeof updateProductSchema>;
export type GetProductsQuery = z.infer<typeof getProductsQuerySchema>;
</file>

<file path="lib/analytics.ts">
// Mock analytics implementation that doesn't use PostHog
// This prevents errors when PostHog is not properly configured

export type AnalyticsProperties = {
  [key: string]: any
}

// Create a logger function that only logs in development
const logAnalytics = (event: string, data?: any) => {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[Analytics] ${event}`, data || '');
  }
};

export const Analytics = {
  // User identification
  identify: (userId: string, properties?: AnalyticsProperties) => {
    logAnalytics('identify', { userId, ...properties });
  },

  // Reset user
  reset: () => {
    logAnalytics('reset');
  },

  // Business events
  businessCreated: (businessId: string, properties?: AnalyticsProperties) => {
    logAnalytics('business_created', { business_id: businessId, ...properties });
  },

  businessUpdated: (businessId: string, properties?: AnalyticsProperties) => {
    logAnalytics('business_updated', { business_id: businessId, ...properties });
  },

  // Product events
  productViewed: (productId: string, properties?: AnalyticsProperties) => {
    logAnalytics('product_viewed', { product_id: productId, ...properties });
  },

  productCreated: (productId: string, properties?: AnalyticsProperties) => {
    logAnalytics('product_created', { product_id: productId, ...properties });
  },

  productUpdated: (productId: string, properties?: AnalyticsProperties) => {
    logAnalytics('product_updated', { product_id: productId, ...properties });
  },

  // Order events
  orderStarted: (orderId: string, properties?: AnalyticsProperties) => {
    logAnalytics('order_started', { order_id: orderId, ...properties });
  },

  orderCompleted: (orderId: string, properties?: AnalyticsProperties) => {
    logAnalytics('order_completed', { order_id: orderId, ...properties });
  },

  // Cart events
  productAddedToCart: (productId: string, properties?: AnalyticsProperties) => {
    logAnalytics('product_added_to_cart', { product_id: productId, ...properties });
  },

  productRemovedFromCart: (productId: string, properties?: AnalyticsProperties) => {
    logAnalytics('product_removed_from_cart', { product_id: productId, ...properties });
  },

  // Search events
  searchPerformed: (query: string, properties?: AnalyticsProperties) => {
    logAnalytics('search_performed', { search_query: query, ...properties });
  },

  // Filter events
  filterApplied: (filterType: string, value: string, properties?: AnalyticsProperties) => {
    logAnalytics('filter_applied', { filter_type: filterType, filter_value: value, ...properties });
  },

  // Custom event
  track: (eventName: string, properties?: AnalyticsProperties) => {
    logAnalytics(eventName, properties);
  }
}
</file>

<file path="lib/auth.ts">
import { cookies } from 'next/headers';
import { createServerClient } from '@supabase/ssr';

export const createServerSupabaseClient = () => {
  const cookieStore = cookies();
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
};

export const getUser = async () => {
  const supabase = createServerSupabaseClient();
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error) {
    return null;
  }

  // Serialize user data to handle any non-serializable objects
  return user ? JSON.parse(JSON.stringify(user)) : null;
};
</file>

<file path="lib/CLEAN_ARCHITECTURE.md">
# Clean Architecture Implementation

This document describes the clean architecture pattern implementation in the Cornucopia application.

## Overview

The codebase has been refactored to follow clean architecture principles, separating concerns into distinct layers:

1. **Validators** - Input validation using Zod schemas
2. **DTOs** - Data Transfer Objects for type-safe data structures
3. **Repositories** - Data access layer abstracting database operations
4. **Services** - Business logic layer containing core application logic
5. **Server Actions** - Presentation layer interfacing with the frontend

## Architecture Layers

### 1. Validators (`lib/validators/`)

Validators define the input schemas using Zod for runtime type validation and type inference.

**Files:**
- `productSchemas.ts` - Product validation schemas
- `marketStandSchemas.ts` - Market stand validation schemas

**Example:**
```typescript
import { createProductSchema } from "@/lib/validators/productSchemas";

// Validate input
const validatedData = createProductSchema.parse(input);
```

**Key Features:**
- Runtime validation
- Type inference for TypeScript
- Clear error messages
- Reusable schemas for create/update/query operations

### 2. DTOs (`lib/dto/`)

Data Transfer Objects define the structure of data passed between layers.

**Files:**
- `product.dto.ts` - Product data structures
- `marketStand.dto.ts` - Market stand data structures

**Example:**
```typescript
import { ProductWithMarketStandDTO } from "@/lib/dto/product.dto";

function displayProduct(product: ProductWithMarketStandDTO) {
  // Type-safe access to product properties
}
```

**Key Features:**
- Type-safe data structures
- Separation from database models
- Clear interfaces for different use cases
- Backwards compatibility with existing code

### 3. Repositories (`lib/repositories/`)

Repositories handle all database operations, abstracting Prisma queries.

**Files:**
- `productRepository.ts` - Product data access
- `marketStandRepository.ts` - Market stand data access

**Example:**
```typescript
import { productRepository } from "@/lib/repositories/productRepository";

// Find products with filtering
const products = await productRepository.findMany({
  userId: "user-id",
  isActive: true,
  limit: 10
});

// Create a new product
const product = await productRepository.create(data);
```

**Key Features:**
- Single source of truth for database operations
- Consistent error handling
- Reusable query methods
- Automatic serialization of database models

**Available Methods:**

**ProductRepository:**
- `findMany(filters)` - Find products with filtering
- `findById(id)` - Find single product by ID
- `findByIdAndUserId(id, userId)` - Find product with ownership check
- `create(data)` - Create new product
- `update(id, data)` - Update existing product
- `delete(id)` - Delete product
- `exists(id)` - Check if product exists
- `count(filters)` - Count products
- `updateInventory(id, inventory)` - Update product inventory
- `bulkUpdateStatus(ids, status)` - Bulk update product status

**MarketStandRepository:**
- `findMany(filters)` - Find market stands with filtering
- `findByLocation(lat, lng, radius, filters)` - Find by location
- `findById(id)` - Find single market stand by ID
- `findByIdAndUserId(id, userId)` - Find with ownership check
- `create(data)` - Create new market stand
- `update(id, data)` - Update existing market stand
- `delete(id)` - Delete market stand
- `exists(id)` - Check if market stand exists
- `count(filters)` - Count market stands
- `updateStatus(id, status)` - Update market stand status
- `findByUserId(userId)` - Get all market stands for a user

### 4. Services (`lib/services/`)

Services contain business logic and use repositories for data access.

**Files:**
- `productService.ts` - Product business logic
- `marketStandService.ts` - Market stand business logic

**Example:**
```typescript
import { productService } from "@/lib/services/productService";

// Create product with validation
const product = await productService.createProduct({
  name: "Fresh Tomatoes",
  price: 5.99,
  // ... other fields
});

// Get products with automatic validation
const products = await productService.getProducts({
  marketStandId: "stand-id"
});
```

**Key Features:**
- Input validation using Zod schemas
- Business rule enforcement
- Error handling and logging
- Consistent API across different entities

**Available Methods:**

**ProductService:**
- `getProducts(query)` - Get products with filtering and validation
- `getProductById(id)` - Get single product with validation
- `createProduct(input)` - Create product with validation
- `updateProduct(id, input)` - Update product with validation
- `deleteProduct(id)` - Delete product
- `updateProductInventory(id, inventory)` - Update inventory
- `getProductsByUserId(userId, filters)` - Get user's products
- `getProductsByMarketStandId(standId, filters)` - Get stand's products
- `checkProductOwnership(productId, userId)` - Verify ownership

**MarketStandService:**
- `getMarketStands(query)` - Get market stands with filtering
- `getMarketStandById(id)` - Get single market stand
- `createMarketStand(input)` - Create market stand with validation
- `updateMarketStand(id, input)` - Update market stand with validation
- `deleteMarketStand(id)` - Delete market stand
- `getMarketStandsByUserId(userId, filters)` - Get user's stands
- `getMarketStandsNearLocation(lat, lng, radius)` - Location-based search
- `checkMarketStandOwnership(standId, userId)` - Verify ownership
- `countMarketStands(filters)` - Count market stands

### 5. Server Actions (`app/actions/`)

Server actions provide the interface between the frontend and the service layer.

**Files:**
- `products.ts` - Product server actions
- `market-stand.ts` - Market stand server actions

**Example:**
```typescript
import { getProducts, createProduct } from "@/app/actions/products";

// In a server component or server action
const products = await getProducts({ userId: "user-id" });

const newProduct = await createProduct({
  name: "Fresh Tomatoes",
  // ... other fields
});
```

**Key Features:**
- Thin wrapper around service layer
- Maintains existing API for backwards compatibility
- Clear documentation for each action
- Type-safe interfaces

## Data Flow

```
┌─────────────┐
│   Frontend  │
│  Component  │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Server    │
│   Action    │  (app/actions/)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Service   │  (lib/services/)
│   Layer     │  - Business Logic
│             │  - Validation (Zod)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Repository │  (lib/repositories/)
│   Layer     │  - Data Access
│             │  - Prisma Queries
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  Database   │
│  (Prisma)   │
└─────────────┘
```

## Benefits

### 1. Separation of Concerns
- Each layer has a single responsibility
- Easy to understand and maintain
- Clear boundaries between layers

### 2. Testability
- Services can be tested independently
- Repositories can be mocked for service tests
- Business logic isolated from data access

### 3. Reusability
- Services can be used across different server actions
- Repositories can be reused across services
- Validators ensure consistent validation

### 4. Type Safety
- DTOs provide clear type definitions
- Zod schemas provide runtime validation
- TypeScript ensures compile-time type checking

### 5. Maintainability
- Changes to business logic centralized in services
- Database changes isolated to repositories
- Validation rules centralized in schemas

## Usage Examples

### Creating a Product

```typescript
// In a server action or API route
import { productService } from "@/lib/services/productService";

try {
  const product = await productService.createProduct({
    name: "Fresh Tomatoes",
    description: "Organic heirloom tomatoes",
    price: 5.99,
    images: ["https://example.com/tomato.jpg"],
    inventory: 100,
    status: Status.PENDING,
    isActive: true,
    userId: "user-id",
    marketStandId: "stand-id",
    tags: ["organic", "vegetables"]
  });
  
  console.log("Product created:", product);
} catch (error) {
  // Validation errors or database errors are caught here
  console.error("Error creating product:", error.message);
}
```

### Querying Products

```typescript
import { productService } from "@/lib/services/productService";

// Get all active products for a market stand
const products = await productService.getProductsByMarketStandId(
  "stand-id",
  {
    isActive: true,
    limit: 20
  }
);

// Get products with location-based filtering
const standProducts = await productService.getProducts({
  marketStandId: "stand-id",
  isActive: true,
  limit: 50
});
```

### Updating a Product

```typescript
import { productService } from "@/lib/services/productService";

try {
  const updated = await productService.updateProduct(
    "product-id",
    {
      price: 6.99,
      inventory: 75
    }
  );
  
  console.log("Product updated:", updated);
} catch (error) {
  console.error("Error updating product:", error.message);
}
```

### Creating a Market Stand

```typescript
import { marketStandService } from "@/lib/services/marketStandService";

const marketStand = await marketStandService.createMarketStand({
  userId: "user-id",
  name: "Green Valley Farm Stand",
  description: "Fresh produce from our family farm",
  locationName: "123 Farm Road, Green Valley",
  locationGuide: "Next to the red barn",
  latitude: 37.7749,
  longitude: -122.4194,
  website: "https://greenvalley.farm",
  images: ["https://example.com/stand.jpg"],
  tags: ["organic", "local"],
  socialMedia: ["https://instagram.com/greenvalley"],
  hours: {
    monday: { open: "08:00", close: "17:00", closed: false },
    tuesday: { open: "08:00", close: "17:00", closed: false },
    // ... other days
  },
  status: Status.PENDING,
  isActive: true
});
```

### Location-Based Search

```typescript
import { marketStandService } from "@/lib/services/marketStandService";

// Find market stands within 10km of a location
const nearbyStands = await marketStandService.getMarketStandsNearLocation(
  37.7749,  // latitude
  -122.4194, // longitude
  10         // radius in kilometers
);
```

## Error Handling

The architecture includes comprehensive error handling:

1. **Validation Errors**: Zod validation errors are caught and returned with clear messages
2. **Database Errors**: Prisma errors are handled by the error handler utility
3. **Not Found Errors**: Custom errors for missing resources
4. **Business Logic Errors**: Service-level validation and business rules

Example error handling:
```typescript
try {
  const product = await productService.createProduct(data);
} catch (error) {
  if (error.message.includes('Validation error')) {
    // Handle validation error
  } else if (error.message.includes('not found')) {
    // Handle not found error
  } else {
    // Handle other errors
  }
}
```

## Migration Guide

### For Existing Code

The refactoring maintains backwards compatibility. Existing code using server actions will continue to work:

```typescript
// Old code still works
import { getProducts } from "@/app/actions/products";
const products = await getProducts({ userId: "user-id" });
```

### For New Features

When adding new features, follow this pattern:

1. **Create Validator Schema** (if needed)
2. **Define DTOs** (if needed)
3. **Add Repository Methods** (if new data access patterns needed)
4. **Implement Service Methods** (business logic)
5. **Create Server Actions** (thin wrapper)

## Best Practices

1. **Always validate input** at the service layer using Zod schemas
2. **Keep services focused** on business logic, not data access
3. **Use repositories** for all database operations
4. **Document service methods** with JSDoc comments
5. **Handle errors gracefully** at each layer
6. **Write tests** for services and repositories
7. **Use DTOs** for type safety across layers
8. **Keep server actions thin** - delegate to services

## Future Enhancements

Potential improvements to consider:

1. **Add caching layer** between services and repositories
2. **Implement event sourcing** for audit trails
3. **Add request/response interceptors** for logging
4. **Create integration tests** for the full stack
5. **Add GraphQL resolvers** using the service layer
6. **Implement webhook handlers** using services
7. **Add background job processing** using services

## Summary

This clean architecture implementation provides:
- ✅ Clear separation of concerns
- ✅ Improved testability
- ✅ Better maintainability
- ✅ Type safety throughout
- ✅ Reusable business logic
- ✅ Consistent error handling
- ✅ Backwards compatibility
- ✅ Scalable structure for future growth
</file>

<file path="lib/config.ts">
// Import env first to ensure it's loaded
import { env } from './env';

export const config = {
  database: {
    url: env.DATABASE_URL,
    directUrl: process.env.DIRECT_URL,
  },
  supabase: {
    url: env.SUPABASE_URL,
    anonKey: env.SUPABASE_ANON_KEY,
    jwtSecret: env.SUPABASE_JWT_SECRET,
  },
  app: {
    url: env.APP_URL,
  },
  env: env.NODE_ENV || 'development',
} as const;
</file>

<file path="lib/db.ts">
import { PrismaClient } from "@prisma/client";
import { logError } from "./logger";
import { env } from "./env";

declare global {
  var prisma: PrismaClient | undefined;
}

/**
 * Get Prisma Client with optimized connection pooling
 * Connection pool configuration for production:
 * - Pool size: 5-10 connections (adjustable based on load)
 * - Connection timeout: 20 seconds
 * - Query timeout: 15 seconds
 */
function getPrismaClient(): PrismaClient {
  console.log('Creating new Prisma client with DATABASE_URL:', env.DATABASE_URL.substring(0, 50) + '...');
  
  const isDevelopment = process.env.NODE_ENV !== 'production';
  
  return new PrismaClient({
    log: isDevelopment 
      ? ['query', 'error', 'warn', 'info']
      : ['error', 'warn'],
    datasources: {
      db: {
        url: env.DATABASE_URL,
      },
    },
  });
}

/**
 * Initialize Prisma Client with connection verification and metrics
 */
async function initializePrismaClient(client: PrismaClient): Promise<void> {
  try {
    console.log('Attempting to connect to database...');
    await client.$connect();
    console.log('Connected to database, verifying connection...');
    
    const result = await client.$queryRaw`SELECT current_database(), current_schema()`;
    console.log('Database connection verified:', result);
    
    // Enable query logging in development
    if (process.env.NODE_ENV !== 'production') {
      client.$on('query' as any, (e: any) => {
        console.log('Query: ' + e.query);
        console.log('Duration: ' + e.duration + 'ms');
      });
    }
  } catch (error) {
    console.error('Failed to initialize Prisma client:', error);
    throw error;
  }
}

// Create or reuse PrismaClient instance
const prisma = global.prisma ?? (() => {
  const client = getPrismaClient();

  // Initialize the client
  initializePrismaClient(client).catch(error => {
    logError('Failed to initialize Prisma client:', error);
  });

  return client;
})();

// Save client reference in development
if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

/**
 * Utility function to execute database operations with retry logic
 * Useful for handling temporary connection issues
 */
export async function executeWithRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3,
  delayMs = 1000
): Promise<T> {
  let lastError: Error | undefined;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      // Don't retry on certain errors
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('Unique constraint') || 
          errorMessage.includes('Foreign key constraint')) {
        throw error;
      }
      
      if (attempt === maxRetries) break;
      
      console.warn(`Database operation failed (attempt ${attempt}/${maxRetries}), retrying...`);
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, delayMs * attempt));
    }
  }
  
  throw lastError;
}

/**
 * Query performance monitoring wrapper
 * Logs slow queries and helps identify performance bottlenecks
 */
export async function monitoredQuery<T>(
  queryName: string,
  operation: () => Promise<T>,
  slowQueryThresholdMs: number = 1000
): Promise<T> {
  const startTime = Date.now();
  
  try {
    const result = await operation();
    const duration = Date.now() - startTime;
    
    if (duration > slowQueryThresholdMs) {
      console.warn(`[SLOW QUERY] ${queryName} took ${duration}ms`);
    } else if (process.env.NODE_ENV !== 'production') {
      console.log(`[QUERY] ${queryName} completed in ${duration}ms`);
    }
    
    return result;
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`[QUERY ERROR] ${queryName} failed after ${duration}ms:`, error);
    throw error;
  }
}

/**
 * Get database connection pool metrics
 */
export async function getConnectionMetrics() {
  try {
    const metrics = await prisma.$metrics.json();
    return metrics;
  } catch (error) {
    logError('Failed to get connection metrics:', error);
    return null;
  }
}

// Utility function to execute operations within a transaction
export async function withTransaction<T>(
  operation: (tx: Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use' | '$extends'>) => Promise<T>
): Promise<T> {
  return prisma.$transaction(async (tx) => {
    return operation(tx);
  });
}

export default prisma;
</file>

<file path="lib/error-handler.ts">
/**
 * Utility functions for consistent error handling across the application
 */

import { Prisma } from "@prisma/client";
import { logError } from "./logger";

/**
 * Standard error response format
 */
export interface ErrorResponse {
  error: string;
  code?: string;
  details?: Record<string, any>;
}

/**
 * Handle database errors consistently
 */
export function handleDatabaseError(
  error: unknown,
  context: string,
  metadata: Record<string, any> = {}
): ErrorResponse {
  // Log the error with context and metadata
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    logError(`${context} - Prisma known request error:`, {
      code: error.code,
      meta: error.meta,
      message: error.message,
      ...metadata
    });
    
    return {
      error: `Database operation failed: ${error.message}`,
      code: error.code,
      details: { ...metadata, meta: error.meta }
    };
  } 
  
  if (error instanceof Prisma.PrismaClientInitializationError) {
    logError(`${context} - Prisma initialization error:`, {
      message: error.message,
      clientVersion: error.clientVersion,
      ...metadata
    });
    
    return {
      error: 'Database connection error. Please try again later.',
      code: 'INITIALIZATION_ERROR',
      details: { ...metadata }
    };
  }
  
  if (error instanceof Prisma.PrismaClientValidationError) {
    logError(`${context} - Prisma validation error:`, {
      message: error.message,
      ...metadata
    });
    
    return {
      error: 'Invalid data provided for database operation.',
      code: 'VALIDATION_ERROR',
      details: { ...metadata }
    };
  }
  
  // Generic error handling
  logError(`${context} - Unknown error:`, {
    error,
    ...metadata
  });
  
  return {
    error: error instanceof Error ? error.message : 'An unexpected error occurred',
    details: { ...metadata }
  };
}

/**
 * Create a JSON response for an error
 */
export function createErrorResponse(
  errorResponse: ErrorResponse,
  status: number = 500
): Response {
  return Response.json(errorResponse, { status });
}

/**
 * Handle not found errors
 */
export function createNotFoundResponse(
  resourceType: string,
  id: string
): Response {
  return Response.json(
    { error: `${resourceType} not found`, resourceId: id },
    { status: 404 }
  );
}
</file>

<file path="lib/logger.ts">
// Utility function for logging errors
export const logError = (message: string, error?: unknown) => {
  // In development, log to console
  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line no-console
  }
  
  // In production, you could send to an error tracking service
  // if (process.env.NODE_ENV === 'production') {
  //   // Send to error tracking service
  // }
};
</file>

<file path="lib/rate-limit.ts">
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

// Create a new ratelimiter that allows 10 requests per 10 seconds by default
export const rateLimiter = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "10s"),
  analytics: true,
  prefix: "@upstash/ratelimit",
});

// Different rate limits for different routes
export const routeRateLimits = {
  // Market stand routes
  "/api/market-stand": { requests: 20, duration: "60s" },
  "/api/market-stand/[id]": { requests: 30, duration: "60s" },
  
  // Product routes
  "/api/product": { requests: 20, duration: "60s" },
  "/api/product/inventory": { requests: 30, duration: "60s" },
  
  // Auth routes - more permissive
  "/api/auth": { requests: 5, duration: "60s" }, // Stricter for auth attempts
  
  // Upload routes
  "/api/upload": { requests: 10, duration: "60s" },
  
  // Stripe routes
  "/api/stripe": { requests: 10, duration: "60s" },
  
  // Default rate limit for other routes
  default: { requests: 10, duration: "10s" }
} as const;

export async function getRateLimiter(identifier: string, route: string) {
  // Get the rate limit configuration for the route, or use default
  const config = routeRateLimits[route as keyof typeof routeRateLimits] || routeRateLimits.default;
  
  return new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(
      config.requests,
      config.duration
    ),
    analytics: true,
    prefix: `@upstash/ratelimit/${route}`,
  });
}
</file>

<file path="lib/serializers.ts">
/**
 * Serializers for converting Prisma models to plain objects
 * This helps avoid serialization issues and standardizes the format of data
 * returned from server actions
 */

import { MarketStand, Product } from "@prisma/client";

/**
 * Serialize a market stand to a plain object
 */
export function serializeMarketStand(marketStand: MarketStand & any): any {
  return {
    id: marketStand.id,
    name: marketStand.name,
    description: marketStand.description,
    locationName: marketStand.locationName,
    locationGuide: marketStand.locationGuide,
    latitude: marketStand.latitude,
    longitude: marketStand.longitude,
    website: marketStand.website,
    images: marketStand.images,
    tags: marketStand.tags,
    socialMedia: marketStand.socialMedia,
    hours: marketStand.hours,
    userId: marketStand.userId,
    createdAt: marketStand.createdAt.toISOString(),
    updatedAt: marketStand.updatedAt.toISOString(),
    // Include any additional fields that might be included via relations
    ...(marketStand.user ? { 
      user: {
        firstName: marketStand.user.firstName,
        lastName: marketStand.user.lastName,
        profileImage: marketStand.user.profileImage
      } 
    } : {}),
    ...(marketStand._count ? { _count: marketStand._count } : {}),
    ...(marketStand.products ? { 
      products: marketStand.products.map(serializeProduct)
    } : {})
  };
}

/**
 * Serialize a product to a plain object
 */
export function serializeProduct(product: Product & any): any {
  return {
    id: product.id,
    name: product.name,
    description: product.description,
    price: product.price,
    images: product.images,
    inventory: product.inventory,
    inventoryUpdatedAt: product.inventoryUpdatedAt?.toISOString() || null,
    status: product.status,
    isActive: product.isActive,
    userId: product.userId,
    marketStandId: product.marketStandId,
    createdAt: product.createdAt.toISOString(),
    updatedAt: product.updatedAt.toISOString(),
    totalReviews: product.totalReviews,
    averageRating: product.averageRating,
    tags: product.tags,
    // Include marketStand if it's loaded
    ...(product.marketStand ? {
      marketStand: {
        id: product.marketStand.id,
        name: product.marketStand.name,
        locationName: product.marketStand.locationName,
        latitude: product.marketStand.latitude,
        longitude: product.marketStand.longitude,
        ...(product.marketStand.user ? {
          user: {
            firstName: product.marketStand.user.firstName,
            profileImage: product.marketStand.user.profileImage
          }
        } : {})
      },
      locationName: product.marketStand.locationName
    } : {})
  };
}

/**
 * Serialize an array of products to plain objects
 */
export function serializeProducts(products: (Product & any)[]): any[] {
  return products.map(serializeProduct);
}

/**
 * Serialize an array of market stands to plain objects
 */
export function serializeMarketStands(marketStands: (MarketStand & any)[]): any[] {
  return marketStands.map(serializeMarketStand);
}
</file>

<file path="lib/stripe.ts">
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY is not set in environment variables");
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-12-18.acacia", // API version for Stripe v17
  typescript: true,
});
</file>

<file path="lib/supabase-browser.ts">
'use client';

import { createBrowserClient } from '@supabase/ssr';

// Singleton instance for client-side
let clientInstance: ReturnType<typeof createBrowserClient> | null = null;

export function getSupabaseBrowser() {
  if (!clientInstance) {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Missing Supabase environment variables');
    }

    // Create client with default options
    clientInstance = createBrowserClient(supabaseUrl, supabaseKey);

    // Initialize auth state - no automatic reload to prevent loops
    clientInstance.auth.onAuthStateChange(() => {
      // Let SupabaseProvider handle auth state changes
      // This prevents the reload loop issue
    });
  }
  return clientInstance;
}

// Helper function for uploading images
export async function uploadImage(
  file: File,
  bucket: string = 'products',
  path: string = ''
): Promise<string> {
  try {
    const supabase = getSupabaseBrowser();
    
    // Check if user is authenticated
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      throw new Error('Authentication required for image upload');
    }

    // Include user ID in the path to prevent conflicts
    const fileName = `${session.user.id}/${path}${Date.now()}-${file.name}`;

    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(fileName, file, {
        cacheControl: '3600',
        upsert: false,
      });

    if (error) {
      throw error;
    }

    const { data: urlData } = await supabase.storage
      .from(bucket)
      .getPublicUrl(data.path);

    if (!urlData.publicUrl) {
      throw new Error('Failed to get public URL');
    }

    return urlData.publicUrl;
  } catch (error) {
     throw error;
  }
}

// Helper function for deleting images
export async function deleteImage(
  url: string,
  bucket: string = 'products'
): Promise<void> {
  const supabase = getSupabaseBrowser();
  
  // Extract file path from URL
  const path = url.split(`${bucket}/`)[1];
  if (!path) throw new Error('Invalid image URL');

  const { error } = await supabase.storage
    .from(bucket)
    .remove([path]);

  if (error) {
    throw error;
  }
}

// Helper function for uploading multiple images
export async function uploadImages(
  files: File[],
  bucket: string = 'products',
  path: string = ''
): Promise<string[]> {
  try {
    const uploadPromises = files.map(file => uploadImage(file, bucket, path));
    const results = await Promise.allSettled(uploadPromises);
    
    // Filter out rejected promises and return successful uploads
    const successfulUploads = results
      .filter((result): result is PromiseFulfilledResult<string> => result.status === 'fulfilled')
      .map(result => result.value);
    
    // Log errors for failed uploads
    results
      .filter((result): result is PromiseRejectedResult => result.status === 'rejected')
      .forEach(result => {
        console.error('Image upload failed:', result.reason);
      });
    
    if (successfulUploads.length === 0 && files.length > 0) {
      throw new Error('All image uploads failed');
    }
    
    return successfulUploads;
  } catch (error) {
    console.error('Error in uploadImages:', error);
    throw error;
  }
}
</file>

<file path="lib/supabase-config.ts">
import { env } from './env';  // Import env directly

export interface SupabaseConfig {
  supabaseUrl: string;
  supabaseKey: string;
  redirectUrl: string;
}

export const getSupabaseConfig = (): SupabaseConfig => {
  return {
    supabaseUrl: env.SUPABASE_URL,
    supabaseKey: env.SUPABASE_ANON_KEY,
    redirectUrl: `${env.APP_URL}/dashboard`,
  };
};

export const getAuthRedirectUrl = (path: string = '/'): string => {
  // Ensure path starts with a slash
  const normalizedPath = path.startsWith('/') ? path : `/${path}`;
  return `${env.APP_URL}${normalizedPath}`;
};
</file>

<file path="lib/supabase-route.ts">
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createRouteHandlerClient() {
  const cookieStore = cookies();
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Route Handler.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}
</file>

<file path="lib/supabase-server.ts">
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { cache } from 'react';

// Singleton instance for server-side
export const getSupabaseServer = cache(() => {
  const cookieStore = cookies();
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
});
</file>

<file path="lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="nextjs/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="nextjs/app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({
  subsets: ["latin"],
  display: 'swap',
  variable: '--font-inter',
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${inter.variable} antialiased`}>
        {children}
      </body>
    </html>
  );
}
</file>

<file path="nextjs/app/page.tsx">
import Image from "next/image";

export default function Home() {
  return (
    <div className="grid grid-rows-[20px_1fr_20px] items-center justify-items-center min-h-screen p-8 pb-20 gap-16 sm:p-20 font-[family-name:var(--font-geist-sans)]">
      <main className="flex flex-col gap-8 row-start-2 items-center sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol className="list-inside list-decimal text-sm text-center sm:text-left font-[family-name:var(--font-geist-mono)]">
          <li className="mb-2">
            Get started by editing{" "}
            <code className="bg-black/[.05] dark:bg-white/[.06] px-1 py-0.5 rounded font-semibold">
              app/page.tsx
            </code>
            .
          </li>
          <li>Save and see your changes instantly.</li>
        </ol>

        <div className="flex gap-4 items-center flex-col sm:flex-row">
          <a
            className="rounded-full border border-solid border-transparent transition-colors flex items-center justify-center bg-foreground text-background gap-2 hover:bg-[#383838] dark:hover:bg-[#ccc] text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            className="rounded-full border border-solid border-black/[.08] dark:border-white/[.145] transition-colors flex items-center justify-center hover:bg-[#f2f2f2] dark:hover:bg-[#1a1a1a] hover:border-transparent text-sm sm:text-base h-10 sm:h-12 px-4 sm:px-5 sm:min-w-44"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className="row-start-3 flex gap-6 flex-wrap items-center justify-center">
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          className="flex items-center gap-2 hover:underline hover:underline-offset-4"
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org →
        </a>
      </footer>
    </div>
  );
}
</file>

<file path="nextjs/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="nextjs/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="nextjs/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="nextjs/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="nextjs/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="nextjs/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="nextjs/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="nextjs/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="nextjs/package.json">
{
  "name": "nextjs",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.1.5"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "eslint": "^9",
    "eslint-config-next": "15.1.5",
    "@eslint/eslintrc": "^3"
  }
}
</file>

<file path="nextjs/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="nextjs/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="nextjs/tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;
</file>

<file path="nextjs/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="prisma/migrations/20250106_optimize_indexes/migration.sql">
-- Add composite indexes for optimized query performance
-- These indexes target common query patterns identified during the performance audit

-- Product composite indexes for frequently used filter combinations
CREATE INDEX IF NOT EXISTS "product_status_active_idx" ON "Product"("status", "isActive", "createdAt" DESC);
CREATE INDEX IF NOT EXISTS "product_stand_status_idx" ON "Product"("marketStandId", "status", "isActive");
CREATE INDEX IF NOT EXISTS "product_user_status_idx" ON "Product"("userId", "status", "isActive");

-- Market stand composite indexes for location and status queries
CREATE INDEX IF NOT EXISTS "market_stand_status_active_idx" ON "MarketStand"("status", "isActive", "createdAt" DESC);
CREATE INDEX IF NOT EXISTS "market_stand_location_active_idx" ON "MarketStand"("isActive", "latitude", "longitude");

-- Review indexes for filtering visible reviews and sorting
CREATE INDEX IF NOT EXISTS "product_review_visible_created_idx" ON "ProductReview"("isVisible", "createdAt" DESC);
CREATE INDEX IF NOT EXISTS "stand_review_visible_created_idx" ON "StandReview"("isVisible", "createdAt" DESC);

-- User engagement indexes for analytics queries
CREATE INDEX IF NOT EXISTS "user_engagement_last_visit_idx" ON "UserEngagement"("lastVisit" DESC);

-- Session indexes for analytics
CREATE INDEX IF NOT EXISTS "visitor_session_start_idx" ON "VisitorSession"("startTime" DESC);

-- Metrics indexes for analytics queries
CREATE INDEX IF NOT EXISTS "product_metrics_revenue_idx" ON "ProductMetrics"("revenue" DESC);
CREATE INDEX IF NOT EXISTS "stand_metrics_revenue_idx" ON "StandMetrics"("totalRevenue" DESC);

-- Daily metrics indexes for date-based queries
CREATE INDEX IF NOT EXISTS "product_daily_date_idx" ON "ProductDailyMetrics"("date" DESC);
CREATE INDEX IF NOT EXISTS "stand_daily_date_idx" ON "StandDailyMetrics"("date" DESC);
</file>

<file path="prisma/migrations/20250206152338_init/migration.sql">
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'SUPER_ADMIN');

-- CreateEnum
CREATE TYPE "Status" AS ENUM ('PENDING', 'APPROVED', 'REJECTED', 'SUSPENDED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" VARCHAR(255) NOT NULL,
    "firstName" VARCHAR(100) NOT NULL,
    "lastName" VARCHAR(100) NOT NULL,
    "profileImage" TEXT NOT NULL,
    "connectedAccountId" VARCHAR(100),
    "stripeConnectedLinked" BOOLEAN NOT NULL DEFAULT false,
    "role" "UserRole" NOT NULL DEFAULT 'USER',

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MarketStand" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "description" TEXT,
    "images" TEXT[],
    "tags" VARCHAR(50)[],
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,
    "locationName" VARCHAR(255) NOT NULL,
    "locationGuide" TEXT NOT NULL,
    "website" TEXT,
    "socialMedia" TEXT[],
    "status" "Status" NOT NULL DEFAULT 'PENDING',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,
    "averageRating" DOUBLE PRECISION,
    "totalReviews" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "MarketStand_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "price" INTEGER NOT NULL,
    "description" TEXT NOT NULL,
    "images" TEXT[],
    "tags" VARCHAR(50)[],
    "inventory" INTEGER NOT NULL DEFAULT 0,
    "inventoryUpdatedAt" TIMESTAMP(3),
    "status" "Status" NOT NULL DEFAULT 'PENDING',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "localId" TEXT,
    "averageRating" DOUBLE PRECISION,
    "totalReviews" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductReview" (
    "id" TEXT NOT NULL,
    "rating" SMALLINT NOT NULL,
    "comment" TEXT NOT NULL,
    "images" TEXT[],
    "isVerifiedPurchase" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "productId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "helpfulVotes" INTEGER NOT NULL DEFAULT 0,
    "reportCount" INTEGER NOT NULL DEFAULT 0,
    "isVisible" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "ProductReview_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandReview" (
    "id" TEXT NOT NULL,
    "rating" SMALLINT NOT NULL,
    "comment" TEXT NOT NULL,
    "images" TEXT[],
    "isVerifiedCustomer" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "helpfulVotes" INTEGER NOT NULL DEFAULT 0,
    "reportCount" INTEGER NOT NULL DEFAULT 0,
    "isVisible" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "StandReview_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductStatusHistory" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "oldStatus" "Status" NOT NULL,
    "newStatus" "Status" NOT NULL,
    "changedById" TEXT NOT NULL,
    "note" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ProductStatusHistory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandStatusHistory" (
    "id" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "oldStatus" "Status" NOT NULL,
    "newStatus" "Status" NOT NULL,
    "changedById" TEXT NOT NULL,
    "note" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "StandStatusHistory_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductMetrics" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "addedToCart" INTEGER NOT NULL DEFAULT 0,
    "purchases" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,
    "conversionRate" DOUBLE PRECISION,

    CONSTRAINT "ProductMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductDailyMetrics" (
    "id" TEXT NOT NULL,
    "productMetricId" TEXT NOT NULL,
    "date" DATE NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "addedToCart" INTEGER NOT NULL DEFAULT 0,
    "purchases" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "ProductDailyMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandMetrics" (
    "id" TEXT NOT NULL,
    "marketStandId" TEXT NOT NULL,
    "totalViews" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "totalOrders" INTEGER NOT NULL DEFAULT 0,
    "totalRevenue" INTEGER NOT NULL DEFAULT 0,
    "averageOrderValue" DOUBLE PRECISION,
    "returningCustomers" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "StandMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StandDailyMetrics" (
    "id" TEXT NOT NULL,
    "standMetricId" TEXT NOT NULL,
    "date" DATE NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "orders" INTEGER NOT NULL DEFAULT 0,
    "revenue" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "StandDailyMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserEngagement" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "lastVisit" TIMESTAMP(3) NOT NULL,
    "totalVisits" INTEGER NOT NULL DEFAULT 0,
    "totalPurchases" INTEGER NOT NULL DEFAULT 0,
    "totalSpent" INTEGER NOT NULL DEFAULT 0,
    "favoriteStands" TEXT[],
    "searchHistory" TEXT[],
    "categoryViews" JSONB NOT NULL,

    CONSTRAINT "UserEngagement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "VisitorSession" (
    "id" TEXT NOT NULL,
    "sessionId" TEXT NOT NULL,
    "userId" TEXT,
    "startTime" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "endTime" TIMESTAMP(3),
    "deviceType" VARCHAR(50),
    "browser" VARCHAR(50),
    "ipAddress" VARCHAR(45),
    "pagesViewed" JSONB NOT NULL,

    CONSTRAINT "VisitorSession_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Local" (
    "id" TEXT NOT NULL,
    "name" VARCHAR(255) NOT NULL,
    "description" TEXT NOT NULL,
    "story" TEXT NOT NULL,
    "images" TEXT[],
    "farmingPractices" TEXT NOT NULL,
    "teamMembers" JSONB NOT NULL,
    "certifications" JSONB NOT NULL,
    "seasonalSchedule" JSONB NOT NULL,
    "events" JSONB NOT NULL,
    "operatingHours" JSONB NOT NULL,
    "wholesaleInfo" TEXT,
    "contactForm" BOOLEAN NOT NULL DEFAULT true,
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,
    "locationName" VARCHAR(255) NOT NULL,
    "locationGuide" TEXT NOT NULL,
    "website" TEXT,
    "socialMedia" TEXT[],
    "status" "Status" NOT NULL DEFAULT 'PENDING',
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "Local_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "LocalMetrics" (
    "id" TEXT NOT NULL,
    "localId" TEXT NOT NULL,
    "views" INTEGER NOT NULL DEFAULT 0,
    "uniqueViews" INTEGER NOT NULL DEFAULT 0,
    "contactFormSubmissions" INTEGER NOT NULL DEFAULT 0,
    "productViews" INTEGER NOT NULL DEFAULT 0,
    "eventSignups" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "LocalMetrics_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_id_key" ON "User"("id");

-- CreateIndex
CREATE INDEX "user_email_idx" ON "User"("email");

-- CreateIndex
CREATE INDEX "user_stripe_idx" ON "User"("connectedAccountId");

-- CreateIndex
CREATE INDEX "market_stand_location_idx" ON "MarketStand"("latitude", "longitude");

-- CreateIndex
CREATE INDEX "market_stand_active_idx" ON "MarketStand"("isActive");

-- CreateIndex
CREATE INDEX "MarketStand_userId_idx" ON "MarketStand"("userId");

-- CreateIndex
CREATE INDEX "product_active_inventory_idx" ON "Product"("isActive", "inventory");

-- CreateIndex
CREATE INDEX "product_updated_at_idx" ON "Product"("updatedAt" DESC);

-- CreateIndex
CREATE INDEX "product_market_stand_idx" ON "Product"("marketStandId");

-- CreateIndex
CREATE INDEX "product_local_idx" ON "Product"("localId");

-- CreateIndex
CREATE INDEX "product_user_idx" ON "Product"("userId");

-- CreateIndex
CREATE INDEX "product_review_product_idx" ON "ProductReview"("productId", "isVisible");

-- CreateIndex
CREATE INDEX "ProductReview_userId_idx" ON "ProductReview"("userId");

-- CreateIndex
CREATE INDEX "stand_review_stand_idx" ON "StandReview"("marketStandId", "isVisible");

-- CreateIndex
CREATE INDEX "StandReview_userId_idx" ON "StandReview"("userId");

-- CreateIndex
CREATE INDEX "ProductStatusHistory_productId_idx" ON "ProductStatusHistory"("productId");

-- CreateIndex
CREATE INDEX "ProductStatusHistory_changedById_idx" ON "ProductStatusHistory"("changedById");

-- CreateIndex
CREATE INDEX "StandStatusHistory_marketStandId_idx" ON "StandStatusHistory"("marketStandId");

-- CreateIndex
CREATE INDEX "StandStatusHistory_changedById_idx" ON "StandStatusHistory"("changedById");

-- CreateIndex
CREATE UNIQUE INDEX "ProductMetrics_productId_key" ON "ProductMetrics"("productId");

-- CreateIndex
CREATE INDEX "product_metrics_product_idx" ON "ProductMetrics"("productId");

-- CreateIndex
CREATE INDEX "ProductDailyMetrics_productMetricId_date_idx" ON "ProductDailyMetrics"("productMetricId", "date");

-- CreateIndex
CREATE UNIQUE INDEX "StandMetrics_marketStandId_key" ON "StandMetrics"("marketStandId");

-- CreateIndex
CREATE INDEX "stand_metrics_stand_idx" ON "StandMetrics"("marketStandId");

-- CreateIndex
CREATE INDEX "StandDailyMetrics_standMetricId_date_idx" ON "StandDailyMetrics"("standMetricId", "date");

-- CreateIndex
CREATE UNIQUE INDEX "UserEngagement_userId_key" ON "UserEngagement"("userId");

-- CreateIndex
CREATE INDEX "UserEngagement_userId_idx" ON "UserEngagement"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "VisitorSession_sessionId_key" ON "VisitorSession"("sessionId");

-- CreateIndex
CREATE INDEX "VisitorSession_userId_idx" ON "VisitorSession"("userId");

-- CreateIndex
CREATE INDEX "VisitorSession_sessionId_idx" ON "VisitorSession"("sessionId");

-- CreateIndex
CREATE INDEX "local_location_idx" ON "Local"("latitude", "longitude");

-- CreateIndex
CREATE INDEX "local_active_idx" ON "Local"("isActive");

-- CreateIndex
CREATE INDEX "local_user_idx" ON "Local"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "LocalMetrics_localId_key" ON "LocalMetrics"("localId");

-- CreateIndex
CREATE INDEX "local_metrics_local_idx" ON "LocalMetrics"("localId");

-- AddForeignKey
ALTER TABLE "MarketStand" ADD CONSTRAINT "MarketStand_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_localId_fkey" FOREIGN KEY ("localId") REFERENCES "Local"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductReview" ADD CONSTRAINT "ProductReview_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductReview" ADD CONSTRAINT "ProductReview_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandReview" ADD CONSTRAINT "StandReview_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandReview" ADD CONSTRAINT "StandReview_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductStatusHistory" ADD CONSTRAINT "ProductStatusHistory_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductStatusHistory" ADD CONSTRAINT "ProductStatusHistory_changedById_fkey" FOREIGN KEY ("changedById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandStatusHistory" ADD CONSTRAINT "StandStatusHistory_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandStatusHistory" ADD CONSTRAINT "StandStatusHistory_changedById_fkey" FOREIGN KEY ("changedById") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductMetrics" ADD CONSTRAINT "ProductMetrics_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductDailyMetrics" ADD CONSTRAINT "ProductDailyMetrics_productMetricId_fkey" FOREIGN KEY ("productMetricId") REFERENCES "ProductMetrics"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandMetrics" ADD CONSTRAINT "StandMetrics_marketStandId_fkey" FOREIGN KEY ("marketStandId") REFERENCES "MarketStand"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StandDailyMetrics" ADD CONSTRAINT "StandDailyMetrics_standMetricId_fkey" FOREIGN KEY ("standMetricId") REFERENCES "StandMetrics"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserEngagement" ADD CONSTRAINT "UserEngagement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "VisitorSession" ADD CONSTRAINT "VisitorSession_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Local" ADD CONSTRAINT "Local_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "LocalMetrics" ADD CONSTRAINT "LocalMetrics_localId_fkey" FOREIGN KEY ("localId") REFERENCES "Local"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250211020323_add_market_stand_hours/migration.sql">
-- AlterTable
ALTER TABLE "MarketStand" ADD COLUMN     "hours" JSONB;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="prisma/schema.prisma">
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres", "metrics", "postgresqlExtensions", "relationJoins"]
  engineType      = "binary"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "foreignKeys"
  extensions   = [uuid_ossp(map: "uuid-ossp", schema: "extensions")]
}

model User {
  id                    String                 @id @unique
  email                 String                 @db.VarChar(255)
  firstName             String                 @db.VarChar(100)
  lastName              String                 @db.VarChar(100)
  profileImage          String
  connectedAccountId    String?                @db.VarChar(100)
  stripeConnectedLinked Boolean                @default(false)
  role                  UserRole               @default(USER)
  locals                Local[]
  marketStands          MarketStand[]
  products              Product[]
  productReviews        ProductReview[]
  productStatusChanges  ProductStatusHistory[]
  standReviews          StandReview[]
  standStatusChanges    StandStatusHistory[]
  engagement            UserEngagement?
  sessions              VisitorSession[]

  @@index([email], map: "user_email_idx")
  @@index([connectedAccountId], map: "user_stripe_idx")
}

model MarketStand {
  id            String               @id @default(uuid())
  name          String               @db.VarChar(255)
  description   String?
  images        String[]
  tags          String[]             @db.VarChar(50)
  latitude      Float
  longitude     Float
  locationName  String               @db.VarChar(255)
  locationGuide String
  website       String?
  socialMedia   String[]
  status        Status               @default(PENDING)
  isActive      Boolean              @default(true)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  userId        String
  averageRating Float?
  totalReviews  Int                  @default(0)
  hours         Json?
  user          User                 @relation(fields: [userId], references: [id])
  products      Product[]            @relation("ProductToMarketStand")
  metrics       StandMetrics?
  reviews       StandReview[]
  statusHistory StandStatusHistory[]

  @@index([latitude, longitude], map: "market_stand_location_idx")
  @@index([isActive], map: "market_stand_active_idx")
  @@index([userId])
}

model Product {
  id                 String                 @id @default(uuid())
  name               String                 @db.VarChar(255)
  price              Int
  description        String
  images             String[]
  tags               String[]               @db.VarChar(50)
  inventory          Int                    @default(0)
  inventoryUpdatedAt DateTime?
  status             Status                 @default(PENDING)
  isActive           Boolean                @default(true)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  userId             String
  marketStandId      String
  localId            String?
  averageRating      Float?
  totalReviews       Int                    @default(0)
  local              Local?                 @relation("ProductToLocal", fields: [localId], references: [id])
  marketStand        MarketStand            @relation("ProductToMarketStand", fields: [marketStandId], references: [id])
  user               User                   @relation(fields: [userId], references: [id])
  metrics            ProductMetrics?
  reviews            ProductReview[]
  statusHistory      ProductStatusHistory[]

  @@index([isActive, inventory], map: "product_active_inventory_idx")
  @@index([updatedAt(sort: Desc)], map: "product_updated_at_idx")
  @@index([marketStandId], map: "product_market_stand_idx")
  @@index([localId], map: "product_local_idx")
  @@index([userId], map: "product_user_idx")
}

model ProductReview {
  id                 String   @id @default(uuid())
  rating             Int      @db.SmallInt
  comment            String
  images             String[]
  isVerifiedPurchase Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  productId          String
  userId             String
  helpfulVotes       Int      @default(0)
  reportCount        Int      @default(0)
  isVisible          Boolean  @default(true)
  product            Product  @relation(fields: [productId], references: [id])
  user               User     @relation(fields: [userId], references: [id])

  @@index([productId, isVisible], map: "product_review_product_idx")
  @@index([userId])
}

model StandReview {
  id                 String      @id @default(uuid())
  rating             Int         @db.SmallInt
  comment            String
  images             String[]
  isVerifiedCustomer Boolean     @default(false)
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  marketStandId      String
  userId             String
  helpfulVotes       Int         @default(0)
  reportCount        Int         @default(0)
  isVisible          Boolean     @default(true)
  marketStand        MarketStand @relation(fields: [marketStandId], references: [id])
  user               User        @relation(fields: [userId], references: [id])

  @@index([marketStandId, isVisible], map: "stand_review_stand_idx")
  @@index([userId])
}

model ProductStatusHistory {
  id          String   @id @default(uuid())
  productId   String
  oldStatus   Status
  newStatus   Status
  changedById String
  note        String
  createdAt   DateTime @default(now())
  changedBy   User     @relation(fields: [changedById], references: [id])
  product     Product  @relation(fields: [productId], references: [id])

  @@index([productId])
  @@index([changedById])
}

model StandStatusHistory {
  id            String      @id @default(uuid())
  marketStandId String
  oldStatus     Status
  newStatus     Status
  changedById   String
  note          String
  createdAt     DateTime    @default(now())
  changedBy     User        @relation(fields: [changedById], references: [id])
  marketStand   MarketStand @relation(fields: [marketStandId], references: [id])

  @@index([marketStandId])
  @@index([changedById])
}

model ProductMetrics {
  id             String                @id @default(uuid())
  productId      String                @unique
  views          Int                   @default(0)
  uniqueViews    Int                   @default(0)
  addedToCart    Int                   @default(0)
  purchases      Int                   @default(0)
  revenue        Int                   @default(0)
  conversionRate Float?
  dailyMetrics   ProductDailyMetrics[]
  product        Product               @relation(fields: [productId], references: [id])

  @@index([productId], map: "product_metrics_product_idx")
}

model ProductDailyMetrics {
  id              String         @id @default(uuid())
  productMetricId String
  date            DateTime       @db.Date
  views           Int            @default(0)
  uniqueViews     Int            @default(0)
  addedToCart     Int            @default(0)
  purchases       Int            @default(0)
  revenue         Int            @default(0)
  productMetrics  ProductMetrics @relation(fields: [productMetricId], references: [id])

  @@index([productMetricId, date])
}

model StandMetrics {
  id                 String              @id @default(uuid())
  marketStandId      String              @unique
  totalViews         Int                 @default(0)
  uniqueViews        Int                 @default(0)
  totalOrders        Int                 @default(0)
  totalRevenue       Int                 @default(0)
  averageOrderValue  Float?
  returningCustomers Int                 @default(0)
  dailyMetrics       StandDailyMetrics[]
  marketStand        MarketStand         @relation(fields: [marketStandId], references: [id])

  @@index([marketStandId], map: "stand_metrics_stand_idx")
}

model StandDailyMetrics {
  id            String       @id @default(uuid())
  standMetricId String
  date          DateTime     @db.Date
  views         Int          @default(0)
  uniqueViews   Int          @default(0)
  orders        Int          @default(0)
  revenue       Int          @default(0)
  standMetrics  StandMetrics @relation(fields: [standMetricId], references: [id])

  @@index([standMetricId, date])
}

model UserEngagement {
  id             String   @id @default(uuid())
  userId         String   @unique
  lastVisit      DateTime
  totalVisits    Int      @default(0)
  totalPurchases Int      @default(0)
  totalSpent     Int      @default(0)
  favoriteStands String[]
  searchHistory  String[]
  categoryViews  Json
  user           User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model VisitorSession {
  id          String    @id @default(uuid())
  sessionId   String    @unique
  userId      String?
  startTime   DateTime  @default(now())
  endTime     DateTime?
  deviceType  String?   @db.VarChar(50)
  browser     String?   @db.VarChar(50)
  ipAddress   String?   @db.VarChar(45)
  pagesViewed Json
  user        User?     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([sessionId])
}

model Local {
  id               String        @id @default(uuid())
  name             String        @db.VarChar(255)
  description      String
  story            String
  images           String[]
  farmingPractices String
  teamMembers      Json
  certifications   Json
  seasonalSchedule Json
  events           Json
  operatingHours   Json
  wholesaleInfo    String?
  contactForm      Boolean       @default(true)
  latitude         Float
  longitude        Float
  locationName     String        @db.VarChar(255)
  locationGuide    String
  website          String?
  socialMedia      String[]
  status           Status        @default(PENDING)
  isActive         Boolean       @default(true)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  userId           String
  user             User          @relation(fields: [userId], references: [id])
  metrics          LocalMetrics?
  products         Product[]     @relation("ProductToLocal")

  @@index([latitude, longitude], map: "local_location_idx")
  @@index([isActive], map: "local_active_idx")
  @@index([userId], map: "local_user_idx")
}

model LocalMetrics {
  id                     String @id @default(uuid())
  localId                String @unique
  views                  Int    @default(0)
  uniqueViews            Int    @default(0)
  contactFormSubmissions Int    @default(0)
  productViews           Int    @default(0)
  eventSignups           Int    @default(0)
  local                  Local  @relation(fields: [localId], references: [id])

  @@index([localId], map: "local_metrics_local_idx")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum Status {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}
</file>

<file path="public/logos/cornucopia-dark.svg">
<svg width="400" height="100" viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Wave line -->
  <path 
    d="M20 40 Q100 40, 150 20, 200 30, 250 20, 300 30, 350 20, 380 30" 
    stroke="#ffffff" 
    stroke-width="8" 
    stroke-linecap="round"
    fill="none"
  />
  
  <!-- Text with better positioning -->
  <text 
    x="20" 
    y="85" 
    font-family="Arial" 
    font-size="48" 
    font-weight="bold" 
    fill="#ffffff"
    letter-spacing="2"
  >
    CORNUCOPIA
  </text>
</svg>
</file>

<file path="public/logos/cornucopia-mountain-tree.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
  <!-- Background circle -->
  <circle cx="16" cy="16" r="16" fill="white"/>
  
  <!-- Mountain peak -->
  <path d="M4 24 L16 8 L28 24" 
        fill="none" 
        stroke="#008000" 
        stroke-width="2.5"
        stroke-linecap="round"
        stroke-linejoin="round"/>
  
  <!-- Fir tree -->
  <path d="M16 24 L16 20 M13 22 L16 17 L19 22 M12 19 L16 14 L20 19" 
        fill="none" 
        stroke="#008000" 
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"/>
</svg>
</file>

<file path="public/logos/cornucopia.svg">
<svg width="400" height="100" viewBox="0 0 400 100" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Wave line -->
  <path 
    d="M20 40 Q100 40, 150 20, 200 30, 250 20, 300 30, 350 20, 380 30" 
    stroke="#2E7D32" 
    stroke-width="8" 
    stroke-linecap="round"
    fill="none"
  />
  
  <!-- Text with better positioning -->
  <text 
    x="20" 
    y="85" 
    font-family="Arial" 
    font-size="48" 
    font-weight="bold" 
    fill="#2E7D32"
    letter-spacing="2"
  >
    CORNUCOPIA
  </text>
</svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/sw.js">
// Service Worker for Cornucopia
// Provides offline capability and improved caching

const CACHE_NAME = 'cornucopia-v1';
const STATIC_CACHE = 'cornucopia-static-v1';
const DYNAMIC_CACHE = 'cornucopia-dynamic-v1';

// Assets to cache on install
const STATIC_ASSETS = [
  '/',
  '/offline',
  '/_next/static/css/app.css',
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('[SW] Installing service worker...');
  event.waitUntil(
    caches.open(STATIC_CACHE).then((cache) => {
      console.log('[SW] Caching static assets');
      return cache.addAll(STATIC_ASSETS.filter(url => !url.includes('undefined')));
    }).catch(err => {
      console.error('[SW] Failed to cache static assets:', err);
    })
  );
  self.skipWaiting();
});

// Activate event - cleanup old caches
self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE) {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  return self.clients.claim();
});

// Fetch event - network first with cache fallback
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Skip chrome extensions
  if (url.protocol === 'chrome-extension:') {
    return;
  }

  // API requests - network only
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(fetch(request));
    return;
  }

  // Images - cache first with network fallback
  if (request.destination === 'image') {
    event.respondWith(
      caches.match(request).then((cached) => {
        if (cached) {
          return cached;
        }
        return fetch(request).then((response) => {
          // Cache successful image responses
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open(DYNAMIC_CACHE).then((cache) => {
              cache.put(request, responseClone);
            });
          }
          return response;
        });
      })
    );
    return;
  }

  // Static assets - cache first
  if (url.pathname.startsWith('/_next/static/')) {
    event.respondWith(
      caches.match(request).then((cached) => {
        return cached || fetch(request).then((response) => {
          const responseClone = response.clone();
          caches.open(STATIC_CACHE).then((cache) => {
            cache.put(request, responseClone);
          });
          return response;
        });
      })
    );
    return;
  }

  // HTML pages - network first with cache fallback
  event.respondWith(
    fetch(request)
      .then((response) => {
        // Cache successful HTML responses
        if (response.status === 200 && request.headers.get('accept')?.includes('text/html')) {
          const responseClone = response.clone();
          caches.open(DYNAMIC_CACHE).then((cache) => {
            cache.put(request, responseClone);
          });
        }
        return response;
      })
      .catch(() => {
        // If network fails, try cache
        return caches.match(request).then((cached) => {
          if (cached) {
            return cached;
          }
          // Return offline page for HTML requests
          if (request.headers.get('accept')?.includes('text/html')) {
            return caches.match('/offline');
          }
        });
      })
  );
});
</file>

<file path="public/vercel.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 283 64"><path fill="black" d="M141 16c-11 0-19 7-19 18s9 18 20 18c7 0 13-3 16-7l-7-5c-2 3-6 4-9 4-5 0-9-3-10-7h28v-3c0-11-8-18-19-18zm-9 15c1-4 4-7 9-7s8 3 9 7h-18zm117-15c-11 0-19 7-19 18s9 18 20 18c6 0 12-3 16-7l-8-5c-2 3-5 4-8 4-5 0-9-3-11-7h28l1-3c0-11-8-18-19-18zm-10 15c2-4 5-7 10-7s8 3 9 7h-19zm-39 3c0 6 4 10 10 10 4 0 7-2 9-5l8 5c-3 5-9 8-17 8-11 0-19-7-19-18s8-18 19-18c8 0 14 3 17 8l-8 5c-2-3-5-5-9-5-6 0-10 4-10 10zm83-29v46h-9V5h9zM37 0l37 64H0L37 0zm92 5-27 48L74 5h10l18 30 17-30h10zm59 12v10l-3-1c-6 0-10 4-10 10v15h-9V17h9v9c0-5 6-9 13-9z"/></svg>
</file>

<file path="types/api.ts">
/**
 * Standard API Response Types
 * Provides consistent response structure across all API endpoints
 */

export interface ApiSuccessResponse<T = unknown> {
  success: true;
  data: T;
  message?: string;
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
    nextCursor?: string;
    hasMore?: boolean;
  };
}

export interface ApiErrorResponse {
  success: false;
  error: {
    message: string;
    code?: string;
    details?: unknown;
    field?: string;
  };
}

export type ApiResponse<T = unknown> = ApiSuccessResponse<T> | ApiErrorResponse;

/**
 * Pagination metadata
 */
export interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

/**
 * Cursor-based pagination
 */
export interface CursorPaginationMeta {
  nextCursor?: string;
  prevCursor?: string;
  hasMore: boolean;
  limit: number;
}

/**
 * Standard list response
 */
export interface ListResponse<T> {
  items: T[];
  pagination: PaginationMeta | CursorPaginationMeta;
}

/**
 * Type guard to check if response is successful
 */
export function isApiSuccess<T>(
  response: ApiResponse<T>
): response is ApiSuccessResponse<T> {
  return response.success === true;
}

/**
 * Type guard to check if response is an error
 */
export function isApiError(
  response: ApiResponse
): response is ApiErrorResponse {
  return response.success === false;
}
</file>

<file path="types/hours.ts">
export type TimeSlot = {
  open: string;   // 24h format "HH:mm"
  close: string;  // 24h format "HH:mm"
};

export type DaySchedule = {
  isOpen: boolean;
  timeSlots: TimeSlot[];
};

export type WeeklyHours = {
  monday: DaySchedule;
  tuesday: DaySchedule;
  wednesday: DaySchedule;
  thursday: DaySchedule;
  friday: DaySchedule;
  saturday: DaySchedule;
  sunday: DaySchedule;
};

export const DEFAULT_WEEKLY_HOURS: WeeklyHours = {
  monday: { isOpen: false, timeSlots: [] },
  tuesday: { isOpen: false, timeSlots: [] },
  wednesday: { isOpen: false, timeSlots: [] },
  thursday: { isOpen: false, timeSlots: [] },
  friday: { isOpen: false, timeSlots: [] },
  saturday: { isOpen: false, timeSlots: [] },
  sunday: { isOpen: false, timeSlots: [] }
};

export const DAYS_OF_WEEK = [
  'monday',
  'tuesday',
  'wednesday',
  'thursday',
  'friday',
  'saturday',
  'sunday'
] as const;

export type DayOfWeek = typeof DAYS_OF_WEEK[number];

export function formatTimeSlot(timeSlot: TimeSlot): string {
  const openTime = new Date(`1970-01-01T${timeSlot.open}`);
  const closeTime = new Date(`1970-01-01T${timeSlot.close}`);
  
  return `${openTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })} - ${closeTime.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
}

export function formatDaySchedule(schedule: DaySchedule): string {
  if (!schedule.isOpen || schedule.timeSlots.length === 0) {
    return 'Closed';
  }
  
  return schedule.timeSlots.map(formatTimeSlot).join(', ');
}
</file>

<file path="types/index.ts">
/**
 * Central type export file
 * Export all types from a single location for easier imports
 */

// API types
export * from './api';

// Domain types
export * from './user';
export * from './product';
export * from './marketStand';
export * from './hours';

// Common types
export interface Location {
  latitude: number;
  longitude: number;
  accuracy?: number;
}

export interface Coordinates {
  lat: number;
  lng: number;
  accuracy?: number;
  timestamp?: number;
}

export interface LocationData {
  coords: Coordinates;
  source: 'browser' | 'ip' | 'manual';
}

export interface Address {
  street?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
}

export interface Image {
  url: string;
  alt?: string;
  width?: number;
  height?: number;
}

export interface Tag {
  id: string;
  name: string;
  slug: string;
}

export interface SocialMedia {
  platform: 'facebook' | 'instagram' | 'twitter' | 'linkedin' | 'tiktok';
  url: string;
}

// Loading states
export interface LoadingState {
  isLoading: boolean;
  error: string | null;
}

export interface DataLoadingState<T> extends LoadingState {
  data: T | null;
}

// Form states
export interface FormState<T = unknown> {
  data: T;
  errors: Record<string, string>;
  isSubmitting: boolean;
  isDirty: boolean;
  isValid: boolean;
}

export interface FormFieldState {
  value: unknown;
  error: string | null;
  touched: boolean;
  dirty: boolean;
}
</file>

<file path="types/marketStand.ts">
/**
 * Market Stand types
 */

import { Status } from '@prisma/client';
import { WeeklyHours } from './hours';

export interface MarketStand {
  id: string;
  name: string;
  description: string | null;
  images: string[];
  tags: string[];
  latitude: number;
  longitude: number;
  locationName: string;
  locationGuide: string;
  website: string | null;
  socialMedia: string[];
  status: Status;
  isActive: boolean;
  hours: WeeklyHours | null;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
  averageRating: number | null;
  totalReviews: number;
}

export interface MarketStandWithDistance extends MarketStand {
  distanceKm: number;
}

export interface MarketStandWithProducts extends MarketStand {
  products: Array<{
    id: string;
    name: string;
    price: number;
    images: string[];
    inventory: number;
  }>;
  productCount: number;
}

export interface CreateMarketStandInput {
  name: string;
  description: string;
  locationName: string;
  locationGuide: string;
  latitude: number;
  longitude: number;
  website?: string | null;
  images: string[];
  tags: string[];
  socialMedia: string[];
  hours: WeeklyHours;
}

export interface UpdateMarketStandInput {
  name?: string;
  description?: string;
  locationName?: string;
  locationGuide?: string;
  latitude?: number;
  longitude?: number;
  website?: string | null;
  images?: string[];
  tags?: string[];
  socialMedia?: string[];
  hours?: WeeklyHours;
  status?: Status;
  isActive?: boolean;
}

export interface MarketStandFilters {
  userId?: string;
  isActive?: boolean;
  latitude?: number;
  longitude?: number;
  radiusKm?: number;
  tags?: string[];
  search?: string;
}

export interface MarketStandListResponse {
  marketStands: MarketStand[];
  total: number;
  hasMore: boolean;
  nextCursor?: string;
}
</file>

<file path="types/product.ts">
export interface Product {
  id: string;
  name: string;
  price: number;
  description: string;
  images: string[];
  inventory: number;
  inventoryUpdatedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
  marketStandId: string;
}

export interface ExtendedProduct extends Product {
  distance?: number;
  user?: {
    id: string;
    email: string;
    firstName: string;
    lastName: string;
    profileImage: string;
  };
  marketStand?: {
    id: string;
    name: string;
    latitude: number;
    longitude: number;
    locationName: string;
  };
}
</file>

<file path="types/user.ts">
/**
 * User-related types
 */

export interface User {
  id: string;
  email: string;
  firstName: string | null;
  lastName: string | null;
  profileImage: string | null;
  role: UserRole;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export enum UserRole {
  USER = 'USER',
  ADMIN = 'ADMIN',
  SELLER = 'SELLER',
}

export interface UserProfile extends User {
  phone?: string | null;
  bio?: string | null;
  address?: string | null;
  city?: string | null;
  state?: string | null;
  zipCode?: string | null;
  stripeAccountId?: string | null;
  stripeCustomerId?: string | null;
}

export interface AuthUser {
  id: string;
  email: string;
  role: UserRole;
}

export interface UserSettings {
  notifications: {
    email: boolean;
    push: boolean;
    marketing: boolean;
  };
  privacy: {
    showEmail: boolean;
    showPhone: boolean;
    showLocation: boolean;
  };
  preferences: {
    theme: 'light' | 'dark' | 'system';
    language: string;
    currency: string;
  };
}
</file>

<file path=".env.example">
# Database Configuration
DATABASE_URL="postgresql://user:password@localhost:5432/cornucopia?connection_limit=10&pool_timeout=20"

# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL="your-supabase-url"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-supabase-anon-key"
SUPABASE_SERVICE_ROLE_KEY="your-service-role-key"

# Redis Cache Configuration (Upstash)
UPSTASH_REDIS_REST_URL="https://your-redis-url.upstash.io"
UPSTASH_REDIS_REST_TOKEN="your-redis-token"

# Stripe Configuration
STRIPE_SECRET_KEY="sk_test_your_stripe_secret_key"
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_test_your_stripe_publishable_key"
STRIPE_WEBHOOK_SECRET="whsec_your_webhook_secret"

# Google Maps API
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY="your-google-maps-api-key"

# Application URLs
NEXT_PUBLIC_APP_URL="http://localhost:3000"

# Performance Monitoring (Optional)
SLOW_QUERY_THRESHOLD=1000

# Node Environment
NODE_ENV="development"
</file>

<file path=".eslintrc.json">
{
  "extends": ["next/core-web-vitals"],
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "rules": {
    "@typescript-eslint/no-unused-vars": "warn",
    "@typescript-eslint/no-explicit-any": "warn",
    "react/no-unescaped-entities": "off",
    "no-console": ["warn", { "allow": ["warn", "error"] }]
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  },
  "overrides": [
    {
      "files": ["lib/logger.ts"],
      "rules": {
        "no-console": "off"
      }
    }
  ]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment files
.env
.env*.local
!.env.local.template
.env.production

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# prisma
.prisma/client/
!.prisma/client/schema.prisma
</file>

<file path="AUTH_SETUP_INSTRUCTIONS.md">
# Authentication Setup Instructions

Follow these steps to configure authentication in your Supabase dashboard.

## Step 1: Configure Email Authentication

Email authentication should already be enabled by default, but let's verify:

1. **Navigate to Auth Providers:**
   - Go to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers

2. **Verify Email Provider:**
   - Scroll down to find "Email" in the providers list
   - It should show as "Enabled"
   - Click on "Email" to configure settings

3. **Email Settings (Optional):**
   - **Confirm email**: Toggle ON if you want users to confirm their email
   - **Secure email change**: Toggle ON for additional security
   - **Double confirm email change**: Toggle ON if you want extra confirmation
   - Click "Save" if you made changes

---

## Step 2: Configure Auth URL Settings

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/url-configuration

1. **Site URL:**
   - Set to: `http://localhost:3000`
   - For production, update to your production URL

2. **Redirect URLs:**
   Add these URLs (one per line):
   ```
   http://localhost:3000/auth/callback
   http://localhost:3000/dashboard
   http://localhost:3000/*
   ```

3. Click **Save**

---

## Step 3: Configure Google OAuth (Optional but Recommended)

### Part A: Create Google OAuth Credentials

1. **Go to Google Cloud Console:**
   - Navigate to: https://console.cloud.google.com/

2. **Create or Select Project:**
   - If you have an existing project, select it
   - Or click "New Project" to create one
   - Name it something like "Cornucopia Auth"

3. **Enable Google+ API (if needed):**
   - Go to "APIs & Services" → "Library"
   - Search for "Google+ API"
   - Click "Enable" if not already enabled

4. **Configure OAuth Consent Screen:**
   - Go to "APIs & Services" → "OAuth consent screen"
   - Choose "External" user type
   - Click "Create"
   - Fill in required fields:
     - **App name**: Cornucopia
     - **User support email**: Your email
     - **Developer contact**: Your email
   - Click "Save and Continue"
   - Skip scopes (or add email, profile if prompted)
   - Click "Save and Continue"
   - Add test users if in testing mode
   - Click "Save and Continue"

5. **Create OAuth 2.0 Credentials:**
   - Go to "APIs & Services" → "Credentials"
   - Click "Create Credentials" → "OAuth 2.0 Client ID"
   - Application type: **Web application**
   - Name: Cornucopia Supabase Auth
   
6. **Add Authorized Redirect URIs:**
   Click "Add URI" and add these two URLs:
   ```
   https://swhinhgrtcowjmpstozh.supabase.co/auth/v1/callback
   http://localhost:3000/auth/callback
   ```

7. **Create and Copy Credentials:**
   - Click "Create"
   - **IMPORTANT:** Copy the Client ID and Client Secret
   - Keep these safe - you'll need them in the next step

### Part B: Configure Google OAuth in Supabase

1. **Navigate to Auth Providers:**
   - Go to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers

2. **Find Google Provider:**
   - Scroll to find "Google" in the providers list
   - Click on "Google" to expand

3. **Enable and Configure:**
   - Toggle "Enable Sign in with Google" to **ON**
   - Paste your **Client ID** from Google Console
   - Paste your **Client Secret** from Google Console
   - Click "Save"

---

## Step 4: Verify Configuration

1. **Check Auth Providers Page:**
   - Email should show as "Enabled"
   - Google should show as "Enabled" (if you configured it)

2. **Check URL Configuration:**
   - Site URL should be set
   - Redirect URLs should be listed

---

## Testing Authentication

Once configured, test your auth:

1. **Start your dev server:**
   ```bash
   npm run dev
   ```

2. **Test Email Auth:**
   - Visit http://localhost:3000
   - Try signing up with email
   - Check your email for confirmation (if enabled)
   - Try logging in

3. **Test Google OAuth (if configured):**
   - Click "Sign in with Google"
   - Authorize with your Google account
   - Verify you're redirected back to your app

---

## Troubleshooting

### Email Auth Issues
- **Emails not sending?** Check Supabase → Authentication → Email Templates
- **Can't sign in?** Verify email confirmation is disabled or email was confirmed

### Google OAuth Issues
- **"Redirect URI mismatch" error:**
  - Double-check the redirect URI in Google Console matches exactly:
    `https://swhinhgrtcowjmpstozh.supabase.co/auth/v1/callback`
  - No trailing slashes, no typos

- **"App not verified" warning:**
  - This is normal for development
  - Add your email as a test user in Google Console
  - For production, submit app for verification

- **"Invalid client" error:**
  - Verify Client ID and Secret are correct in Supabase
  - Check they were copied completely without extra spaces

---

## Next Steps

After authentication is configured:

1. Run the SQL setup script (`supabase-setup.sql`) in Supabase SQL Editor
2. Test creating products and market stands
3. Test image uploads

Your Supabase authentication is now configured! 🎉
</file>

<file path="check-image-urls.sql">
-- Check the current state of image URLs
SELECT id, name, images[1] as current_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;

-- Try a more specific fix if the previous one didn't work
-- This assumes the URLs might have a different format than expected
UPDATE "Product"
SET images = ARRAY[
  CASE 
    -- If URL already contains 'products/' in the right place, leave it as is
    WHEN images[1] LIKE '%/public/products/%' THEN images[1]
    -- If URL ends with '/public/', add 'products/'
    WHEN images[1] LIKE '%/public/' THEN 
      SUBSTRING(images[1], 1, LENGTH(images[1])) || 'products/'
    -- If URL contains '/public/' but not at the end, insert 'products/' after it
    WHEN images[1] LIKE '%/public/%' THEN 
      REPLACE(images[1], '/public/', '/public/products/')
    -- Otherwise, leave it as is
    ELSE images[1]
  END
];

-- Check if we need to add the filename to the URL
-- If the URLs end with 'products/' but don't have a filename, we need to extract it from the original path
SELECT 
  id, 
  name, 
  images[1] as current_url,
  CASE
    WHEN images[1] LIKE '%/products/' THEN
      -- Extract filename from the original path if needed
      images[1] || SUBSTRING(
        REVERSE(images[1]), 
        1, 
        POSITION('/' IN REVERSE(images[1])) - 1
      )
    ELSE images[1]
  END as fixed_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;
</file>

<file path="ClineContext.txt">
Context:
- The project name is Cornucopia
- We are a directory for roadside marketstands with additional QR payment functionallity that can only be used when scanned at the roadside marketstands.
-   This is the current tech stack
    @tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/typography": "^0.5.15",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "eslint": "^8",
    "eslint-config-next": "14.2.3",
    "postcss": "^8.4.49",
    "prisma": "^5.22.0",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
    "google maps embeded api"

Exploration tasks:
1. Review current codebase structure
2. Identify key files and dependencies
3. Note existing patterns and styles
4. Find relevant examples or similar code

Requirements:
-If port 3000 is busy close all terminals and try again
-Do not nest imports deeply. Use @ routing whenever possible
-
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
</file>

<file path="fix-duplicate-products.sql">
-- First, let's check the current state of the URLs
SELECT id, name, images[1] as current_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;

-- Function to clean up URLs with duplicate 'products/' segments
CREATE OR REPLACE FUNCTION clean_url(url text) RETURNS text AS $$
DECLARE
  base_url text;
  file_path text;
  clean_path text;
BEGIN
  -- Extract the base URL (up to '/storage/v1/object/public/')
  base_url := substring(url from '^(https://[^/]+/storage/v1/object/public/)');
  
  -- Extract the file path (everything after '/public/')
  file_path := substring(url from '/public/(.*)$');
  
  -- Remove all 'products/' segments
  clean_path := regexp_replace(file_path, 'products/', '', 'g');
  
  -- Add back a single 'products/' at the beginning
  RETURN base_url || 'products/' || clean_path;
END;
$$ LANGUAGE plpgsql;

-- Test the function on one row
SELECT 
  id, 
  name, 
  images[1] as current_url,
  clean_url(images[1]) as fixed_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;

-- If the fixed URLs look correct, update all rows
UPDATE "Product"
SET images = ARRAY[clean_url(images[1])];

-- Verify the update
SELECT id, name, images[1] as updated_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;
</file>

<file path="fix-image-urls.sql">
-- First, let's test the transformation on one row to verify
SELECT 
  id,
  name,
  images[1] as current_url,
  REPLACE(images[1], '/public/', '/public/products/') as new_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 1;

-- If the above looks correct, run this to update all rows
UPDATE "Product"
SET images = ARRAY[
  REPLACE(images[1], '/public/', '/public/products/')
];
</file>

<file path="fix-urls-extract-filename.sql">
-- First, let's check the current state of the URLs
SELECT id, name, images[1] as current_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;

-- Function to extract just the filename and rebuild the URL
CREATE OR REPLACE FUNCTION rebuild_url(url text) RETURNS text AS $$
DECLARE
  filename text;
BEGIN
  -- Try to extract the filename using various patterns
  -- First try to get the last segment after the last slash
  filename := substring(url from '([^/]+)$');
  
  -- If that doesn't work, try to extract common filename patterns
  IF filename IS NULL OR length(filename) < 5 THEN
    -- Try to extract filenames like '173782505726-more_apples.jpeg'
    filename := substring(url from '(17[0-9]+-[a-zA-Z0-9_-]+\.[a-zA-Z]+)');
  END IF;
  
  -- If we still don't have a filename, use a default
  IF filename IS NULL OR length(filename) < 5 THEN
    filename := 'missing-filename.jpg';
  END IF;
  
  -- Build the correct URL
  RETURN 'https://swhinhgrtcowjmpstozh.supabase.co/storage/v1/object/public/products/' || filename;
END;
$$ LANGUAGE plpgsql;

-- Test the function on a few rows
SELECT 
  id, 
  name, 
  images[1] as current_url,
  rebuild_url(images[1]) as fixed_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;

-- If the fixed URLs look correct, update all rows
UPDATE "Product"
SET images = ARRAY[rebuild_url(images[1])];

-- Verify the update
SELECT id, name, images[1] as updated_url
FROM "Product"
WHERE array_length(images, 1) > 0
LIMIT 5;
</file>

<file path="middleware.ts">
import { createServerClient } from '@supabase/ssr';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  try {
    const pathname = request.nextUrl.pathname;
    const response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value, options }) => {
              request.cookies.set(name, value);
              response.cookies.set(name, value, options);
            });
          },
        },
      }
    );

    const { data: { session } } = await supabase.auth.getSession();

    // Check if this is an admin route
    if (pathname.startsWith('/admin')) {
      if (!session?.user) {
        return NextResponse.redirect(new URL('/auth/admin/login', request.url));
      }

      // Check user role from metadata
      const userRole = session.user.user_metadata?.role;
      if (!userRole || !['ADMIN', 'SUPER_ADMIN'].includes(userRole)) {
        console.log('[Middleware] Non-admin access attempt:', userRole);
        return NextResponse.redirect(new URL('/auth/admin/login', request.url));
      }

      return response;
    }

    // Handle other protected routes
    if (
      pathname.startsWith('/dashboard') || 
      pathname.startsWith('/settings') || 
      pathname.startsWith('/market-stand/setup') ||
      pathname.startsWith('/local/setup')
    ) {
      if (!session) {
        const loginUrl = new URL('/auth/login', request.url);
        loginUrl.searchParams.set('returnTo', pathname);
        return NextResponse.redirect(loginUrl);
      }
    }

    // Handle auth routes
    if (pathname.startsWith('/auth')) {
      // Allow access to admin login page
      if (pathname === '/auth/admin/login') {
        return response;
      }

      // Redirect authenticated users
      if (session) {
        const returnTo = request.nextUrl.searchParams.get('returnTo') || '/dashboard/market-stand';
        return NextResponse.redirect(new URL(returnTo, request.url));
      }
    }

    return response;
  } catch (error) {
    console.error('[Middleware] Error:', error);
    return NextResponse.next();
  }
}

export const config = {
  matcher: [
    // Match admin and protected routes
    '/admin/:path*',
    '/dashboard/:path*',
    '/auth/:path*',
    '/settings/:path*',
    '/market-stand/setup/:path*',
    '/local/setup/:path*'
  ]
};
</file>

<file path="next.config.mjs">
import { validateEnv } from './lib/env.server.mjs';

// Validate environment variables during build
if (process.env.NODE_ENV !== 'development') {
  validateEnv();
}

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Performance optimizations
  compress: true,
  poweredByHeader: false,
  
  experimental: {
    serverActions: {
      allowedOrigins: ['localhost:3000', 'cornucopia-dev.vercel.app'],
      bodySizeLimit: '2mb'
    },
    serverComponentsExternalPackages: ['@prisma/client', 'prisma'],
    optimizePackageImports: ['lucide-react', '@radix-ui/react-icons']
  },
  eslint: {
    ignoreDuringBuilds: true // Temporarily ignore ESLint during builds
  },
  webpack: (config, { isServer }) => {
    if (isServer) {
      config.externals.push('@prisma/client')
    }
    return config
  },
  output: 'standalone',
  async headers() {
    return [
      {
        source: '/_next/static/css/:path*',
        headers: [
          {
            key: 'Content-Type',
            value: 'text/css'
          }
        ]
      },
      {
        source: '/:path*',
        headers: [
          {
            key: 'Content-Security-Policy',
            value: `
              default-src 'self';
              script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdnjs.cloudflare.com https://*.googleapis.com https://maps.googleapis.com https://*.posthog.com;
              style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://maps.googleapis.com;
              img-src 'self' blob: data: https://*.supabase.co https://*.googleapis.com https://*.gstatic.com https://*.google.com https://maps.gstatic.com https://picsum.photos;
              font-src 'self' https://fonts.gstatic.com;
              connect-src 'self' https://*.supabase.co https://*.googleapis.com https://maps.googleapis.com https://*.posthog.com;
              frame-src 'self' https://www.google.com https://maps.google.com;
              base-uri 'self';
              form-action 'self';
            `.replace(/\s{2,}/g, ' ').trim()
          },
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin'
          },
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=()'
          }
        ]
      },
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Credentials', value: 'true' },
          { key: 'Access-Control-Allow-Origin', value: process.env.NEXT_PUBLIC_APP_URL || '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,DELETE,PATCH,POST,PUT' },
          { key: 'Access-Control-Allow-Headers', value: 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version' }
        ]
      }
    ]
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com',
        pathname: '/**'
      },
      {
        protocol: 'https',
        hostname: 'uploadthing.com',
        pathname: '/**'
      },
      {
        protocol: 'https',
        hostname: 'utfs.io',
        pathname: '/**'
      },
      {
        protocol: 'https',
        hostname: 'bzkj7i8mse.ufs.sh',
        pathname: '/**'
      },
      {
        protocol: 'https',
        hostname: 'swhinhgrtcowjmpstozh.supabase.co',
        pathname: '/storage/v1/object/public/**'
      },
      {
        protocol: 'https',
        hostname: 'swhinhgrtcowjmpstozh.supabase.co',
        pathname: '/storage/v1/object/public/**'
      },
      {
        protocol: 'https',
        hostname: 'picsum.photos',
        pathname: '/**'
      }
    ]
  }
}

export default nextConfig
</file>

<file path="package.json">
{
  "name": "cornucopia",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate"
  },
  "engines": {
    "node": ">=18.17.0"
  },
  "dependencies": {
    "@hello-pangea/dnd": "^17.0.0",
    "@prisma/client": "^6.2.1",
    "@prisma/extension-accelerate": "^1.2.1",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.2",
    "@react-email/components": "0.0.17",
    "@react-google-maps/api": "^2.20.5",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.12",
    "@tanstack/react-table": "^8.21.2",
    "@tiptap/pm": "^2.3.2",
    "@tiptap/react": "^2.3.2",
    "@tiptap/starter-kit": "^2.3.2",
    "@types/jsonwebtoken": "^9.0.7",
    "@types/lodash": "^4.17.13",
    "@upstash/ratelimit": "^2.0.5",
    "@upstash/redis": "^1.34.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "embla-carousel-react": "^8.0.4",
    "jsonwebtoken": "^9.0.2",
    "lodash": "^4.17.21",
    "lucide-react": "^0.378.0",
    "next": "^14.2.32",
    "next-themes": "^0.3.0",
    "posthog-js": "^1.223.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-error-boundary": "^5.0.0",
    "react-qr-code": "^2.0.15",
    "recharts": "^2.15.1",
    "resend": "^3.2.0",
    "sonner": "^1.7.4",
    "stripe": "^17.5.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@tailwindcss/aspect-ratio": "^0.4.2",
    "@tailwindcss/typography": "^0.5.15",
    "@types/google.maps": "^3.58.1",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.19.1",
    "@typescript-eslint/parser": "^8.19.1",
    "autoprefixer": "^10.4.20",
    "dotenv-cli": "^8.0.0",
    "eslint": "^8",
    "eslint-config-next": "^15.1.4",
    "postcss": "^8.4.49",
    "prisma": "^6.2.1",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
  }
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="README_PERFORMANCE.md">
# Performance Optimization Implementation Summary

This document provides a quick overview of the performance optimizations implemented in Cornucopia.

## 📋 What Was Implemented

### ✅ Frontend Optimizations

1. **React Server Components**
   - Converted homepage to use Server Components with Suspense
   - Implemented streaming for faster initial page load
   - Reduced JavaScript bundle size

2. **Image Optimization**
   - Updated all ProductCard images to use Next.js Image
   - Added blur placeholders
   - Configured responsive sizes
   - Optimized quality to 85%

3. **Loading States**
   - Created reusable ProductCardSkeleton component
   - Added ProductGridSkeleton for grid layouts
   - Implemented proper loading.tsx for route transitions
   - Added Suspense boundaries

4. **Caching Strategy**
   - Enabled ISR with 60-second revalidation
   - Created cache revalidation utilities
   - Implemented cache tags for granular control

5. **Service Worker**
   - Implemented offline support
   - Smart caching for static assets and images
   - Created offline fallback page
   - Auto-registration in production

6. **Configuration**
   - Enabled compression in next.config
   - Added package import optimization
   - Configured proper headers

### 📁 Files Created/Modified

**New Files:**
- `components/skeletons/ProductCardSkeleton.tsx` - Skeleton loading components
- `app/offline/page.tsx` - Offline fallback page
- `components/ServiceWorkerRegistration.tsx` - SW registration component
- `lib/cache/revalidation.ts` - Cache revalidation utilities
- `public/sw.js` - Service worker implementation
- `docs/FRONTEND_PERFORMANCE.md` - Frontend optimization guide
- `docs/PERFORMANCE_GUIDE.md` - Master performance guide

**Modified Files:**
- `app/page.tsx` - Added Suspense and ISR
- `app/loading.tsx` - Updated with new skeleton
- `app/layout.tsx` - Added service worker registration
- `components/ProductCard.tsx` - Optimized image loading
- `next.config.mjs` - Added performance optimizations

## 🚀 Performance Improvements

### Expected Results

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| Page Load Time | 3-5s | 1-2s | 50-60% |
| Time to Interactive | 4-6s | 2-3s | 40-50% |
| Image Size | 100% | 40-60% | 40-60% reduction |
| JavaScript Bundle | Baseline | -20-30% | 20-30% reduction |
| Offline Support | ❌ | ✅ | Full support |

### Core Web Vitals Targets

- **LCP** (Largest Contentful Paint): < 2.5s ✅
- **FID** (First Input Delay): < 100ms ✅
- **CLS** (Cumulative Layout Shift): < 0.1 ✅

## 📖 Documentation

Complete documentation is available in the `/docs` folder:

1. **[PERFORMANCE_GUIDE.md](./docs/PERFORMANCE_GUIDE.md)** - Master guide with setup instructions
2. **[FRONTEND_PERFORMANCE.md](./docs/FRONTEND_PERFORMANCE.md)** - Frontend optimization details
3. **[PERFORMANCE_OPTIMIZATION.md](./docs/PERFORMANCE_OPTIMIZATION.md)** - Backend optimization details

## 🛠️ Testing the Optimizations

### 1. Test Development Build

```bash
npm run dev
```

Visit http://localhost:3000 and check:
- [ ] Page loads with skeleton screens
- [ ] Images load with blur placeholders
- [ ] Smooth transitions between pages
- [ ] No console errors

### 2. Test Production Build

```bash
npm run build
npm start
```

Check:
- [ ] Service worker registers successfully
- [ ] Offline page works (disconnect network)
- [ ] Images are optimized (check Network tab)
- [ ] Fast page loads

### 3. Test Performance

Using Chrome DevTools:
1. Open DevTools → Lighthouse
2. Run performance audit
3. Check Core Web Vitals scores
4. Verify 90+ performance score

### 4. Test Caching

```bash
# Check Redis cache (if configured)
curl http://localhost:3000/api/admin/performance
```

### 5. Test Offline Mode

1. Load homepage
2. Open DevTools → Application → Service Workers
3. Enable "Offline" checkbox
4. Refresh page
5. Verify offline page appears

## 🎯 Next Steps

### Immediate Actions

1. Test all optimizations in development
2. Review and test in production
3. Monitor performance metrics
4. Gather user feedback

### Future Enhancements

The following optimizations are documented but not yet implemented:

1. **Optimistic UI Updates** - Instant feedback for user actions
2. **Partial Prerendering** - Static shell with dynamic content
3. **Edge Runtime** - Deploy to edge for lower latency
4. **View Transitions** - Smooth page transitions
5. **Additional Suspense Boundaries** - More granular loading states

See [FRONTEND_PERFORMANCE.md](./docs/FRONTEND_PERFORMANCE.md#future-optimizations) for details.

## 📊 Monitoring

### Development

Monitor performance during development:
- Use React DevTools Profiler
- Check Network tab for asset sizes
- Monitor console for warnings
- Test on slow 3G network

### Production

Set up monitoring tools:
- **Vercel Analytics** for page metrics
- **PostHog** for user behavior
- **Sentry** for error tracking
- **Upstash** for cache metrics

## ✅ Verification Checklist

Before deploying to production:

- [ ] All tests pass
- [ ] No console errors
- [ ] Service worker registers
- [ ] Images load optimized
- [ ] Offline mode works
- [ ] Cache invalidation works
- [ ] Performance score > 90
- [ ] Core Web Vitals pass
- [ ] Documentation is complete
- [ ] Team is trained on new patterns

## 🐛 Troubleshooting

### Common Issues

**Service Worker Not Registering:**
- Check that you're in production mode
- Verify sw.js is in public folder
- Check browser console for errors

**Images Not Optimizing:**
- Verify next/image is used
- Check remotePatterns in next.config.mjs
- Ensure images are from allowed domains

**Cache Not Working:**
- Verify Redis credentials in .env.local
- Check cache health endpoint
- Review TTL configurations

**Skeleton Screens Not Showing:**
- Check Suspense boundaries
- Verify loading.tsx exists
- Check for errors in console

## 📞 Support

For help with performance optimizations:

1. Check documentation in `/docs` folder
2. Review code comments
3. Check browser console for errors
4. Contact development team

## 🎉 Summary

This implementation provides a solid foundation for excellent performance:

- ✅ Fast initial page loads with streaming
- ✅ Optimized images with modern formats
- ✅ Smooth loading states with skeletons
- ✅ Offline support for better UX
- ✅ Smart caching strategies
- ✅ Comprehensive documentation

The application is now optimized for:
- Better user experience
- Improved SEO
- Lower bandwidth usage
- Higher conversion rates
- Better Core Web Vitals scores

---

**Implementation Date**: January 6, 2025  
**Version**: 1.0.0  
**Status**: ✅ Complete and Ready for Testing
</file>

<file path="README.md">
Phew that was a close one.
</file>

<file path="REFACTOR_PLAN.md">
# Cornucopia Refactoring Plan

## Overview
Comprehensive refactoring of the Cornucopia marketplace platform to improve architecture, security, performance, and maintainability.

**Branch**: `refactor/architecture-modernization`
**Started**: October 6, 2025

---

## Phase 1: Dependencies & Security Updates ⚡ HIGH PRIORITY

### Objectives
- Fix security vulnerabilities (21 total: 2 critical, 2 high, 10 moderate, 7 low)
- Migrate from deprecated Supabase packages
- Update to latest stable versions
- Ensure compatibility

### Tasks
- [ ] Run `npm audit` to identify all vulnerabilities
- [ ] Update Next.js to latest stable version
- [ ] Migrate from deprecated Supabase auth helpers to `@supabase/ssr`
  - Remove: `@supabase/auth-helpers-nextjs`, `@supabase/auth-helpers-react`
  - Update: `lib/auth.ts`, `lib/supabase-server.ts`, `lib/supabase-browser.ts`
- [ ] Update React and React-DOM if needed
- [ ] Update Prisma to latest
- [ ] Run `npm audit fix` for auto-fixable issues
- [ ] Manually review and fix remaining vulnerabilities
- [ ] Test all critical flows after updates

### Dependencies to Update
```json
{
  "next": "14.1.0" → "15.x or latest 14.x",
  "@supabase/auth-helpers-nextjs": "REMOVE",
  "@supabase/auth-helpers-react": "REMOVE",
  "@supabase/ssr": "keep and expand usage",
  "@prisma/client": "6.2.1" → "latest"
}
```

---

## Phase 2: Architecture Restructuring 🏗️

### Objectives
- Implement clean architecture patterns
- Separate concerns (presentation, business logic, data access)
- Create reusable service layer
- Improve testability

### Structure
```
lib/
  services/          # Business logic layer
    productService.ts
    marketStandService.ts
    localService.ts
    userService.ts
    authService.ts
    reviewService.ts
  repositories/      # Data access layer
    productRepository.ts
    marketStandRepository.ts
    localRepository.ts
  validators/        # Input validation with Zod
    productSchemas.ts
    marketStandSchemas.ts
  dto/              # Data Transfer Objects
    product.dto.ts
    marketStand.dto.ts
```

### Tasks
- [ ] Create service layer structure
- [ ] Implement repository pattern
- [ ] Extract business logic from server actions
- [ ] Create proper DTOs and validation schemas
- [ ] Implement error handling middleware
- [ ] Update server actions to use services

---

## Phase 3: Database Optimization 🗄️

### Objectives
- Optimize query performance
- Reduce N+1 queries
- Implement caching strategy
- Improve connection management

### Tasks
- [ ] Audit all Prisma queries for N+1 issues
- [ ] Implement proper query includes/selects
- [ ] Add Redis caching for frequently accessed data
  - Product listings
  - Market stand listings
  - User sessions
- [ ] Configure database connection pooling
- [ ] Review and optimize indexes
- [ ] Implement proper cursor-based pagination
- [ ] Add query performance monitoring

### Caching Strategy
```typescript
// Cache TTLs
- Product listings: 5 minutes
- Market stand data: 10 minutes
- User profile: 15 minutes
- Static content: 1 hour
```

---

## Phase 4: Code Organization 📁

### Objectives
- Standardize code structure
- Improve type safety
- Create reusable utilities
- Better error handling

### Tasks
- [ ] Consolidate all types in `types/` directory
- [ ] Create consistent API response types
- [ ] Implement custom hooks
  - `useProducts()`
  - `useMarketStands()`
  - `useAuth()`
  - `useUserLocation()`
- [ ] Extract shared utilities
- [ ] Implement error boundaries
- [ ] Standardize form handling
- [ ] Create consistent loading states

---

## Phase 5: Performance & UX Improvements ⚡

### Objectives
- Improve page load times
- Better user experience
- Optimize asset loading
- Implement proper caching

### Tasks
- [ ] Audit React Server Components usage
- [ ] Implement proper loading states
- [ ] Add skeleton screens
- [ ] Optimize image loading (Next.js Image)
- [ ] Implement optimistic updates
- [ ] Add proper data revalidation
- [ ] Implement streaming where applicable
- [ ] Add service worker for offline capability

---

## Phase 6: Testing & Documentation 📝

### Objectives
- Ensure code reliability
- Improve maintainability
- Better developer onboarding

### Tasks
- [ ] Add unit tests for services (Jest/Vitest)
- [ ] Add integration tests for API routes
- [ ] E2E tests for critical flows (Playwright)
- [ ] Document API patterns
- [ ] Create developer documentation
- [ ] Add code comments for complex logic
- [ ] Create architecture diagrams

---

## Migration Strategy

### Approach
1. **Incremental Migration**: Refactor one module at a time
2. **Feature Flags**: Use flags to toggle between old/new code
3. **Testing**: Thoroughly test each phase before moving to next
4. **Documentation**: Document changes as we go

### Risk Mitigation
- Keep main branch stable
- Regular commits on refactor branch
- Comprehensive testing at each phase
- Code reviews before merging
- Rollback plan for each phase

---

## Success Metrics

### Performance
- [ ] Page load time < 2s
- [ ] Time to interactive < 3s
- [ ] Lighthouse score > 90

### Code Quality
- [ ] Test coverage > 70%
- [ ] Zero critical security vulnerabilities
- [ ] TypeScript strict mode enabled
- [ ] ESLint warnings = 0

### Developer Experience
- [ ] Clear documentation
- [ ] Easy local setup
- [ ] Fast build times
- [ ] Good error messages

---

## Timeline

**Phase 1**: 2-3 days
**Phase 2**: 1 week
**Phase 3**: 3-4 days
**Phase 4**: 3-4 days
**Phase 5**: 1 week
**Phase 6**: Ongoing

**Total Estimated**: 3-4 weeks

---

## Notes

- All changes tracked in this branch: `refactor/architecture-modernization`
- Security vulnerabilities must be addressed first
- Breaking changes acceptable during refactor
- Focus on maintainability and scalability
</file>

<file path="SUPABASE_MIGRATION_CHECKLIST.md">
# Supabase Migration Checklist

Use this checklist to complete your Supabase migration. Check off each item as you complete it.

## ✅ Completed (Automated)

- [x] Created new Supabase project (swhinhgrtcowjmpstozh)
- [x] Updated `.env.local` with new Supabase credentials
- [x] Updated `.env` with database URLs for Prisma
- [x] Generated Prisma client
- [x] Updated `upload.ts` to use correct bucket names
- [x] Created SQL setup script (`supabase-setup.sql`)
- [x] Created setup guide (`SUPABASE_SETUP_GUIDE.md`)

## 🔲 Manual Steps Required

### 1. Wait for Database Migration to Complete
- [ ] Check terminal - the `npx prisma migrate deploy` command should complete
- [ ] Verify no errors in the migration output
- [ ] If migration fails, check troubleshooting section below

### 2. Run SQL Setup in Supabase Dashboard

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/sql

- [ ] Navigate to SQL Editor in Supabase dashboard (link above)
- [ ] Open `supabase-setup.sql` from your project
- [ ] Copy all SQL content
- [ ] Paste into Supabase SQL Editor
- [ ] Click "Run" to execute
- [ ] Verify success message (should see "Success. No rows returned")

This creates:
- UUID extension
- 4 storage buckets
- All RLS policies for storage

### 3. Configure Email Authentication

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers

- [ ] Go to Authentication → Providers
- [ ] Find "Email" provider
- [ ] Verify it's enabled (should be by default)
- [ ] Optional: Configure email templates or confirmation settings

### 4. Configure Google OAuth

**Part A: Get Google Credentials**
- [ ] Go to https://console.cloud.google.com/
- [ ] Create new project or select existing
- [ ] Navigate to "APIs & Services" → "Credentials"
- [ ] Click "Create Credentials" → "OAuth 2.0 Client ID"
- [ ] Choose "Web application"
- [ ] Add redirect URIs:
  - `https://swhinhgrtcowjmpstozh.supabase.co/auth/v1/callback`
  - `http://localhost:3000/auth/callback`
- [ ] Save and copy Client ID and Client Secret

**Part B: Configure in Supabase**

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers

- [ ] Go to Authentication → Providers
- [ ] Find "Google" provider
- [ ] Enable the provider
- [ ] Paste Client ID
- [ ] Paste Client Secret
- [ ] Save changes

### 5. Configure Auth URL Settings

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/url-configuration

- [ ] Set Site URL: `http://localhost:3000`
- [ ] Add Redirect URLs:
  - `http://localhost:3000/auth/callback`
  - `http://localhost:3000/dashboard`
  - `http://localhost:3000/*` (wildcard for all routes)
- [ ] Save changes
- [ ] Note: Update these with production URLs when deploying

### 6. Verify Storage Buckets Created

**URL:** https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/storage/buckets

- [ ] Navigate to Storage → Buckets
- [ ] Verify these buckets exist:
  - `product-images`
  - `market-stand-images`
  - `profile-images`
  - `local-images`
- [ ] All should be marked as "Public"

### 7. Test the Setup

**Start Development Server:**
```bash
npm run dev
```

**Test Authentication:**
- [ ] Visit http://localhost:3000
- [ ] Try signing up with email
- [ ] Try logging in with Google OAuth
- [ ] Verify successful login and redirect

**Test Database:**
- [ ] Log in to your app
- [ ] Try creating a market stand or product
- [ ] Verify data appears in Supabase database
- [ ] Check Supabase → Table Editor to see the data

**Test Image Upload:**
- [ ] Try uploading an image (product or profile)
- [ ] Verify upload succeeds
- [ ] Check Supabase → Storage to see the uploaded file
- [ ] Verify image displays correctly in your app

## 🔍 Verification

Once all steps are complete, verify:

- [ ] Users can sign up/login with email
- [ ] Users can sign up/login with Google
- [ ] Products/market stands can be created
- [ ] Images can be uploaded
- [ ] Images display correctly
- [ ] Database tables are populated correctly

## 🚨 Troubleshooting

### Migration Fails
If `npx prisma migrate deploy` fails:

1. **Check connection:**
   ```bash
   npx prisma db pull
   ```
   If this works, your connection is fine.

2. **Try direct URL instead of pooler:**
   - Temporarily change `DATABASE_URL` in `.env` to use `DIRECT_URL`
   - Run migration again
   - Change back after migration completes

3. **Verify credentials:**
   - Double-check password in `.env`
   - Ensure DATABASE_URL is formatted correctly

### Auth Not Working
- Verify all redirect URLs are correct (no typos)
- Check that Site URL matches your app URL
- For Google OAuth, ensure redirect URI in Google Console matches Supabase exactly
- Clear browser cookies and try again

### Images Not Uploading
- Verify storage buckets exist in Supabase dashboard
- Check that RLS policies were created (run supabase-setup.sql again if needed)
- Verify file size is under bucket limits (default 5MB)
- Check browser console for specific error messages

### Database Connection Issues
- Verify password is correct
- Try using DIRECT_URL instead of transaction pooler
- Check if IP is whitelisted (Supabase allows all by default)
- Verify project isn't paused in Supabase dashboard

## 📝 Notes

- **Environment Variables:** Keep `.env` and `.env.local` in sync for Supabase credentials
- **Production:** Remember to update redirect URLs and Site URL when deploying
- **Storage:** Images are organized by user ID (`bucket-name/user-id/filename`)
- **RLS:** Storage policies ensure users can only delete their own images but everyone can view

## ✅ Migration Complete!

Once all checklist items are complete, your Supabase migration is done! Your app should be fully functional with:
- Working authentication (email + Google)
- Database connected and migrated
- Image uploads to Supabase Storage
- All features operational

For ongoing management, bookmark your Supabase dashboard:
https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh
</file>

<file path="SUPABASE_SETUP_GUIDE.md">
# Supabase Setup Guide for Cornucopia

This guide will walk you through completing the Supabase migration for your Cornucopia project.

## Current Progress

✅ New Supabase project created  
✅ Environment variables updated in `.env.local` and `.env`  
✅ Prisma client generated  
⏳ Database migrations running (in progress)

## Next Steps to Complete

### 1. Run SQL Setup Script in Supabase

Once the Prisma migration completes, go to your Supabase dashboard and run the SQL setup:

1. Navigate to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/sql
2. Open the file `supabase-setup.sql` in this project
3. Copy all the SQL content
4. Paste it into the Supabase SQL Editor
5. Click "Run" to execute

This will:
- Enable the `uuid-ossp` extension
- Create 4 storage buckets (product-images, market-stand-images, profile-images, local-images)
- Set up Row Level Security policies for all buckets

### 2. Configure Authentication Providers

#### Email Authentication

1. Go to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers
2. Scroll to "Email" provider
3. Ensure it's **enabled**
4. Configure settings:
   - Enable email confirmations if desired
   - Customize email templates (optional)

#### Google OAuth

1. **First, get Google OAuth credentials:**
   - Go to: https://console.cloud.google.com/
   - Create a new project or select existing one
   - Go to "APIs & Services" → "Credentials"
   - Click "Create Credentials" → "OAuth 2.0 Client ID"
   - Application type: "Web application"
   - Add authorized redirect URIs:
     - `https://swhinhgrtcowjmpstozh.supabase.co/auth/v1/callback`
     - `http://localhost:3000/auth/callback` (for local testing)
   - Save and copy the Client ID and Client Secret

2. **Configure in Supabase:**
   - Go to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/providers
   - Find "Google" provider
   - Enable it
   - Enter your Client ID and Client Secret
   - Save

### 3. Configure Auth Settings

1. Go to: https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/auth/url-configuration
2. Set **Site URL**: `http://localhost:3000` (for development)
3. Add **Redirect URLs**:
   - `http://localhost:3000/auth/callback`
   - `http://localhost:3000/dashboard`
   - Add your production URLs when deploying

### 4. Update Upload Code for Supabase Storage

The file `app/actions/upload.ts` needs to be updated to use Supabase Storage instead of the current service. This will be done in the next step.

### 5. Test the Setup

Once everything is configured:

1. **Test Authentication:**
   ```bash
   npm run dev
   ```
   - Try signing up with email
   - Try logging in with Google
   - Verify you're redirected correctly

2. **Test Database:**
   - Create a test user
   - Create a test market stand
   - Verify data is saved in Supabase

3. **Test Image Upload:**
   - Once upload.ts is updated, test uploading images
   - Verify images appear in Supabase Storage

## Environment Variables Summary

Your project now uses these Supabase-related environment variables:

```env
NEXT_PUBLIC_SUPABASE_URL="https://swhinhgrtcowjmpstozh.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="[your-anon-key]"
SUPABASE_SERVICE_ROLE_KEY="[your-service-role-key]"
DATABASE_URL="[transaction-pooler-connection-string]"
DIRECT_URL="[direct-connection-string]"
```

## Storage Buckets Created

1. **product-images** - For product photos
2. **market-stand-images** - For market stand photos  
3. **profile-images** - For user avatars
4. **local-images** - For farm/local page images

All buckets are public for easy image display, with RLS policies ensuring only authenticated users can upload and users can only delete their own images.

## Important Files

- `.env.local` - Next.js environment variables (used by the app)
- `.env` - Prisma environment variables (used by Prisma CLI)
- `supabase-setup.sql` - SQL script to run in Supabase dashboard
- `prisma/schema.prisma` - Your database schema

## Troubleshooting

**If migrations fail:**
- Check your DATABASE_URL is correct
- Ensure your database password is correct
- Try using DIRECT_URL instead of transaction pooler for migrations

**If auth doesn't work:**
- Verify redirect URLs are correct in Supabase dashboard
- Check that Site URL matches your app URL
- Ensure Google OAuth credentials are correct

**If images don't upload:**
- Verify storage buckets exist in Supabase dashboard
- Check RLS policies are in place
- Ensure upload.ts is updated to use Supabase Storage

## Next: Update Upload Service

The final step is to update `app/actions/upload.ts` to use Supabase Storage. This will allow your app to store images in Supabase instead of the previous service.
</file>

<file path="supabase-setup.sql">
-- Supabase Setup SQL Script
-- Run this in your Supabase SQL Editor (https://supabase.com/dashboard/project/swhinhgrtcowjmpstozh/sql)

-- ============================================================================
-- STEP 1: Enable Required Extensions
-- ============================================================================

-- Enable UUID extension for generating UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;

-- ============================================================================
-- STEP 2: Create Storage Buckets
-- ============================================================================

-- Create bucket for product images
INSERT INTO storage.buckets (id, name, public)
VALUES ('product-images', 'product-images', true)
ON CONFLICT (id) DO NOTHING;

-- Create bucket for market stand images
INSERT INTO storage.buckets (id, name, public)
VALUES ('market-stand-images', 'market-stand-images', true)
ON CONFLICT (id) DO NOTHING;

-- Create bucket for profile images
INSERT INTO storage.buckets (id, name, public)
VALUES ('profile-images', 'profile-images', true)
ON CONFLICT (id) DO NOTHING;

-- Create bucket for local/farm images
INSERT INTO storage.buckets (id, name, public)
VALUES ('local-images', 'local-images', true)
ON CONFLICT (id) DO NOTHING;

-- ============================================================================
-- STEP 3: Storage Security Policies
-- ============================================================================

-- Product Images Policies
-- Allow authenticated users to upload
CREATE POLICY "Authenticated users can upload product images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'product-images');

-- Allow public to view product images
CREATE POLICY "Public can view product images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'product-images');

-- Allow users to update their own product images
CREATE POLICY "Users can update their own product images"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'product-images' AND auth.uid()::text = (storage.foldername(name))[1]);

-- Allow users to delete their own product images
CREATE POLICY "Users can delete their own product images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'product-images' AND auth.uid()::text = (storage.foldername(name))[1]);

-- Market Stand Images Policies
CREATE POLICY "Authenticated users can upload market stand images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'market-stand-images');

CREATE POLICY "Public can view market stand images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'market-stand-images');

CREATE POLICY "Users can update their own market stand images"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'market-stand-images' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Users can delete their own market stand images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'market-stand-images' AND auth.uid()::text = (storage.foldername(name))[1]);

-- Profile Images Policies
CREATE POLICY "Authenticated users can upload profile images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'profile-images');

CREATE POLICY "Public can view profile images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'profile-images');

CREATE POLICY "Users can update their own profile images"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'profile-images' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Users can delete their own profile images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'profile-images' AND auth.uid()::text = (storage.foldername(name))[1]);

-- Local/Farm Images Policies
CREATE POLICY "Authenticated users can upload local images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'local-images');

CREATE POLICY "Public can view local images"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'local-images');

CREATE POLICY "Users can update their own local images"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'local-images' AND auth.uid()::text = (storage.foldername(name))[1]);

CREATE POLICY "Users can delete their own local images"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'local-images' AND auth.uid()::text = (storage.foldername(name))[1]);

-- ============================================================================
-- SETUP COMPLETE
-- ============================================================================
-- Next steps:
-- 1. Run Prisma migrations: npx prisma migrate deploy
-- 2. Configure Auth providers in Supabase dashboard
-- 3. Test the setup
-- ============================================================================
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        pulse: {
          "0%, 100%": { opacity: "1" },
          "50%": { opacity: ".5" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "pulse-delayed": "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography"),
    require("@tailwindcss/aspect-ratio"),
  ],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/lib/*": ["lib/*"],
      "@/*": ["./*"],
      "@components/*": ["components/*"]
    },
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="vercel.json">
{
    "buildCommand": "prisma generate && next build",
    "framework": "nextjs",
    "installCommand": "npm install",
    "functions": {
      "app/api/**/*": {
        "maxDuration": 10
      }
    },
    "env": {
      "NEXT_PUBLIC_APP_URL": "cornucopialocal.com"
    }
  }
</file>

</files>
